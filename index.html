<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="IOT2014">
<meta property="og:type" content="website">
<meta property="og:title" content="blog | percy">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="blog | percy">
<meta property="og:description" content="IOT2014">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Percy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>blog | percy</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blog | percy</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/08/redis/%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/08/redis/%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" class="post-title-link" itemprop="url">不推荐使用redis分布式锁的原因</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-08 16:43:43 / 修改时间：16:58:17" itemprop="dateCreated datePublished" datetime="2022-07-08T16:43:43+08:00">2022-07-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>目前比较主流的分布式锁有两种选择：一种是使用redis集群做分布式锁，另外一种是使用zookeeper，这两种分布式锁有着各自的特点，但是在技术选型上，我还是推荐使用zookeeper来做分布式锁，至于为什么不推荐redis集群来做分布式锁，我会在下面阐述。</p>
<h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><h3 id="1-Consistency-一致性"><a href="#1-Consistency-一致性" class="headerlink" title="1.Consistency 一致性"></a>1.Consistency 一致性</h3><p>一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致，所以，一致性，说的就是数据一致性。分布式的一致性</p>
<p>对于一致性，可以分为从客户端和服务端两个不同的视角。从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。</p>
<p>一致性是因为有并发读写才有的问题，因此在理解一致性的问题时，一定要注意结合考虑并发读写的场景。</p>
<p>从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。</p>
<p>三种一致性策略</p>
<ul>
<li>对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。</li>
<li>如果能容忍后续的部分或者全部访问不到，则是弱一致性。</li>
<li>如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。</li>
</ul>
<p>CAP中说，不可能同时满足的这个一致性指的是强一致性。</p>
<h3 id="2-Availability-可用性"><a href="#2-Availability-可用性" class="headerlink" title="2.Availability 可用性"></a>2.Availability 可用性</h3><p>可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。</p>
<p>对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。所以，一般我们在衡量一个系统的可用性的时候，都是通过停机时间来计算的。</p>
<h3 id="3-Partition-Tolerance分区容错性"><a href="#3-Partition-Tolerance分区容错性" class="headerlink" title="3.Partition Tolerance分区容错性"></a>3.Partition Tolerance分区容错性</h3><p>分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</p>
<p>分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔未独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。</p>
<h2 id="为什么不建议使用redis分布锁"><a href="#为什么不建议使用redis分布锁" class="headerlink" title="为什么不建议使用redis分布锁"></a>为什么不建议使用redis分布锁</h2><h3 id="主从切换可能丢失锁信息"><a href="#主从切换可能丢失锁信息" class="headerlink" title="主从切换可能丢失锁信息"></a>主从切换可能丢失锁信息</h3><p>考虑一下这样的场景：在分布式环境中，很多并发需要锁来同步，当使用redis分布式锁，通用的做法是使用redis的setnx key value px 这样的命令，设置一个字段，当设置成功说明获取锁，设置不成功说明锁被占用，当获取所之后需要删除锁，也就是删除设置的锁字段，这是锁可以被其他占用。</p>
<p>这里在主从切换回出现问题，当第一个线程在主服务器上设置了锁，但是这时候从服务器并没有及时同步主服务器的状态，也就是没有同步主服务器中的锁字段，而此时，主服务器挂了，redis的哨兵模式升级从服务器为主服务器，如果在并发量大的情况下，虽然第一个线程获取了锁，其他线程会在当前的主服务器（之前的从服务器，但是并没有同步已经设置的锁字段）上设置锁字段，这样并不能保证锁的互斥性。</p>
<h3 id="缓存易失性"><a href="#缓存易失性" class="headerlink" title="缓存易失性"></a>缓存易失性</h3><p>假如第一个线程设置了锁，但是之后触发内存淘汰机制很不幸淘汰了设置的锁字段，接下来的线程在第一个线程没有释放锁的情况下，也是重新设置锁字段的，这样并不能保证锁的安全性。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>但是如果不在意上诉问题，其实可以用 redis 做分布式锁，毕竟简单。</p>
<h2 id="redis-分布式锁的挑战"><a href="#redis-分布式锁的挑战" class="headerlink" title="redis 分布式锁的挑战"></a>redis 分布式锁的挑战</h2><h3 id="执行时间超过锁的过期时间"><a href="#执行时间超过锁的过期时间" class="headerlink" title="执行时间超过锁的过期时间"></a>执行时间超过锁的过期时间</h3><ul>
<li>客户 1 获取锁成功并设置 30 秒超时;</li>
<li>客户 1 因为一些原因导致执行很慢(网络问题、发生 FullGC……)，过了 30 秒依然没执行完，但是锁过期「自动释放了」;</li>
<li>客户 2 申请加锁成功;</li>
<li>客户 1 执行完成，执行 DEL 释放锁指令，这个时候就把 客户 2 的锁给释放了。</li>
</ul>
<h4 id="锁续期"><a href="#锁续期" class="headerlink" title="锁续期"></a>锁续期</h4><p>我们可以让获得锁的线程开启一个守护线程，用来给快要过期的锁「续航」。加锁的时候设置一个过期时间，同时客户端开启一个「守护线程」，定时去检测这个锁的失效时间。如果快要过期，但是业务逻辑还没执行完成，自动对这个锁进行续期，重新设置过期时间。</p>
<h3 id="避免释放别人的锁"><a href="#避免释放别人的锁" class="headerlink" title="避免释放别人的锁"></a>避免释放别人的锁</h3><p>在释放锁的时候，客户端将自己的「唯一标识」与锁上的「标识」比较是否相等，匹配上则删除，否则没有权利释放锁。通过 SET lock_resource_name $unique_id NX PX $expire_time，同时启动守护线程为快要过期单还没执行完毕的客户端的锁续命。由于是多个指令所以需要 lua 脚本来保证原子性。</p>
<h3 id="解决-redis-主从切换的问题"><a href="#解决-redis-主从切换的问题" class="headerlink" title="解决 redis 主从切换的问题"></a>解决 redis 主从切换的问题</h3><p>如果客户端 1 刚往 master 节点写入一个分布式锁，此时这个指令还没来得及同步到 slave 节点。此时，master 节点宕机，其中一个 slave 被选举为新 master，这时候新 master 是没有客户端 1 写入的锁，锁丢失了。此刻，客户端 2 线程来获取锁，就成功了。</p>
<p>虽然这个概率极低，但是我们必须得承认这个风险的存在。Redis 的作者为了统一分布式锁的标准，搞了一个 Redlock，算是 Redis 官方对于实现分布式锁的指导规范，<a target="_blank" rel="noopener" href="https://redis.io/topics/distlock%EF%BC%8C%E4%BD%86%E6%98%AF%E8%BF%99%E4%B8%AA">https://redis.io/topics/distlock，但是这个</a> Redlock 也被国外的一些分布式专家给喷了。</p>
<p>太麻烦不看了</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/MOVIE14/article/details/82053391">https://blog.csdn.net/MOVIE14/article/details/82053391</a></p>
<p><a target="_blank" rel="noopener" href="https://www.51cto.com/article/689646.html">https://www.51cto.com/article/689646.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/29/golang/golang%20context/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/29/golang/golang%20context/" class="post-title-link" itemprop="url">golang context</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-29 16:03:44" itemprop="dateCreated datePublished" datetime="2022-01-29T16:03:44+08:00">2022-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-26 23:35:58" itemprop="dateModified" datetime="2023-02-26T23:35:58+08:00">2023-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="什么是-context"><a href="#什么是-context" class="headerlink" title="什么是 context"></a>什么是 context</h2><p>本质上 Go 语言是基于 context 来实现和搭建了各类 goroutine 控制的，并且与 select-case 联合，就可以实现进行上下文的截止时间、信号控制、信息传递等跨 goroutine 的操作，是 Go 语言协程的重中之重。</p>
<p>**在 Goroutine 构成的树形结构中对信号进行同步以减少计算资源的浪费是 context.Context 的最大作用。 context 的树形结构 对应着的就是 Goroutine 的树形结构 **</p>
<p><strong>context 通过构建链表式的结构来实现多层级的 cancel 传递，而 timeout 的逻辑也是通过传递一个 “context deadline exceeded” 的 cancel 错误来实现所有的 信号的统一。</strong></p>
<h2 id="context-本质"><a href="#context-本质" class="headerlink" title="context 本质"></a>context 本质</h2><p>我们在基本特性中介绍了不少 context 的方法，其基本大同小异。看上去似乎不难，接下来我们看看其底层的基本原理和设计。</p>
<p>context 相关函数的标准返回如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithXXXX</span><span class="params">(parent Context, xxx xxx)</span></span> (Context, CancelFunc)</span><br></pre></td></tr></table></figure>

<p>其返回值分别是 <code>Context</code> 和 <code>CancelFunc</code>，接下来我们将进行分析这两者的作用。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="Context-接口："><a href="#Context-接口：" class="headerlink" title="Context 接口："></a>Context 接口：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Deadline：获取当前 context 的截止时间。</li>
<li>Done：获取一个只读的 channel，类型为结构体。可用于识别当前 channel <strong>是否已经被关闭</strong>，其原因可能是到期，也可能是被取消了。</li>
<li>Err：获取当前 context <strong>被关闭的原因</strong>。</li>
<li>Value：获取当前 context 对应所存储的上下文信息。</li>
</ul>
<h4 id="Canceler-接口："><a href="#Canceler-接口：" class="headerlink" title="Canceler 接口："></a>Canceler 接口：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line"> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>)</span><br><span class="line"> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>cancel：调用当前 context 的取消方法。</li>
<li>Done：与前面一致，可用于识别当前 channel 是否已经被关闭。</li>
</ul>
<h2 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h2><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/yiFBNR"><img src="https://s3.ax1x.com/2021/01/29/yiFBNR.png" alt="yiFBNR.png"></a></p>
<p>在标准库 context 的设计上，一共提供了四类 context 类型来实现上述接口。分别是 <code>emptyCtx</code>、<code>cancelCtx</code>、<code>timerCtx</code> 以及 <code>valueCtx</code>。</p>
<h3 id="emptyCtx"><a href="#emptyCtx" class="headerlink" title="emptyCtx"></a>emptyCtx</h3><p>在日常使用中，常常使用到的 <code>context.Background</code> 方法，又或是 <code>context.TODO</code> 方法。</p>
<p>源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line"> background = new(emptyCtx)</span><br><span class="line"> todo       = new(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Background() Context &#123;</span><br><span class="line"> return background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TODO() Context &#123;</span><br><span class="line"> return todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其本质上都是基于 <code>emptyCtx</code> 类型的基本封装。而 <code>emptyCtx</code> 类型本质上是实现了 Context 接口：</p>
<p>实际上 <code>emptyCtx</code> 类型的 context 的实现非常简单，因为他是空 context 的定义，因此没有 deadline，更没有 timeout，可以认为就是一个基础空白 context 模板。</p>
<h3 id="cancelCtx"><a href="#cancelCtx" class="headerlink" title="cancelCtx"></a>cancelCtx</h3><p>在调用 <code>context.WithCancel</code> 方法时，我们会涉及到 <code>cancelCtx</code> 类型，其主要特性是取消事件。源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line"> c := newCancelCtx(parent)</span><br><span class="line"> propagateCancel(parent, &amp;c)</span><br><span class="line"> <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span></span> cancelCtx &#123;</span><br><span class="line"> <span class="keyword">return</span> cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的 <code>newCancelCtx</code> 方法将会生成出一个可以取消的新 context，如果该 context 执行取消，与其相关联的子 context 以及对应的 goroutine 也会收到取消信息。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>首先 main goroutine 创建并传递了一个新的 context 给 goroutine b，此时 goroutine b 的 context 是 main goroutine context 的子集：</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/yik0sS"><img src="https://s3.ax1x.com/2021/01/29/yik0sS.png" alt="yik0sS.png"></a></p>
<p>传递过程中，goroutine b 再将其 context 一个个传递给了 goroutine c、d、e。最后在运行时 goroutine b 调用了 <code>cancel</code> 方法。使得该 context 以及其对应的子集均接受到取消信号，对应的 goroutine 也进行了响应。</p>
<h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopWithContext</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> data := &lt;-ctx.Done():</span><br><span class="line">				fmt.Println(<span class="string">&quot;监控退出，停止了...&quot;</span>, data, ctx.Err())</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				fmt.Println(<span class="string">&quot;goroutine监控中...&quot;</span>)</span><br><span class="line">				time.Sleep(<span class="number">200</span> * time.Millisecond)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(ctx)</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	cancel()</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A cancelCtx can be canceled. When canceled, it also cancels any children</span></span><br><span class="line"><span class="comment">// that implement canceler.</span></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line"></span><br><span class="line">	mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">	done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;         <span class="comment">// created lazily, closed by first cancel call</span></span><br><span class="line">	children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">	err      <span class="type">error</span>                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">		<span class="keyword">return</span> c</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	d := c.done</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	err := c.err</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cancel 函数， 可以看到，对所有的子 context 也调用的 cancel</span></span><br><span class="line"><span class="comment">// cancel closes c.done, cancels each of c&#x27;s children, and, if</span></span><br><span class="line"><span class="comment">// removeFromParent is true, removes c from its parent&#x27;s children.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;context: internal error: missing cancel error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.mu.Unlock()</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.err = err</span><br><span class="line">	<span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.done = closedchan</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">close</span>(c.done)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">		<span class="comment">// <span class="doctag">NOTE:</span> acquiring the child&#x27;s lock while holding parent&#x27;s lock.</span></span><br><span class="line">		child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	c.children = <span class="literal">nil</span></span><br><span class="line">	c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">		removeChild(c.Context, c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="timerCtx"><a href="#timerCtx" class="headerlink" title="timerCtx"></a>timerCtx</h3><p>在调用 <code>context.WithTimeout</code> 方法时，我们会涉及到 <code>timerCtx</code> 类型，其主要特性是 Timeout 和 Deadline 事件，源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line"> <span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line"> ...</span><br><span class="line"> c := &amp;timerCtx&#123;</span><br><span class="line">  cancelCtx: newCancelCtx(parent),</span><br><span class="line">  deadline:  d,</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以发现 <code>timerCtx</code> 类型是基于 <code>cancelCtx</code> 类型的。我们再进一步看看 <code>timerCtx</code> 结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A timerCtx carries a timer and a deadline. It embeds a cancelCtx to</span></span><br><span class="line"><span class="comment">// implement Done and Err. It implements cancel by stopping its timer then</span></span><br><span class="line"><span class="comment">// delegating to cancelCtx.cancel.</span></span><br><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	cancelCtx</span><br><span class="line">	timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">	deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h4><h5 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> c.deadline, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"> c.cancelCtx.cancel(<span class="literal">false</span>, err)</span><br><span class="line"> <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">  removeChild(c.cancelCtx.Context, c)</span><br><span class="line"> &#125;</span><br><span class="line"> c.mu.Lock()</span><br><span class="line"> <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">  c.timer.Stop()</span><br><span class="line">  c.timer = <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br><span class="line"> c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cancel 先会调用 <code>cancelCtx</code> 类型的取消事件。若存在父级节点，则移除当前 context 子节点，最后停止定时器并进行定时器重置。而 Deadline 或 Timeout 的行为则由 <code>timerCtx</code> 的 <code>WithDeadline</code> 方法实现：</p>
<h5 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">    <span class="comment">// 进行前置判断，若父级节点的 Deadline 时间早于当前所指定的 Deadline 时间，将会直接生成一个 cancelCtx 的 context。</span></span><br><span class="line">	<span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">		<span class="comment">// The current deadline is already sooner than the new one.</span></span><br><span class="line">		<span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">	dur := time.Until(d)</span><br><span class="line">	<span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line">		<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 开启了一个 timer</span></span><br><span class="line">		c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="valueCtx"><a href="#valueCtx" class="headerlink" title="valueCtx"></a>valueCtx</h3><p>在调用 <code>context.WithValue</code> 方法时，我们会涉及到 <code>valueCtx</code> 类型，其主要特性是涉及上下文信息传递，源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context &#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本质上 `valueCtx` 类型是一个单向链表，会在调用 `Value` 方法时先查询自己的节点是否有该值。若无，则会通过自身存储的上层父级节点的信息一层层向上寻找对应的值，直到找到为止。！！！</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">		<span class="keyword">return</span> c.val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="context-取消事件"><a href="#context-取消事件" class="headerlink" title="context 取消事件"></a>context 取消事件</h2><p>在我们针对 context 的各类延伸类型和源码进行了分析后。我们进一步提出一个疑问点，<strong>context 是如何实现跨 goroutine 的取消事件并传播开来的，是如何实现的</strong>？</p>
<p>这个问题的答案就在于 <code>WithCancel</code> 和 <code>WithDeadline</code> 都会涉及到 <code>propagateCancel</code> 方法，其作用是构建父子级的上下文的关联关系，若出现取消事件时，就会进行处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// propagateCancel arranges for child to be canceled when parent is.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 当父级上下文（parent）的 Done 结果为 nil 时，将会直接返回，因为其不会具备取消事件的基本条件，可能该 context 是 Background、TODO 等方法产生的空白 context。</span></span><br><span class="line">	done := parent.Done()</span><br><span class="line">	<span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当父级上下文（parent）的 Done 结果不为 nil 时，则发现父级上下文已经被取消，作为其子级，该 context 将会触发取消事件并返回父级上下文的取消原因。双检查机制</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-done:</span><br><span class="line">		<span class="comment">// parent is already canceled</span></span><br><span class="line">		child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 经过前面一个代码片段的判断，已得知父级 context 未触发取消事件，当前父级和子级 context 均正常（未取消）。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">		p.mu.Lock()</span><br><span class="line">		<span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// parent has already been canceled</span></span><br><span class="line">			child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">				p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 调用 parentCancelCtx 方法找到具备取消功能的父级 context。并将当前 context，也就是 child 加入到 父级 context 的 children 列表中，等待后续父级 context 的取消事件通知和响应。(这样就能像链表一样实现整个 ctx 链路的传输了)</span></span><br><span class="line">			p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p.mu.Unlock()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 parentCancelCtx 方法没有找到，将会启动一个新的 goroutine 去监听父子 context 的取消事件通知。</span></span><br><span class="line">		atomic.AddInt32(&amp;goroutines, +<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">				child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">			<span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过对 context 的取消事件和整体源码分析，可得知 <code>cancelCtx</code> 类型的上下文包含了其下属的所有子节点信息。</strong>也就是其在 <code>children</code> 属性的 <code>map[canceler]struct&#123;&#125;</code> 存储结构上就已经支持了子级关系的查找，也就自然可以进行取消事件传播了。</p>
<p><code>而具体的取消事件的实际行为，则是在前面提到的 </code>propagateCancel<code>方法中，会在执行例如</code>cacenl&#96; 方法时，会对父子级上下文分别进行状态判断，若满足则进行取消事件，并传播给子级同步取消。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>我们可以通过一个代码片段了解 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 是如何对信号进行同步的。在这段代码中，我们创建了一个过期时间为 1s 的上下文，并向上下文传入 <code>handle</code> 函数，该方法会使用 500ms 的时间处理传入的请求：</p>
<ul>
<li>因为过期时间大于处理时间，所以我们有足够的时间处理该请求</li>
<li>如果我们将处理请求时间增加至 1500ms，整个程序都会因为上下文的过期而被中止，：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">1</span>*time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> handle(ctx, <span class="number">500</span>*time.Millisecond)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		fmt.Println(<span class="string">&quot;main&quot;</span>, ctx.Err())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(ctx context.Context, duration time.Duration)</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		fmt.Println(<span class="string">&quot;handle&quot;</span>, ctx.Err())</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(duration):</span><br><span class="line">		fmt.Println(<span class="string">&quot;process request with&quot;</span>, duration)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作为 Go 语言的核心功能之一，其实标准库 context 非常的短小精悍，使用的都是基本的数据结构和理念。既满足了跨 goroutine 的调控控制，像是并发、超时控制等。</p>
<p>同时也满足了上下文的信息传递。在工程应用中，例如像是链路ID、公共参数、鉴权校验等，都会使用到 context 作为媒介。</p>
<p>目前官方对于 context 的建议是作为方法的首参数传入，虽有些麻烦，但也有人选择将其作为结构体中的一个属性传入。但这也会带来一些心智负担，需要识别是否重新 new 一个。</p>
<p>也有人提出希望 Go2 取消掉 context，换成另外一种方法，但总体而言目前未见到正式的提案，这是我们都需要再思考的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/A03G3_kCvVFN3TxB-92GVw">一文吃透 Go 语言解密之上下文 context</a></p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/">上下文 Context</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/18/database/bblot/db/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/18/database/bblot/db/" class="post-title-link" itemprop="url">bblot db</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-18 00:00:00 / 修改时间：20:43:44" itemprop="dateCreated datePublished" datetime="2021-07-18T00:00:00+08:00">2021-07-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/bblot/" itemprop="url" rel="index"><span itemprop="name">bblot</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>前面我们介绍了boltdb底层在磁盘上数据时如何组织存储(page)的，然后又介绍了磁盘中的数据在内存中又是如何存储(node)的。接着我们又介绍了管理kv数据集合的Bucket对象以及用来遍历Bucket的Cursor对象。最后我们详细的介绍了boltdb中事务是如何实现(Tx)的。到此boltdb中 各个零散的部件我们都一一熟悉了，接下来是时候将他们组织在一起工作了。因而就有了boltdb中最上层的DB对象。本章主要介绍DB对象相关的方法以及其内部实现。</p>
<h2 id="DB结构"><a href="#DB结构" class="headerlink" title="DB结构"></a>DB结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DB represents a collection of buckets persisted to a file on disk.</span></span><br><span class="line"><span class="comment">// All data access is performed through transactions which can be obtained through the DB.</span></span><br><span class="line"><span class="comment">// All the functions on DB will return a ErrDatabaseNotOpen if accessed before Open() is called.</span></span><br><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">    path     <span class="type">string</span></span><br><span class="line">    file     *os.File  <span class="comment">// 真实存储数据的磁盘文件</span></span><br><span class="line">    lockfile *os.File <span class="comment">// windows only</span></span><br><span class="line">    dataref  []<span class="type">byte</span>   <span class="comment">// mmap&#x27;ed readonly, write throws SEGV</span></span><br><span class="line">    <span class="comment">// 通过mmap映射进来的地址</span></span><br><span class="line">    data   *[maxMapSize]<span class="type">byte</span></span><br><span class="line">    datasz <span class="type">int</span></span><br><span class="line">    filesz <span class="type">int</span> <span class="comment">// current on disk file size</span></span><br><span class="line">    <span class="comment">//  元数据</span></span><br><span class="line">    meta0 *meta</span><br><span class="line">    meta1 *meta</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对外接口"><a href="#对外接口" class="headerlink" title="对外接口"></a>对外接口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建数据库接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(path <span class="type">string</span>, mode os.FileMode, options *Options)</span></span> (*DB, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<h2 id="db-View-实现分析"><a href="#db-View-实现分析" class="headerlink" title="db.View()实现分析"></a>db.View()实现分析</h2><p>View()主要用来执行只读事务。事务的开启、提交、回滚都交由tx控制。</p>
<h2 id="db-Update-实现分析"><a href="#db-Update-实现分析" class="headerlink" title="db.Update()实现分析"></a>db.Update()实现分析</h2><p>Update()主要用来执行读写事务。事务的开始、提交、回滚都交由tx内部控制</p>
<h2 id="db-Batch-实现分析"><a href="#db-Batch-实现分析" class="headerlink" title="db.Batch()实现分析"></a>db.Batch()实现分析</h2><p>现在对Batch()方法稍作分析，在DB定义的那一节中我们可以看到，一个DB对象拥有一个batch对象，该对象是全局的。当我们使用Batch()方法时，内部会对将传递进去的fn缓存在calls中。</p>
<p>其内部也是调用了Update，只不过是在Update内部遍历之前缓存的calls。</p>
<p>有两种情况会触发调用Update。</p>
<ol>
<li>第一种情况是到达了MaxBatchDelay时间，就会触发Update</li>
<li>第二种情况是len(db.batch.calls) &gt;&#x3D; db.MaxBatchSize，即缓存的calls个数大于等于MaxBatchSize时，也会触发Update。</li>
</ol>
<p><strong>Batch的本质是：</strong> 将每次写、每次刷盘的操作转变成了多次写、一次刷盘，从而提升性能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 幂等</span></span><br><span class="line"><span class="comment">// The maximum batch size and delay can be adjusted with DB.MaxBatchSize</span></span><br><span class="line"><span class="comment">// and DB.MaxBatchDelay, respectively.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Batch is only useful when there are multiple goroutines calling it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Batch(fn <span class="function"><span class="keyword">func</span><span class="params">(*Tx)</span></span> <span class="type">error</span>) <span class="type">error</span> &#123;</span><br><span class="line">    errCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="number">1</span>)</span><br><span class="line">    db.batchMu.Lock()</span><br><span class="line">    <span class="keyword">if</span> (db.batch == <span class="literal">nil</span>) || (db.batch != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(db.batch.calls) &gt;= db.MaxBatchSize) &#123;</span><br><span class="line">        <span class="comment">// There is no existing batch, or the existing batch is full; start a new one.</span></span><br><span class="line">        db.batch = &amp;batch&#123;</span><br><span class="line">            db: db,</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 超时控制</span></span><br><span class="line">        db.batch.timer = time.AfterFunc(db.MaxBatchDelay, db.batch.trigger)</span><br><span class="line">    &#125;</span><br><span class="line">    db.batch.calls = <span class="built_in">append</span>(db.batch.calls, call&#123;fn: fn, err: errCh&#125;)</span><br><span class="line">  	<span class="comment">// 数量控制</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(db.batch.calls) &gt;= db.MaxBatchSize &#123;</span><br><span class="line">        <span class="comment">// wake up batch, it&#x27;s ready to run</span></span><br><span class="line">        <span class="keyword">go</span> db.batch.trigger()</span><br><span class="line">    &#125;</span><br><span class="line">    db.batchMu.Unlock()</span><br><span class="line">    err := &lt;-errCh</span><br><span class="line">    <span class="keyword">if</span> err == trySolo &#123;</span><br><span class="line">        err = db.Update(fn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run performs the transactions in the batch and communicates results</span></span><br><span class="line"><span class="comment">// back to DB.Batch.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *batch)</span></span> run() &#123;</span><br><span class="line">	b.db.batchMu.Lock()</span><br><span class="line">	b.timer.Stop()</span><br><span class="line">	<span class="comment">// Make sure no new work is added to this batch, but don&#x27;t break</span></span><br><span class="line">	<span class="comment">// other batches.</span></span><br><span class="line">	<span class="keyword">if</span> b.db.batch == b &#123;</span><br><span class="line">		b.db.batch = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	b.db.batchMu.Unlock()</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(b.calls) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> failIdx = <span class="number">-1</span></span><br><span class="line">		err := b.db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *Tx)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">			<span class="comment">// 遍历函数函数调用</span></span><br><span class="line">			<span class="keyword">for</span> i, c := <span class="keyword">range</span> b.calls &#123;</span><br><span class="line">				<span class="keyword">if</span> err := safelyCall(c.fn, tx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					failIdx = i</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> failIdx &gt;= <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// take the failing transaction out of the batch. it&#x27;s</span></span><br><span class="line">			<span class="comment">// safe to shorten b.calls here because db.batch no longer</span></span><br><span class="line">			<span class="comment">// points to us, and we hold the mutex anyway.</span></span><br><span class="line">			c := b.calls[failIdx]</span><br><span class="line">			b.calls[failIdx], b.calls = b.calls[<span class="built_in">len</span>(b.calls)<span class="number">-1</span>], b.calls[:<span class="built_in">len</span>(b.calls)<span class="number">-1</span>]</span><br><span class="line">			<span class="comment">// tell the submitter re-run it solo, continue with the rest of the batch</span></span><br><span class="line">			c.err &lt;- trySolo</span><br><span class="line">			<span class="keyword">continue</span> retry</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// pass success, or bolt internal errors, to all callers</span></span><br><span class="line">		<span class="comment">// 失败的单独重试一次</span></span><br><span class="line">		<span class="keyword">for</span> _, c := <span class="keyword">range</span> b.calls &#123;</span><br><span class="line">			c.err &lt;- err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span> retry</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="db-allocate-和db-grow-分析"><a href="#db-allocate-和db-grow-分析" class="headerlink" title="db.allocate()和db.grow()分析"></a>db.allocate()和db.grow()分析</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allocate returns a contiguous block of memory starting at a given page.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> allocate(count <span class="type">int</span>) (*page, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// Allocate a temporary buffer for the page.</span></span><br><span class="line">    <span class="keyword">var</span> buf []<span class="type">byte</span></span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">1</span> &#123;</span><br><span class="line">        buf = db.pagePool.Get().([]<span class="type">byte</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf = <span class="built_in">make</span>([]<span class="type">byte</span>, count*db.pageSize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转成*page</span></span><br><span class="line">    p := (*page)(unsafe.Pointer(&amp;buf[<span class="number">0</span>]))</span><br><span class="line">    p.overflow = <span class="type">uint32</span>(count - <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// Use pages from the freelist if they are available.</span></span><br><span class="line">    <span class="comment">// 先从空闲列表中找</span></span><br><span class="line">    <span class="keyword">if</span> p.id = db.freelist.allocate(count); p.id != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找不到的话，就按照事务的pgid来分配</span></span><br><span class="line">    <span class="comment">// 表示需要从文件内部扩大</span></span><br><span class="line">    <span class="comment">// Resize mmap() if we&#x27;re at the end.</span></span><br><span class="line">    p.id = db.rwtx.meta.pgid</span><br><span class="line">    <span class="comment">// 因此需要判断是否目前所有的页数已经大于了mmap映射出来的空间</span></span><br><span class="line">    <span class="comment">// 这儿计算的页面总数是从当前的id后还要计算count+1个</span></span><br><span class="line">    <span class="keyword">var</span> minsz = <span class="type">int</span>((p.id+pgid(count))+<span class="number">1</span>) * db.pageSize</span><br><span class="line">    <span class="keyword">if</span> minsz &gt;= db.datasz &#123;</span><br><span class="line">        <span class="keyword">if</span> err := db.mmap(minsz); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;mmap allocate error: %s&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Move the page id high water mark.</span></span><br><span class="line">    <span class="comment">// 如果不是从freelist中找到的空间的话，更新meta的id，也就意味着是从文件中新扩展的页</span></span><br><span class="line">    db.rwtx.meta.pgid += pgid(count)</span><br><span class="line">    <span class="keyword">return</span> p, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// grow grows the size of the database to the given sz.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> grow(sz <span class="type">int</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// Ignore if the new size is less than available file size.</span></span><br><span class="line">    <span class="keyword">if</span> sz &lt;= db.filesz &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 满足这个条件sz&gt;filesz</span></span><br><span class="line">    <span class="comment">// If the data is smaller than the alloc size then only allocate what&#x27;s needed.</span></span><br><span class="line">    <span class="comment">// Once it goes over the allocation size then allocate in chunks.</span></span><br><span class="line">    <span class="keyword">if</span> db.datasz &lt; db.AllocSize &#123;</span><br><span class="line">        sz = db.datasz</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sz += db.AllocSize</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Truncate and fsync to ensure file size metadata is flushed.</span></span><br><span class="line">    <span class="comment">// https://github.com/boltdb/bolt/issues/284</span></span><br><span class="line">    <span class="keyword">if</span> !db.NoGrowSync &amp;&amp; !db.readOnly &#123;</span><br><span class="line">        <span class="keyword">if</span> runtime.GOOS != <span class="string">&quot;windows&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err := db.file.Truncate(<span class="type">int64</span>(sz)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;file resize error: %s&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err := db.file.Sync(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;file sync error: %s&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    db.filesz = sz</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="db-allocate-和db-grow-分析-1"><a href="#db-allocate-和db-grow-分析-1" class="headerlink" title="db.allocate()和db.grow()分析"></a>db.allocate()和db.grow()分析</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allocate returns a contiguous block of memory starting at a given page.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> allocate(count <span class="type">int</span>) (*page, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// Allocate a temporary buffer for the page.</span></span><br><span class="line">    <span class="keyword">var</span> buf []<span class="type">byte</span></span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">1</span> &#123;</span><br><span class="line">        buf = db.pagePool.Get().([]<span class="type">byte</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf = <span class="built_in">make</span>([]<span class="type">byte</span>, count*db.pageSize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转成*page</span></span><br><span class="line">    p := (*page)(unsafe.Pointer(&amp;buf[<span class="number">0</span>]))</span><br><span class="line">    p.overflow = <span class="type">uint32</span>(count - <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// Use pages from the freelist if they are available.</span></span><br><span class="line">    <span class="comment">// 先从空闲列表中找</span></span><br><span class="line">    <span class="keyword">if</span> p.id = db.freelist.allocate(count); p.id != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找不到的话，就按照事务的pgid来分配</span></span><br><span class="line">    <span class="comment">// 表示需要从文件内部扩大</span></span><br><span class="line">    <span class="comment">// Resize mmap() if we&#x27;re at the end.</span></span><br><span class="line">    p.id = db.rwtx.meta.pgid</span><br><span class="line">    <span class="comment">// 因此需要判断是否目前所有的页数已经大于了mmap映射出来的空间</span></span><br><span class="line">    <span class="comment">// 这儿计算的页面总数是从当前的id后还要计算count+1个</span></span><br><span class="line">    <span class="keyword">var</span> minsz = <span class="type">int</span>((p.id+pgid(count))+<span class="number">1</span>) * db.pageSize</span><br><span class="line">    <span class="keyword">if</span> minsz &gt;= db.datasz &#123;</span><br><span class="line">        <span class="keyword">if</span> err := db.mmap(minsz); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;mmap allocate error: %s&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Move the page id high water mark.</span></span><br><span class="line">    <span class="comment">// 如果不是从freelist中找到的空间的话，更新meta的id，也就意味着是从文件中新扩展的页</span></span><br><span class="line">    db.rwtx.meta.pgid += pgid(count)</span><br><span class="line">    <span class="keyword">return</span> p, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// grow grows the size of the database to the given sz.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> grow(sz <span class="type">int</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// Ignore if the new size is less than available file size.</span></span><br><span class="line">    <span class="keyword">if</span> sz &lt;= db.filesz &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 满足这个条件sz&gt;filesz</span></span><br><span class="line">    <span class="comment">// If the data is smaller than the alloc size then only allocate what&#x27;s needed.</span></span><br><span class="line">    <span class="comment">// Once it goes over the allocation size then allocate in chunks.</span></span><br><span class="line">    <span class="keyword">if</span> db.datasz &lt; db.AllocSize &#123;</span><br><span class="line">        sz = db.datasz</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sz += db.AllocSize</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Truncate and fsync to ensure file size metadata is flushed.</span></span><br><span class="line">    <span class="comment">// https://github.com/boltdb/bolt/issues/284</span></span><br><span class="line">    <span class="keyword">if</span> !db.NoGrowSync &amp;&amp; !db.readOnly &#123;</span><br><span class="line">        <span class="keyword">if</span> runtime.GOOS != <span class="string">&quot;windows&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err := db.file.Truncate(<span class="type">int64</span>(sz)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;file resize error: %s&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err := db.file.Sync(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;file sync error: %s&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    db.filesz = sz</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/15/database/bblot/bbolt%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/15/database/bblot/bbolt%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">bblot 入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-15 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-15T00:00:00+08:00">2021-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-18 20:43:48" itemprop="dateModified" datetime="2021-07-18T20:43:48+08:00">2021-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/bblot/" itemprop="url" rel="index"><span itemprop="name">bblot</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本书是采用自底向上的方式来介绍boltdb内部的实现原理。其实我们经常都在采用<strong>自底向上</strong>或者<strong>自顶向下</strong>这两种方式来思考和求解问题。</p>
<p>例如：我们阅读源码时，通常都是从最顶层的接口点进去，然后层层深入内部。这其实本质上就是一种自顶向下的方式。</p>
<p>又比如我们平常做开发时，都是先将系统进行拆分、解耦。然后一般都会采用从下而上或者从上而下的方式来进行开发迭代。</p>
<p>回到最初的话题，为什么本书要采用自底向上的方式来写呢？</p>
<p>对于一个文件型数据库而言，<strong>所谓的上</strong>指的是暴露给用户侧的调用接口。<strong>所谓的下</strong>又指它的输出(数据)最终要落到磁盘这种 存储介质上。采用自底向上的方式的话，也就意味着我们先从磁盘这一层进行分析。然后逐步衍生到内存；再到用户接口这一层。层层之间是 被依赖的一种关系。这样的话，其实就比较好理解了。在本书中，本人采用自底向上的方式来介绍。希望阅读完后，有一种自己从0到1构建了 一块数据库的快感。</p>
<p>当然也可以采用自顶向下的方式来介绍，这时我们就需要在介绍最上层时，先假设它所依赖的底层都已经就绪了，我们只分析当层内容。然后层层 往下扩展。</p>
<p>之前和一位大佬进行过针对此问题的探讨，在不同的场景、不同的组件中。具体采用<strong>自底向上</strong>还是<strong>自顶向下</strong>来分析。见仁见智，也具体问题具体分析。当要达成的目标足够清晰时，通过自顶向下的方式可以倒推达成目标需要完成的几个阶段任务。然后再依次进行细分展开。</p>
<h2 id="boltdb是什么"><a href="#boltdb是什么" class="headerlink" title="boltdb是什么"></a>boltdb是什么</h2><blockquote>
<p>Bolt is a pure Go key&#x2F;value store inspired by [Howard Chu’s][hyc_symas] [LMDB project][lmdb]. The goal of the project is to provide a simple, fast, and reliable database for projects that don’t require a full database server such as Postgres or MySQL.</p>
<p>Since Bolt is meant to be used as such a low-level piece of functionality, simplicity is key. The API will be small and only focus on getting values and setting values. That’s it.</p>
</blockquote>
<h2 id="boltdb的黑科技"><a href="#boltdb的黑科技" class="headerlink" title="boltdb的黑科技"></a>boltdb的黑科技</h2><p><strong>1. mmap</strong></p>
<p>在boltdb中所有的数据都是以page页为单位组织的，那这时候通常我们的理解是，当通过索引定位到具体存储数据在某一页时，然后就先在页缓存中找，如果页没有缓存，则打开数据库文件中开始读取那一页的数据就好了。 但这样的话性能会极低。boltdb中是通过mmap内存映射技术来解决这个问题。当数据库初始化时，就会进行内存映射，将文件中的数据映射到内存中的一段连续空间，后续再读取某一页的数据时，直接在内存中读取。性能大幅度提升。</p>
<p><strong>2. b+树</strong></p>
<p>在boltdb中，索引和数据时按照b+树来组织的。其中一个bucket对象对应一颗b+树，叶子节点存储具体的数据，非叶子节点只存储具体的索引信息，很类似mysql innodb中的主键索引结构。同时值得注意的是所有的bucket也构成了一颗树。但该树不是b+树。</p>
<p><strong>3. 嵌套bucket</strong></p>
<p>前面说到，在boltdb中，一个bucket对象是一颗b+树，它上面存储一批kv键值对。但同时它还有一个特性，一个bucket下面还可以有嵌套的subbucket。subbucket中还可以有subbucket。这个特性也很重要。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">first</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在当前目录下打开 my.db 这个文件</span></span><br><span class="line">	<span class="comment">// 如果文件不存在，将会自动创建</span></span><br><span class="line">	db, err := bolt.Open(<span class="string">&quot;my.db&quot;</span>, <span class="number">0600</span>, &amp;bolt.Options&#123;Timeout: <span class="number">1</span> * time.Second&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">	key := []<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	value := []<span class="type">byte</span>(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个 read-write 事务来进行写操作</span></span><br><span class="line">	err = db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="comment">// 如果 bucket 不存在则，创建一个 bucket</span></span><br><span class="line">		bucket, err := tx.CreateBucketIfNotExists(testBucket)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将 key-value 写入到 bucket 中</span></span><br><span class="line">		err = bucket.Put(key, value)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个 read-only 事务来获取数据</span></span><br><span class="line">	err = db.View(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="comment">// 获取对应的 bucket</span></span><br><span class="line">		bucket := tx.Bucket(testBucket)</span><br><span class="line">		<span class="comment">// 如果 bucket 返回为 nil，则说明不存在对应 bucket</span></span><br><span class="line">		<span class="keyword">if</span> bucket == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;bucket %q is not found&quot;</span>, testBucket)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从 bucket 中获取对应的 key（即上面写入的 key-value）</span></span><br><span class="line">		val := bucket.Get(key)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s: %s\n&quot;</span>, <span class="type">string</span>(key), <span class="type">string</span>(val))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/jaydenwen123-boltdb_book/00fe39712cec954e.md">自底向上分析boltdb源码</a></p>
<p><a target="_blank" rel="noopener" href="https://youjiali1995.github.io/storage/boltdb/">boltdb 源码分析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/15/database/bblot/bucket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/15/database/bblot/bucket/" class="post-title-link" itemprop="url">bblot bucket</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-15 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-15T00:00:00+08:00">2021-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-18 20:43:46" itemprop="dateModified" datetime="2021-07-18T20:43:46+08:00">2021-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/bblot/" itemprop="url" rel="index"><span itemprop="name">bblot</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="Bucket数据结构"><a href="#Bucket数据结构" class="headerlink" title="Bucket数据结构"></a>Bucket数据结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bucket represents a collection of key/value pairs inside the database.</span></span><br><span class="line"><span class="keyword">type</span> Bucket <span class="keyword">struct</span> &#123;</span><br><span class="line">	*bucket</span><br><span class="line">	tx       *Tx                <span class="comment">// the associated transaction</span></span><br><span class="line">	buckets  <span class="keyword">map</span>[<span class="type">string</span>]*Bucket <span class="comment">// subbucket cache</span></span><br><span class="line">	page     *page              <span class="comment">// inline page reference</span></span><br><span class="line">	rootNode *node              <span class="comment">// materialized node for the root page.</span></span><br><span class="line">	nodes    <span class="keyword">map</span>[pgid]*node     <span class="comment">// node cache</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sets the threshold for filling nodes when they split. By default,</span></span><br><span class="line">	<span class="comment">// the bucket will fill to 50% but it can be useful to increase this</span></span><br><span class="line">	<span class="comment">// amount if you know that your write workloads are mostly append-only.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// This is non-persisted across transactions so it must be set in every Tx.</span></span><br><span class="line">	FillPercent <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bucket represents the on-file representation of a bucket.</span></span><br><span class="line"><span class="comment">// This is stored as the &quot;value&quot; of a bucket key. If the bucket is small enough,</span></span><br><span class="line"><span class="comment">// then its root page can be stored inline in the &quot;value&quot;, after the bucket</span></span><br><span class="line"><span class="comment">// header. In the case of inline buckets, the &quot;root&quot; will be 0.</span></span><br><span class="line"><span class="keyword">type</span> bucket <span class="keyword">struct</span> &#123;</span><br><span class="line">	root     pgid   <span class="comment">// page id of the bucket&#x27;s root-level page</span></span><br><span class="line">	sequence <span class="type">uint64</span> <span class="comment">// monotonically incrementing, used by NextSequence()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Bucket遍历之Cursor"><a href="#Bucket遍历之Cursor" class="headerlink" title="Bucket遍历之Cursor"></a>Bucket遍历之Cursor</h2><p>本节我们先做一节内容的铺垫，暂时不讲如何创建、获取、删除一个Bucket。而是介绍一个boltdb中的新对象Cursor。</p>
<p>答案是：所有的上述操作都是建立在首先定位到一个Bucket所属的位置，然后才能对其进行操作。而定位一个Bucket的功能就是由Cursor来完成的。所以我们先这一节给大家介绍一下boltdb中的Cursor。</p>
<p>我们先看下官方文档对Cursor的描述</p>
<blockquote>
<p>Cursor represents an iterator that can traverse over all key&#x2F;value pairs in a bucket in sorted order.</p>
</blockquote>
<p>用大白话讲，既然一个Bucket逻辑上是一颗b+树，那就意味着我们可以对其进行遍历。前面提到的set、get操作，无非是要在Bucket上先找到合适的位置，然后再进行操作。而“找”这个操作就是交由Cursor来完成的。简而言之对Bucket这颗b+树的遍历工作由Cursor来执行。一个Bucket对象关联一个Cursor。下面我们先看看Bucket和Cursor之间的关系。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cursor creates a cursor associated with the bucket.</span></span><br><span class="line"><span class="comment">// The cursor is only valid as long as the transaction is open.</span></span><br><span class="line"><span class="comment">// Do not use a cursor after the transaction is closed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span></span> Cursor() *Cursor &#123;</span><br><span class="line">	<span class="comment">// Update transaction statistics.</span></span><br><span class="line">	b.tx.stats.CursorCount++</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate and return a cursor.</span></span><br><span class="line">	<span class="keyword">return</span> &amp;Cursor&#123;</span><br><span class="line">		bucket: b,</span><br><span class="line">		stack:  <span class="built_in">make</span>([]elemRef, <span class="number">0</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// elemRef represents a reference to an element on a given page/node.</span></span><br><span class="line"><span class="keyword">type</span> elemRef <span class="keyword">struct</span> &#123;</span><br><span class="line">	page  *page</span><br><span class="line">	node  *node</span><br><span class="line">	index <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isLeaf returns whether the ref is pointing at a leaf page/node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *elemRef)</span></span> isLeaf() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.node != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> r.node.isLeaf</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (r.page.flags &amp; leafPageFlag) != <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// count returns the number of inodes or page elements.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *elemRef)</span></span> count() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.node != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(r.node.inodes)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">int</span>(r.page.count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Cursor结构"><a href="#Cursor结构" class="headerlink" title="Cursor结构"></a>Cursor结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cursor <span class="keyword">struct</span> &#123;</span><br><span class="line">   bucket *Bucket</span><br><span class="line">   stack  []elemRef</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bucket returns the bucket that this cursor was created from.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cursor)</span></span> Bucket() *Bucket &#123;</span><br><span class="line">   <span class="keyword">return</span> c.bucket</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Cursor对外接口"><a href="#Cursor对外接口" class="headerlink" title="Cursor对外接口"></a>Cursor对外接口</h3><p>下面我们看一下Cursor对外暴露的接口有哪些。看之前也可以心里先想一下。针对一棵树我们需要哪些遍历接口呢？</p>
<p>主体也就是三类：<strong>定位到某一个元素的位置</strong>、在当前位置<strong>从前往后找</strong>、在当前位置<strong>从后往前找</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cursor)</span></span> First() (key []<span class="type">byte</span>, value []<span class="type">byte</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cursor)</span></span> Last() (key []<span class="type">byte</span>, value []<span class="type">byte</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cursor)</span></span> Next() (key []<span class="type">byte</span>, value []<span class="type">byte</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cursor)</span></span> Prev() (key []<span class="type">byte</span>, value []<span class="type">byte</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cursor)</span></span> Delete() <span class="type">error</span></span><br><span class="line"><span class="comment">// Seek moves the cursor to a given key and returns it.</span></span><br><span class="line"><span class="comment">// If the key does not exist then the next key is used. If no keys</span></span><br><span class="line"><span class="comment">// follow, a nil key is returned.</span></span><br><span class="line"><span class="comment">// The returned key and value are only valid for the life of the transaction.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cursor)</span></span> Seek(seek []<span class="type">byte</span>) (key []<span class="type">byte</span>, value []<span class="type">byte</span>)</span><br></pre></td></tr></table></figure>

<h3 id="page-node"><a href="#page-node" class="headerlink" title="page node"></a>page node</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pageNode returns the in-memory node, if it exists.</span></span><br><span class="line"><span class="comment">// Otherwise returns the underlying page.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span></span> pageNode(id pgid) (*page, *node) &#123;</span><br><span class="line">   <span class="comment">// Inline buckets have a fake page embedded in their value so treat them</span></span><br><span class="line">   <span class="comment">// differently. We&#x27;ll return the rootNode (if available) or the fake page.</span></span><br><span class="line">   <span class="keyword">if</span> b.root == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> id != <span class="number">0</span> &#123;</span><br><span class="line">         <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;inline bucket non-zero page access(2): %d != 0&quot;</span>, id))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> b.rootNode != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, b.rootNode</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> b.page, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check the node cache for non-inline buckets.</span></span><br><span class="line">   <span class="keyword">if</span> b.nodes != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> n := b.nodes[id]; n != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, n</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Finally lookup the page from the transaction if no node is materialized.</span></span><br><span class="line">   <span class="keyword">return</span> b.tx.page(id), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// data 表示 mmap 的 file 数据</span></span><br><span class="line"><span class="comment">// page retrieves a page reference from the mmap based on the current page size.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> page(id pgid) *page &#123;</span><br><span class="line">	pos := id * pgid(db.pageSize)</span><br><span class="line">	<span class="keyword">return</span> (*page)(unsafe.Pointer(&amp;db.data[pos]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Seek-key-实现分析"><a href="#Seek-key-实现分析" class="headerlink" title="Seek(key)实现分析"></a>Seek(key)实现分析</h3><p>Seek()方法内部主要调用了seek()私有方法，我们重点关注seek()这个方法的实现，该方法有三个返回值，前两个为key、value、第三个为叶子节点的类型。前面提到在boltdb中，叶子节点元素有两种类型：一种是嵌套的子桶、一种是普通的key&#x2F;value。而这二者就是通过flags来区分的。如果叶子节点元素为嵌套的子桶时，返回的flags为1，也就是bucketLeafFlag取值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cursor)</span></span> Seek(seek []<span class="type">byte</span>) (key []<span class="type">byte</span>, value []<span class="type">byte</span>) &#123;</span><br><span class="line">    k, v, flags := c.seek(seek)</span><br><span class="line">    <span class="comment">// If we ended up after the last element of a page then move to the next one.</span></span><br><span class="line">    <span class="comment">// 下面这一段逻辑是必须的，因为在seek()方法中，如果ref.index&gt;ref.count()的话，就直接返回nil,nil,0了</span></span><br><span class="line">    <span class="comment">// 这里需要返回下一个</span></span><br><span class="line">    <span class="keyword">if</span> ref := &amp;c.stack[<span class="built_in">len</span>(c.stack)<span class="number">-1</span>]; ref.index &gt;= ref.count() &#123;</span><br><span class="line">        k, v, flags = c.next()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> k == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="comment">//     子桶的话</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; <span class="type">uint32</span>(bucketLeafFlag)) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> k, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k, v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际上调用 search 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cursor)</span></span> seek(seek []<span class="type">byte</span>) (key []<span class="type">byte</span>, value []<span class="type">byte</span>, flags <span class="type">uint32</span>) &#123;</span><br><span class="line">	<span class="comment">// Start from root page/node and traverse to correct page.</span></span><br><span class="line">	c.stack = c.stack[:<span class="number">0</span>]</span><br><span class="line">	c.search(seek, c.bucket.root)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If this is a bucket then return a nil value.</span></span><br><span class="line">	<span class="keyword">return</span> c.keyValue()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个 search 就是构建了一个搜索栈，最后用 elemRef 中的 index， 这个 index 表示node 中 inodes 的下标，或者 	page 下标。</span></span><br><span class="line"><span class="comment">// search recursively performs a binary search against a given page/node until it finds a given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cursor)</span></span> search(key []<span class="type">byte</span>, pgid pgid) &#123;</span><br><span class="line">	p, n := c.bucket.pageNode(pgid)</span><br><span class="line">	<span class="keyword">if</span> p != <span class="literal">nil</span> &amp;&amp; (p.flags&amp;(branchPageFlag|leafPageFlag)) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;invalid page type: %d: %x&quot;</span>, p.id, p.flags))</span><br><span class="line">	&#125;</span><br><span class="line">	e := elemRef&#123;page: p, node: n&#125;</span><br><span class="line">  <span class="comment">// 搜索栈</span></span><br><span class="line">	c.stack = <span class="built_in">append</span>(c.stack, e)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If we&#x27;re on a leaf page/node then find the specific node.</span></span><br><span class="line">  <span class="comment">// 叶子结点就直接最后一次二分查询了</span></span><br><span class="line">	<span class="keyword">if</span> e.isLeaf() &#123;</span><br><span class="line">		c.nsearch(key)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 搜索 node 或者 page， 差异非常小，因为本质上 node 就是 page 的 内存形式</span></span><br><span class="line">	<span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.searchNode(key, n)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.searchPage(key, p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cursor)</span></span> searchNode(key []<span class="type">byte</span>, n *node) &#123;</span><br><span class="line">	<span class="keyword">var</span> exact <span class="type">bool</span></span><br><span class="line">	index := sort.Search(<span class="built_in">len</span>(n.inodes), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="comment">// TODO(benbjohnson): Optimize this range search. It&#x27;s a bit hacky right now.</span></span><br><span class="line">		<span class="comment">// sort.Search() finds the lowest index where f() != -1 but we need the highest index.</span></span><br><span class="line">		ret := bytes.Compare(n.inodes[i].key, key)</span><br><span class="line">		<span class="keyword">if</span> ret == <span class="number">0</span> &#123;</span><br><span class="line">			exact = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret != <span class="number">-1</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> !exact &amp;&amp; index &gt; <span class="number">0</span> &#123;</span><br><span class="line">		index--</span><br><span class="line">	&#125;</span><br><span class="line">	c.stack[<span class="built_in">len</span>(c.stack)<span class="number">-1</span>].index = index</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Recursively search to the next page.</span></span><br><span class="line">	c.search(key, n.inodes[index].pgid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// keyValue returns the key and value of the current leaf element.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cursor)</span></span> keyValue() ([]<span class="type">byte</span>, []<span class="type">byte</span>, <span class="type">uint32</span>) &#123;</span><br><span class="line">	ref := &amp;c.stack[<span class="built_in">len</span>(c.stack)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the cursor is pointing to the end of page/node then return nil.</span></span><br><span class="line">	<span class="keyword">if</span> ref.count() == <span class="number">0</span> || ref.index &gt;= ref.count() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Retrieve value from node.</span></span><br><span class="line">	<span class="keyword">if</span> ref.node != <span class="literal">nil</span> &#123;</span><br><span class="line">		inode := &amp;ref.node.inodes[ref.index]</span><br><span class="line">		<span class="keyword">return</span> inode.key, inode.value, inode.flags</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Or retrieve value from page.</span></span><br><span class="line">	elem := ref.page.leafPageElement(<span class="type">uint16</span>(ref.index))</span><br><span class="line">	<span class="keyword">return</span> elem.key(), elem.value(), elem.flags</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这儿我们就已经看完所有的seek()查找一个key的过程了，其内部也很简单，就是从根节点开始，通过不断递归遍历每层节点，采用二分法来定位到具体的叶子节点。到达叶子节点时，其叶子节点内部存储的数据也是有序的，因此继续按照二分查找来找到最终的下标。</p>
<p>值得需要注意点：</p>
<p><strong>在遍历时，我们都知道，有可能遍历到的当前分支节点数据并没有在内存中，此时就需要从page中加载数据遍历。所以在遍历过程中，优先在node中找，如果node为空的时候才会采用page来查找。</strong></p>
<h3 id="First-、Last-实现分析"><a href="#First-、Last-实现分析" class="headerlink" title="First()、Last()实现分析"></a>First()、Last()实现分析</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cursor)</span></span> First() (key []<span class="type">byte</span>, value []<span class="type">byte</span>) &#123;</span><br><span class="line">    _assert(c.bucket.tx.db != <span class="literal">nil</span>, <span class="string">&quot;tx closed&quot;</span>)</span><br><span class="line">    <span class="comment">// 清空stack</span></span><br><span class="line">    c.stack = c.stack[:<span class="number">0</span>]</span><br><span class="line">    p, n := c.bucket.pageNode(c.bucket.root)</span><br><span class="line">    <span class="comment">// 一直找到第一个叶子节点，此处在天添加stack时，一直让index设置为0即可</span></span><br><span class="line">    ref := elemRef&#123;page: p, node: n, index: <span class="number">0</span>&#125;</span><br><span class="line">    c.stack = <span class="built_in">append</span>(c.stack, ref)</span><br><span class="line">    c.first()</span><br><span class="line">    <span class="comment">// If we land on an empty page then move to the next value.</span></span><br><span class="line">    <span class="comment">// https://github.com/boltdb/bolt/issues/450</span></span><br><span class="line">    <span class="comment">// 当前页时空的话，找下一个</span></span><br><span class="line">    <span class="keyword">if</span> c.stack[<span class="built_in">len</span>(c.stack)<span class="number">-1</span>].count() == <span class="number">0</span> &#123;</span><br><span class="line">        c.next()</span><br><span class="line">    &#125;</span><br><span class="line">    k, v, flags := c.keyValue()</span><br><span class="line">    <span class="comment">// 是桶</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; <span class="type">uint32</span>(bucketLeafFlag)) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> k, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k, v</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first moves the cursor to the first leaf element under the last page in the stack.</span></span><br><span class="line"><span class="comment">// 找到最后一个非叶子节点的第一个叶子节点。index=0的节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cursor)</span></span> first() &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// Exit when we hit a leaf page.</span></span><br><span class="line">        <span class="keyword">var</span> ref = &amp;c.stack[<span class="built_in">len</span>(c.stack)<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> ref.isLeaf() &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Keep adding pages pointing to the first element to the stack.</span></span><br><span class="line">        <span class="keyword">var</span> pgid pgid</span><br><span class="line">        <span class="keyword">if</span> ref.node != <span class="literal">nil</span> &#123;</span><br><span class="line">            pgid = ref.node.inodes[ref.index].pgid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pgid = ref.page.branchPageElement(<span class="type">uint16</span>(ref.index)).pgid</span><br><span class="line">        &#125;</span><br><span class="line">        p, n := c.bucket.pageNode(pgid)</span><br><span class="line">        c.stack = <span class="built_in">append</span>(c.stack, elemRef&#123;page: p, node: n, index: <span class="number">0</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Next-分析"><a href="#Next-分析" class="headerlink" title="Next 分析"></a>Next 分析</h3><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c := b.Cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动遍历模式</span></span><br><span class="line"><span class="keyword">for</span> k, v := c.First(); k != <span class="literal">nil</span>; k, v = c.Next() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;cursor, key=%s, value=%s\n&quot;</span>, <span class="type">string</span>(k), <span class="type">string</span>(v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next 的实现就是去移动每一个 node 的 index， 从叶子结点开始，这样就能遍历完所有的叶子结点了！！！</span></span><br><span class="line"><span class="comment">// next moves to the next leaf element and returns the key and value.</span></span><br><span class="line"><span class="comment">// If the cursor is at the last leaf element then it stays there and returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cursor)</span></span> next() (key []<span class="type">byte</span>, value []<span class="type">byte</span>, flags <span class="type">uint32</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Attempt to move over one element until we&#x27;re successful.</span></span><br><span class="line">		<span class="comment">// Move up the stack as we hit the end of each page in our stack.</span></span><br><span class="line">		<span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">    <span class="comment">// c.stack 是在调用 First 函数时被写入的，所以，这样倒序来遍历能实现按序获取</span></span><br><span class="line">		<span class="keyword">for</span> i = <span class="built_in">len</span>(c.stack) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">			elem := &amp;c.stack[i]</span><br><span class="line">			<span class="keyword">if</span> elem.index &lt; elem.count()<span class="number">-1</span> &#123;</span><br><span class="line">				elem.index++</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If we&#x27;ve hit the root page then stop and return. This will leave the</span></span><br><span class="line">		<span class="comment">// cursor on the last element of the last page.</span></span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">-1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Otherwise start from where we left off in the stack and find the</span></span><br><span class="line">		<span class="comment">// first element of the first leaf page.</span></span><br><span class="line">		c.stack = c.stack[:i+<span class="number">1</span>]</span><br><span class="line">    <span class="comment">// 获取下一个叶子结点</span></span><br><span class="line">		c.first()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If this is an empty page then restart and move back up the stack.</span></span><br><span class="line">		<span class="comment">// https://github.com/boltdb/bolt/issues/450</span></span><br><span class="line">		<span class="keyword">if</span> c.stack[<span class="built_in">len</span>(c.stack)<span class="number">-1</span>].count() == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> c.keyValue()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="node节点的相关操作"><a href="#node节点的相关操作" class="headerlink" title="node节点的相关操作"></a>node节点的相关操作</h2><p>在开始分析node节点之前，我们先看一下官方对node节点的描述</p>
<blockquote>
<p>node represents an in-memory, deserialized page</p>
</blockquote>
<p>一个node节点，既可能是叶子节点，也可能是根节点，也可能是分支节点。是物理磁盘上读取进来的页page的内存表现形式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node represents an in-memory, deserialized page.</span></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    bucket     *Bucket <span class="comment">// 关联一个桶</span></span><br><span class="line">    isLeaf     <span class="type">bool</span></span><br><span class="line">    unbalanced <span class="type">bool</span>   <span class="comment">// 值为true的话，需要考虑页合并</span></span><br><span class="line">    spilled    <span class="type">bool</span>   <span class="comment">// 值为true的话，需要考虑页分裂</span></span><br><span class="line">    key        []<span class="type">byte</span> <span class="comment">// 对于分支节点的话，保留的是最小的key</span></span><br><span class="line">    pgid       pgid   <span class="comment">// 分支节点关联的页id</span></span><br><span class="line">    parent     *node  <span class="comment">// 该节点的parent</span></span><br><span class="line">    children   nodes  <span class="comment">// 该节点的孩子节点</span></span><br><span class="line">    inodes     inodes <span class="comment">// 该节点上保存的索引数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/ inode represents an internal node inside of a node.</span><br><span class="line"><span class="comment">// It can be used to point to elements in a page or point</span></span><br><span class="line"><span class="comment">// to an element which hasn&#x27;t been added to a page yet.</span></span><br><span class="line"><span class="keyword">type</span> inode <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 表示是否是子桶叶子节点还是普通叶子节点。如果flags值为1表示子桶叶子节点，否则为普通叶子节点</span></span><br><span class="line">    flags <span class="type">uint32</span></span><br><span class="line">    <span class="comment">// 当inode为分支元素时，pgid才有值，为叶子元素时，则没值</span></span><br><span class="line">    pgid pgid</span><br><span class="line">    key  []<span class="type">byte</span></span><br><span class="line">    <span class="comment">// 当inode为分支元素时，value为空，为叶子元素时，才有值</span></span><br><span class="line">    value []<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="node-gt-page"><a href="#node-gt-page" class="headerlink" title="node-&gt;page"></a>node-&gt;page</h3><h3 id="page-gt-node"><a href="#page-gt-node" class="headerlink" title="page-&gt;node"></a>page-&gt;node</h3><h3 id="node节点的增删改查"><a href="#node节点的增删改查" class="headerlink" title="node节点的增删改查"></a>node节点的增删改查</h3><h4 id="put-k-v"><a href="#put-k-v" class="headerlink" title="put(k,v)"></a>put(k,v)</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// put inserts a key/value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> put(oldKey, newKey, value []<span class="type">byte</span>, pgid pgid, flags <span class="type">uint32</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> pgid &gt;= n.bucket.tx.meta.pgid &#123;</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;pgid (%d) above high water mark (%d)&quot;</span>, pgid, n.bucket.tx.meta.pgid))</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(oldKey) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;put: zero-length old key&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(newKey) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;put: zero-length new key&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find insertion index.</span></span><br><span class="line">	index := sort.Search(<span class="built_in">len</span>(n.inodes), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> bytes.Compare(n.inodes[i].key, oldKey) != <span class="number">-1</span> &#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add capacity and shift nodes if we don&#x27;t have an exact match and need to insert.</span></span><br><span class="line">	exact := (<span class="built_in">len</span>(n.inodes) &gt; <span class="number">0</span> &amp;&amp; index &lt; <span class="built_in">len</span>(n.inodes) &amp;&amp; bytes.Equal(n.inodes[index].key, oldKey))</span><br><span class="line">	<span class="keyword">if</span> !exact &#123;</span><br><span class="line">		n.inodes = <span class="built_in">append</span>(n.inodes, inode&#123;&#125;)</span><br><span class="line">		<span class="built_in">copy</span>(n.inodes[index+<span class="number">1</span>:], n.inodes[index:])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	inode := &amp;n.inodes[index]</span><br><span class="line">	inode.flags = flags</span><br><span class="line">	inode.key = newKey</span><br><span class="line">	inode.value = value</span><br><span class="line">	inode.pgid = pgid</span><br><span class="line">	_assert(<span class="built_in">len</span>(inode.key) &gt; <span class="number">0</span>, <span class="string">&quot;put: zero-length inode key&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="get-k"><a href="#get-k" class="headerlink" title="get(k)"></a>get(k)</h4><p>在node中，没有get(k)的方法，其本质是在Cursor中就返回了get的数据。大家可以看看Cursor中的keyValue()方法。</p>
<h4 id="del-k"><a href="#del-k" class="headerlink" title="del(k)"></a>del(k)</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// del removes a key from the node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> del(key []<span class="type">byte</span>) &#123;</span><br><span class="line">	<span class="comment">// Find index of key.</span></span><br><span class="line">	index := sort.Search(<span class="built_in">len</span>(n.inodes), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> bytes.Compare(n.inodes[i].key, key) != <span class="number">-1</span> &#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Exit if the key isn&#x27;t found.</span></span><br><span class="line">	<span class="keyword">if</span> index &gt;= <span class="built_in">len</span>(n.inodes) || !bytes.Equal(n.inodes[index].key, key) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Delete inode from the node.</span></span><br><span class="line">	n.inodes = <span class="built_in">append</span>(n.inodes[:index], n.inodes[index+<span class="number">1</span>:]...)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mark the node as needing rebalancing.</span></span><br><span class="line">	n.unbalanced = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="nextSibling-、prevSibling"><a href="#nextSibling-、prevSibling" class="headerlink" title="nextSibling()、prevSibling()"></a>nextSibling()、prevSibling()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// childAt returns the child node at a given index.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> childAt(index <span class="type">int</span>) *node &#123;</span><br><span class="line">	<span class="keyword">if</span> n.isLeaf &#123;</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;invalid childAt(%d) on a leaf node&quot;</span>, index))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n.bucket.node(n.inodes[index].pgid, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// childIndex returns the index of a given child node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> childIndex(child *node) <span class="type">int</span> &#123;</span><br><span class="line">	index := sort.Search(<span class="built_in">len</span>(n.inodes), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> bytes.Compare(n.inodes[i].key, child.key) != <span class="number">-1</span> &#125;)</span><br><span class="line">	<span class="keyword">return</span> index</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// numChildren returns the number of children.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> numChildren() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(n.inodes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nextSibling returns the next node with the same parent.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> nextSibling() *node &#123;</span><br><span class="line">	<span class="keyword">if</span> n.parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 有父节点问题就不大了</span></span><br><span class="line">	index := n.parent.childIndex(n)</span><br><span class="line">	<span class="keyword">if</span> index &gt;= n.parent.numChildren()<span class="number">-1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n.parent.childAt(index + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prevSibling returns the previous node with the same parent.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> prevSibling() *node &#123;</span><br><span class="line">	<span class="keyword">if</span> n.parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	index := n.parent.childIndex(n)</span><br><span class="line">	<span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n.parent.childAt(index - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Bucket的相关操作"><a href="#Bucket的相关操作" class="headerlink" title="Bucket的相关操作"></a>Bucket的相关操作</h2><h3 id="创建一个Bucket"><a href="#创建一个Bucket" class="headerlink" title="创建一个Bucket"></a>创建一个Bucket</h3><p>根据指定的key来创建一个Bucket,如果指定key的Bucket已经存在，则会报错。如果指定的key之前有插入过元素，也会报错。否则的话，会在当前的Bucket中找到合适的位置，然后新建一个Bucket插入进去，最后返回给客户端。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CreateBucket creates a new bucket at the given key and returns the new bucket.</span></span><br><span class="line"><span class="comment">// Returns an error if the key already exists, if the bucket name is blank, or if the bucket name is too long.</span></span><br><span class="line"><span class="comment">// The bucket instance is only valid for the lifetime of the transaction.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span></span> CreateBucket(key []<span class="type">byte</span>) (*Bucket, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> b.tx.db == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrTxClosed</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> !b.tx.writable &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrTxNotWritable</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(key) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrBucketNameRequired</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Move cursor to correct position.</span></span><br><span class="line">    <span class="comment">// 拿到游标</span></span><br><span class="line">    c := b.Cursor()</span><br><span class="line">    <span class="comment">// 开始遍历、找到合适的位置</span></span><br><span class="line">    k, _, flags := c.seek(key)</span><br><span class="line">    <span class="comment">// Return an error if there is an existing key.</span></span><br><span class="line">    <span class="keyword">if</span> bytes.Equal(key, k) &#123;</span><br><span class="line">        <span class="comment">// 是桶,已经存在了</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; bucketLeafFlag) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, ErrBucketExists</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是桶、但key已经存在了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrIncompatibleValue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Create empty, inline bucket.</span></span><br><span class="line">    <span class="keyword">var</span> bucket = Bucket&#123;</span><br><span class="line">        bucket:      &amp;bucket&#123;&#125;,</span><br><span class="line">        rootNode:    &amp;node&#123;isLeaf: <span class="literal">true</span>&#125;,</span><br><span class="line">        FillPercent: DefaultFillPercent,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿到bucket对应的value</span></span><br><span class="line">    <span class="keyword">var</span> value = bucket.write()</span><br><span class="line">    <span class="comment">// Insert into node.</span></span><br><span class="line">    key = cloneBytes(key)</span><br><span class="line">    <span class="comment">// 插入到inode中</span></span><br><span class="line">    <span class="comment">// c.node()方法会在内存中建立这棵树，调用n.read(page)</span></span><br><span class="line">    c.node().put(key, key, value, <span class="number">0</span>, bucketLeafFlag)</span><br><span class="line">    <span class="comment">// Since subbuckets are not allowed on inline buckets, we need to</span></span><br><span class="line">    <span class="comment">// dereference the inline page, if it exists. This will cause the bucket</span></span><br><span class="line">    <span class="comment">// to be treated as a regular, non-inline bucket for the rest of the tx.</span></span><br><span class="line">    b.page = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">//根据key获取一个桶</span></span><br><span class="line">    <span class="keyword">return</span> b.Bucket(key), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取一个Bucket"><a href="#获取一个Bucket" class="headerlink" title="获取一个Bucket"></a>获取一个Bucket</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/ Bucket retrieves a nested bucket by name.</span><br><span class="line"><span class="comment">// Returns nil if the bucket does not exist.</span></span><br><span class="line"><span class="comment">// The bucket instance is only valid for the lifetime of the transaction.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span></span> Bucket(name []<span class="type">byte</span>) *Bucket &#123;</span><br><span class="line">    <span class="keyword">if</span> b.buckets != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> child := b.buckets[<span class="type">string</span>(name)]; child != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> child</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Move cursor to key.</span></span><br><span class="line">    <span class="comment">// 根据游标找key</span></span><br><span class="line">    c := b.Cursor()</span><br><span class="line">    k, v, flags := c.seek(name)</span><br><span class="line">    <span class="comment">// Return nil if the key doesn&#x27;t exist or it is not a bucket.</span></span><br><span class="line">    <span class="keyword">if</span> !bytes.Equal(name, k) || (flags&amp;bucketLeafFlag) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Otherwise create a bucket and cache it.</span></span><br><span class="line">    <span class="comment">// 根据找到的value来打开桶。</span></span><br><span class="line">    <span class="keyword">var</span> child = b.openBucket(v)</span><br><span class="line">    <span class="comment">// 加速缓存的作用</span></span><br><span class="line">    <span class="keyword">if</span> b.buckets != <span class="literal">nil</span> &#123;</span><br><span class="line">        b.buckets[<span class="type">string</span>(name)] = child</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> child</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Helper method that re-interprets a sub-bucket value</span></span><br><span class="line"><span class="comment">// from a parent into a Bucket</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span></span> openBucket(value []<span class="type">byte</span>) *Bucket &#123;</span><br><span class="line">    <span class="keyword">var</span> child = newBucket(b.tx)</span><br><span class="line">    <span class="comment">// If unaligned load/stores are broken on this arch and value is</span></span><br><span class="line">    <span class="comment">// unaligned simply clone to an aligned byte array.</span></span><br><span class="line">    unaligned := brokenUnaligned &amp;&amp; <span class="type">uintptr</span>(unsafe.Pointer(&amp;value[<span class="number">0</span>]))&amp;<span class="number">3</span> != <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> unaligned &#123;</span><br><span class="line">        value = cloneBytes(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If this is a writable transaction then we need to copy the bucket entry.</span></span><br><span class="line">    <span class="comment">// Read-only transactions can point directly at the mmap entry.</span></span><br><span class="line">    <span class="keyword">if</span> b.tx.writable &amp;&amp; !unaligned &#123;</span><br><span class="line">        child.bucket = &amp;bucket&#123;&#125;</span><br><span class="line">        *child.bucket = *(*bucket)(unsafe.Pointer(&amp;value[<span class="number">0</span>]))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        child.bucket = (*bucket)(unsafe.Pointer(&amp;value[<span class="number">0</span>]))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Save a reference to the inline page if the bucket is inline.</span></span><br><span class="line">    <span class="comment">// 内联桶</span></span><br><span class="line">    <span class="keyword">if</span> child.root == <span class="number">0</span> &#123;</span><br><span class="line">        child.page = (*page)(unsafe.Pointer(&amp;value[bucketHeaderSize]))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;child</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="key-x2F-value的插入、获取、删除"><a href="#key-x2F-value的插入、获取、删除" class="headerlink" title="key&#x2F;value的插入、获取、删除"></a>key&#x2F;value的插入、获取、删除</h2><p>其实本质上，对key&#x2F;value的所有操作最终都要表现在底层的node上。因为node节点就是用来存储真实数据的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span></span> Get(key []<span class="type">byte</span>) []<span class="type">byte</span> &#123;</span><br><span class="line">	k, v, flags := b.Cursor().seek(key)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Return nil if this is a bucket.</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; bucketLeafFlag) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If our target node isn&#x27;t the same key as what&#x27;s passed in then return nil.</span></span><br><span class="line">	<span class="keyword">if</span> !bytes.Equal(key, k) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span></span> Put(key []<span class="type">byte</span>, value []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// Move cursor to correct position.</span></span><br><span class="line">	c := b.Cursor()</span><br><span class="line">	k, _, flags := c.seek(key)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Return an error if there is an existing key with a bucket value.</span></span><br><span class="line">	<span class="keyword">if</span> bytes.Equal(key, k) &amp;&amp; (flags&amp;bucketLeafFlag) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ErrIncompatibleValue</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Insert into node.</span></span><br><span class="line">	key = cloneBytes(key)</span><br><span class="line">	c.node().put(key, key, value, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span></span> Delete(key []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// Move cursor to correct position.</span></span><br><span class="line">	c := b.Cursor()</span><br><span class="line">	k, _, flags := c.seek(key)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Return nil if the key doesn&#x27;t exist.</span></span><br><span class="line">	<span class="keyword">if</span> !bytes.Equal(key, k) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Return an error if there is already existing bucket value.</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; bucketLeafFlag) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ErrIncompatibleValue</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Delete the node if we have a matching key.</span></span><br><span class="line">	c.node().del(key)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Bucket的页分裂、页合并"><a href="#Bucket的页分裂、页合并" class="headerlink" title="Bucket的页分裂、页合并"></a>Bucket的页分裂、页合并</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spill writes all the nodes for this bucket to dirty pages.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span></span> spill() <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span></span> rebalance() &#123;</span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> b.nodes &#123;</span><br><span class="line">        n.rebalance()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, child := <span class="keyword">range</span> b.buckets &#123;</span><br><span class="line">        child.rebalance()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/15/database/bblot/page/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/15/database/bblot/page/" class="post-title-link" itemprop="url">bblot page</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-15 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-15T00:00:00+08:00">2021-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-18 20:43:42" itemprop="dateModified" datetime="2021-07-18T20:43:42+08:00">2021-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/bblot/" itemprop="url" rel="index"><span itemprop="name">bblot</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在boltdb中，一个db对应一个真实的磁盘文件。而在具体的文件中，boltdb又是按照以page为单位来读取和写入数据的，也就是说所有的数据在磁盘上都是按照页(page)来存储的，而此处的页大小是保持和操作系统对应的内存页大小一致，也就是4k。</p>
<p>每页由两部分数据组成：<strong>页头数据</strong>+<strong>真实数据</strong>，页头信息占16个字节，下面的页的结构定义</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pgid <span class="type">uint64</span></span><br><span class="line"><span class="keyword">type</span> page <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 页id 8字节</span></span><br><span class="line">    id pgid</span><br><span class="line">    <span class="comment">// flags：页类型，可以是分支，叶子节点，元信息，空闲列表  2字节，该值的取值详细参见下面描述</span></span><br><span class="line">    flags <span class="type">uint16</span></span><br><span class="line">    <span class="comment">// 个数 2字节，统计叶子节点、非叶子节点、空闲列表页的个数</span></span><br><span class="line">    count <span class="type">uint16</span></span><br><span class="line">    <span class="comment">// 4字节，数据是否有溢出，主要在空闲列表上有用</span></span><br><span class="line">    overflow <span class="type">uint32</span></span><br><span class="line">    <span class="comment">// 真实的数据，实际上没有这个字段，</span></span><br><span class="line">    ptr <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在boltdb中，它把页划分为四类：</p>
<table>
<thead>
<tr>
<th align="left">page页类型</th>
<th align="left">类型定义</th>
<th align="left">类型值</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">分支节点页</td>
<td align="left">branchPageFlag</td>
<td align="left">0x01</td>
<td align="left">存储索引信息(页号、元素key值)</td>
</tr>
<tr>
<td align="left">叶子节点页</td>
<td align="left">leafPageFlag</td>
<td align="left">0x02</td>
<td align="left">存储数据信息(页号、插入的key值、插入的value值)</td>
</tr>
<tr>
<td align="left">元数据页</td>
<td align="left">metaPageFlag</td>
<td align="left">0x04</td>
<td align="left">存储数据库的元信息，例如空闲列表页id、放置桶的根页等</td>
</tr>
<tr>
<td align="left">空闲列表页</td>
<td align="left">freelistPageFlag</td>
<td align="left">0x10</td>
<td align="left">存储哪些页是空闲页，可以用来后续分配空间时，优先考虑分配</td>
</tr>
</tbody></table>
<p><img src="https://static.sitestack.cn/projects/jaydenwen123-boltdb_book/47b966145cf27bff53b7d35acbe05554.png"></p>
<h2 id="元数据页"><a href="#元数据页" class="headerlink" title="元数据页"></a>元数据页</h2><p>每页有一个meta()方法，如果该页是元数据页的话，可以通过该方法来获取具体的元数据信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// meta returns a pointer to the metadata section of the page.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *page)</span></span> meta() *meta &#123;</span><br><span class="line">	<span class="keyword">return</span> (*meta)(unsafeAdd(unsafe.Pointer(p), unsafe.Sizeof(*p)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细的元数据信息定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> meta <span class="keyword">struct</span> &#123;</span><br><span class="line">    magic    <span class="type">uint32</span> <span class="comment">//魔数</span></span><br><span class="line">    version  <span class="type">uint32</span> <span class="comment">//版本</span></span><br><span class="line">    pageSize <span class="type">uint32</span> <span class="comment">//page页的大小，该值和操作系统默认的页大小保持一致</span></span><br><span class="line">    flags    <span class="type">uint32</span> <span class="comment">//保留值，目前貌似还没用到</span></span><br><span class="line">    root     bucket <span class="comment">//所有小柜子bucket的根</span></span><br><span class="line">    freelist pgid <span class="comment">//空闲列表页的id</span></span><br><span class="line">    pgid     pgid <span class="comment">//元数据页的id</span></span><br><span class="line">    txid     txid <span class="comment">//最大的事务id</span></span><br><span class="line">    checksum <span class="type">uint64</span> <span class="comment">//用作校验的校验和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="空闲列表页"><a href="#空闲列表页" class="headerlink" title="空闲列表页"></a>空闲列表页</h2><p>空闲列表页中主要包含三个部分：所有已经可以重新利用的空闲页列表ids、将来很快被释放掉的事务关联的页列表pending、页id的缓存。详细定义在<strong>freelist.go</strong>文件中，下面给大家展示其空闲页的定义。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> freelist <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 已经可以被分配的空闲页</span></span><br><span class="line">    ids     []pgid          <span class="comment">// all free and available free page ids.</span></span><br><span class="line">    <span class="comment">// 将来很快能被释放的空闲页，部分事务可能在读或者写</span></span><br><span class="line">    pending <span class="keyword">map</span>[txid][]pgid <span class="comment">// mapping of soon-to-be free page ids by tx.</span></span><br><span class="line">    cache   <span class="keyword">map</span>[pgid]<span class="type">bool</span>   <span class="comment">// fast lookup of all free and pending page ids.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="freelist-gt-page"><a href="#freelist-gt-page" class="headerlink" title="freelist-&gt;page"></a>freelist-&gt;page</h3><p>将空闲列表转换成页信息，写到磁盘中，此处需要注意一个问题.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write writes the page ids onto a freelist page. All free and pending ids are</span></span><br><span class="line"><span class="comment">// saved to disk since in the event of a program crash, all pending ids will</span></span><br><span class="line"><span class="comment">// become free.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *freelist)</span></span> write(p *page) <span class="type">error</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="page-gt-freelist"><a href="#page-gt-freelist" class="headerlink" title="page-&gt;freelist"></a>page-&gt;freelist</h3><p>从磁盘中加载空闲页信息，并转为freelist结构，转换时</p>
<h2 id="分支节点页"><a href="#分支节点页" class="headerlink" title="分支节点页"></a>分支节点页</h2><p>分支节点在存储时，一个分支节点页上会存储多个分支页元素即branchPageElement。这个信息可以记做为分支页元素元信息。元信息中定义了具体该元素的页id(pgid)、该元素所指向的页中存储的最小key的值大小、最小key的值存储的位置距离当前的元信息的偏移量pos。下面是branchPageElement的详细定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> branchPageElement <span class="keyword">struct</span> &#123;</span><br><span class="line">    pos   <span class="type">uint32</span> <span class="comment">//该元信息和真实key之间的偏移量</span></span><br><span class="line">    ksize <span class="type">uint32</span></span><br><span class="line">    pgid  pgid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// key returns a byte slice of the node key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *branchPageElement)</span></span> key() []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> unsafeByteSlice(unsafe.Pointer(n), <span class="number">0</span>, <span class="type">int</span>(n.pos), <span class="type">int</span>(n.pos)+<span class="type">int</span>(n.ksize))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// branchPageElement retrieves the branch node by index</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *page)</span></span> branchPageElement(index <span class="type">uint16</span>) *branchPageElement &#123;</span><br><span class="line">	<span class="keyword">return</span> (*branchPageElement)(unsafeIndex(unsafe.Pointer(p), unsafe.Sizeof(*p),</span><br><span class="line">		unsafe.Sizeof(branchPageElement&#123;&#125;), <span class="type">int</span>(index)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// branchPageElements retrieves a list of branch nodes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *page)</span></span> branchPageElements() []branchPageElement &#123;</span><br><span class="line">	<span class="keyword">if</span> p.count == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> elems []branchPageElement</span><br><span class="line">	data := unsafeAdd(unsafe.Pointer(p), unsafe.Sizeof(*p))</span><br><span class="line">	unsafeSlice(unsafe.Pointer(&amp;elems), data, <span class="type">int</span>(p.count))</span><br><span class="line">	<span class="keyword">return</span> elems</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p>下图展现的是非叶子节点存储方式。</p>
<p><img src="https://static.sitestack.cn/projects/jaydenwen123-boltdb_book/43bf261237987ec953c1fb2997f21083.png"></p>
<h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><p><strong>在内存中，分支节点页和叶子节点页都是通过node来表示，只不过的区别是通过其node中的isLeaf这个字段来区分。下面和大家分析分支节点页page和内存中的node的转换关系。</strong></p>
<p>在内存中，具体的一个分支节点或者叶子节点都被抽象为一个node对象，其中是分支节点还是叶子节点主要通通过其isLeaf字段来区分。下面对分支节点和叶子节点做两点说明：</p>
<ol>
<li>对叶子节点而言，其没有children这个信息。同时也没有key信息。isLeaf字段为true，其上存储的key、value都保存在inodes中</li>
<li>对于分支节点而言，其具有key信息，同时children也不一定为空。isLeaf字段为false，同时该节点上的数据保存在inode中。</li>
</ol>
<h4 id="page-gt-node"><a href="#page-gt-node" class="headerlink" title="page -&gt; node"></a>page -&gt; node</h4><p>通过分支节点页来构建node节点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据page来初始化node</span></span><br><span class="line"><span class="comment">// read initializes the node from a page.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> read(p *page) &#123;</span><br><span class="line">    n.pgid = p.id</span><br><span class="line">    n.isLeaf = ((p.flags &amp; leafPageFlag) != <span class="number">0</span>)</span><br><span class="line">    n.inodes = <span class="built_in">make</span>(inodes, <span class="type">int</span>(p.count))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(p.count); i++ &#123;</span><br><span class="line">        inode := &amp;n.inodes[i]</span><br><span class="line">        <span class="keyword">if</span> n.isLeaf &#123;</span><br><span class="line">            <span class="comment">// 获取第i个叶子节点</span></span><br><span class="line">            elem := p.leafPageElement(<span class="type">uint16</span>(i))</span><br><span class="line">            inode.flags = elem.flags</span><br><span class="line">            inode.key = elem.key()</span><br><span class="line">            inode.value = elem.value()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 树枝节点</span></span><br><span class="line">            elem := p.branchPageElement(<span class="type">uint16</span>(i))</span><br><span class="line">            inode.pgid = elem.pgid</span><br><span class="line">            inode.key = elem.key()</span><br><span class="line">        &#125;</span><br><span class="line">        _assert(<span class="built_in">len</span>(inode.key) &gt; <span class="number">0</span>, <span class="string">&quot;read: zero-length inode key&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Save first key so we can find the node in the parent when we spill.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(n.inodes) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 保存第1个元素的值</span></span><br><span class="line">        n.key = n.inodes[<span class="number">0</span>].key</span><br><span class="line">        _assert(<span class="built_in">len</span>(n.key) &gt; <span class="number">0</span>, <span class="string">&quot;read: zero-length node key&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n.key = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="node-gt-page"><a href="#node-gt-page" class="headerlink" title="node-&gt;page"></a>node-&gt;page</h4><p>将node中的数据写入到page中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write writes the items onto one or more pages.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> write(p *page) &#123;</span><br><span class="line">	<span class="comment">// Initialize page.</span></span><br><span class="line">	<span class="keyword">if</span> n.isLeaf &#123;</span><br><span class="line">		p.flags |= leafPageFlag</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		p.flags |= branchPageFlag</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(n.inodes) &gt;= <span class="number">0xFFFF</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;inode overflow: %d (pgid=%d)&quot;</span>, <span class="built_in">len</span>(n.inodes), p.id))</span><br><span class="line">	&#125;</span><br><span class="line">	p.count = <span class="type">uint16</span>(<span class="built_in">len</span>(n.inodes))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Stop here if there are no items to write.</span></span><br><span class="line">	<span class="keyword">if</span> p.count == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Loop over each item and write it to the page.</span></span><br><span class="line">	<span class="comment">// off tracks the offset into p of the start of the next data.</span></span><br><span class="line">  <span class="comment">// off： page 和 page elements 的头信息</span></span><br><span class="line">	off := unsafe.Sizeof(*p) + n.pageElementSize()*<span class="type">uintptr</span>(<span class="built_in">len</span>(n.inodes))</span><br><span class="line">	<span class="keyword">for</span> i, item := <span class="keyword">range</span> n.inodes &#123;</span><br><span class="line">		_assert(<span class="built_in">len</span>(item.key) &gt; <span class="number">0</span>, <span class="string">&quot;write: zero-length inode key&quot;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create a slice to write into of needed size and advance</span></span><br><span class="line">		<span class="comment">// byte pointer for next iteration.</span></span><br><span class="line">		sz := <span class="built_in">len</span>(item.key) + <span class="built_in">len</span>(item.value)</span><br><span class="line">		b := unsafeByteSlice(unsafe.Pointer(p), off, <span class="number">0</span>, sz)</span><br><span class="line">		off += <span class="type">uintptr</span>(sz)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Write the page element.</span></span><br><span class="line">		<span class="comment">// 1. 写一个节点的头信息</span></span><br><span class="line">		<span class="keyword">if</span> n.isLeaf &#123;</span><br><span class="line">			elem := p.leafPageElement(<span class="type">uint16</span>(i))</span><br><span class="line">			elem.pos = <span class="type">uint32</span>(<span class="type">uintptr</span>(unsafe.Pointer(&amp;b[<span class="number">0</span>])) - <span class="type">uintptr</span>(unsafe.Pointer(elem)))</span><br><span class="line">			elem.flags = item.flags</span><br><span class="line">			elem.ksize = <span class="type">uint32</span>(<span class="built_in">len</span>(item.key))</span><br><span class="line">			elem.vsize = <span class="type">uint32</span>(<span class="built_in">len</span>(item.value))</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			elem := p.branchPageElement(<span class="type">uint16</span>(i))</span><br><span class="line">			elem.pos = <span class="type">uint32</span>(<span class="type">uintptr</span>(unsafe.Pointer(&amp;b[<span class="number">0</span>])) - <span class="type">uintptr</span>(unsafe.Pointer(elem)))</span><br><span class="line">			elem.ksize = <span class="type">uint32</span>(<span class="built_in">len</span>(item.key))</span><br><span class="line">			elem.pgid = item.pgid</span><br><span class="line">			_assert(elem.pgid != p.id, <span class="string">&quot;write: circular dependency occurred&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 2. 写数据信息</span></span><br><span class="line">		<span class="comment">// Write data for the element to the end of the page.</span></span><br><span class="line">		l := <span class="built_in">copy</span>(b, item.key)</span><br><span class="line">		<span class="built_in">copy</span>(b[l:], item.value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// DEBUG ONLY: n.dump()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="叶子节点页"><a href="#叶子节点页" class="headerlink" title="叶子节点页"></a>叶子节点页</h2><p>叶子节点主要用来存储实际的数据，也就是key+value了。下面看看具体的key+value是如何设计的。</p>
<p>在boltdb中，每一对key&#x2F;value在存储时，都有一份元素元信息，也就是leafPageElement。其中定义了key的长度、value的长度、具体存储的值距离元信息的偏移位置pos。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// leafPageElement represents a node on a leaf page.</span></span><br><span class="line"><span class="comment">// 叶子节点既存储key，也存储value</span></span><br><span class="line"><span class="keyword">type</span> leafPageElement <span class="keyword">struct</span> &#123;</span><br><span class="line">    flags <span class="type">uint32</span> <span class="comment">//该值主要用来区分，是子桶叶子节点元素还是普通的key/value叶子节点元素。flags值为1时表示子桶。否则为key/value</span></span><br><span class="line">    pos   <span class="type">uint32</span></span><br><span class="line">    ksize <span class="type">uint32</span></span><br><span class="line">    vsize <span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// key returns a byte slice of the node key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *leafPageElement)</span></span> key() []<span class="type">byte</span> &#123;</span><br><span class="line">	i := <span class="type">int</span>(n.pos)</span><br><span class="line">	j := i + <span class="type">int</span>(n.ksize)</span><br><span class="line">	<span class="keyword">return</span> unsafeByteSlice(unsafe.Pointer(n), <span class="number">0</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// value returns a byte slice of the node value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *leafPageElement)</span></span> value() []<span class="type">byte</span> &#123;</span><br><span class="line">	i := <span class="type">int</span>(n.pos) + <span class="type">int</span>(n.ksize)</span><br><span class="line">	j := i + <span class="type">int</span>(n.vsize)</span><br><span class="line">	<span class="keyword">return</span> unsafeByteSlice(unsafe.Pointer(n), <span class="number">0</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// leafPageElement retrieves the leaf node by index</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *page)</span></span> leafPageElement(index <span class="type">uint16</span>) *leafPageElement &#123;</span><br><span class="line">	<span class="keyword">return</span> (*leafPageElement)(unsafeIndex(unsafe.Pointer(p), unsafe.Sizeof(*p),</span><br><span class="line">		leafPageElementSize, <span class="type">int</span>(index)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// leafPageElements retrieves a list of leaf nodes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *page)</span></span> leafPageElements() []leafPageElement &#123;</span><br><span class="line">	<span class="keyword">if</span> p.count == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> elems []leafPageElement</span><br><span class="line">	data := unsafeAdd(unsafe.Pointer(p), unsafe.Sizeof(*p))</span><br><span class="line">	unsafeSlice(unsafe.Pointer(&amp;elems), data, <span class="type">int</span>(p.count))</span><br><span class="line">	<span class="keyword">return</span> elems</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存结构-1"><a href="#内存结构-1" class="headerlink" title="内存结构"></a>内存结构</h3><p>下图展现的是叶子节点存储方式。</p>
<p><img src="https://static.sitestack.cn/projects/jaydenwen123-boltdb_book/1eaa872ada92656b02a5ddadc050a608.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章中我们重点分析了boltdb中的核心数据结构(page、freelist、meta、node)以及他们之间的相互转化。</p>
<p>在底层磁盘上存储时，boltdb是按照页的单位来存储实际数据的，页的大小取自于它运行的操作系统的页大小。在boltdb中，根据存储的数据的类型不同，将页page整体上分为4大类：</p>
<p><strong>1. 元信息页(meta page)</strong></p>
<p><strong>2. 空闲列表页(freelist page)</strong></p>
<p><strong>3. 分支节点页(branch page)</strong></p>
<p><strong>4. 叶子节点页(leaf page)</strong></p>
<p>在page的头信息中通过flags字段来区分。</p>
<p>在内存中同样有对应的结构来映射磁盘上的上述几种页。如<strong>元信息meta</strong>、<strong>空闲列表freelist</strong>、**分支&#x2F;叶子节点node(通过isLeaf区分分支节点还是叶子节点)**。我们在每一节中先详细介绍其数据结构的定义。接着再重点分析在内存和磁盘上该类型的页时如何进行转换的。可以准确的说，数据结构属于boltdb核心中的核心。梳理清楚了每个数据结构存储的具体数据和格式后。下一章我们将重点分析其另外两个核心结构bucket和node。</p>
<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/jaydenwen123-boltdb_book/e46bc5498d5fe932.md">第二章 boltdb的核心数据结构分析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/15/database/bblot/transaction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/15/database/bblot/transaction/" class="post-title-link" itemprop="url">bblot transaction</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-15 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-15T00:00:00+08:00">2021-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-18 20:43:40" itemprop="dateModified" datetime="2021-07-18T20:43:40+08:00">2021-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/bblot/" itemprop="url" rel="index"><span itemprop="name">bblot</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="boltdb事务Tx定义"><a href="#boltdb事务Tx定义" class="headerlink" title="boltdb事务Tx定义"></a>boltdb事务Tx定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tx 主要封装了读事务和写事务。其中通过writable来区分是读事务还是写事务</span></span><br><span class="line"><span class="keyword">type</span> Tx <span class="keyword">struct</span> &#123;</span><br><span class="line">    writable       <span class="type">bool</span></span><br><span class="line">    managed        <span class="type">bool</span></span><br><span class="line">    db             *DB</span><br><span class="line">    meta           *meta</span><br><span class="line">    root           Bucket</span><br><span class="line">    pages          <span class="keyword">map</span>[pgid]*page</span><br><span class="line">    stats          TxStats</span><br><span class="line">    <span class="comment">// 提交时执行的动作</span></span><br><span class="line">    commitHandlers []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// WriteFlag specifies the flag for write-related methods like WriteTo().</span></span><br><span class="line">    <span class="comment">// Tx opens the database file with the specified flag to copy the data.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// By default, the flag is unset, which works well for mostly in-memory</span></span><br><span class="line">    <span class="comment">// workloads. For databases that are much larger than available RAM,</span></span><br><span class="line">    <span class="comment">// set the flag to syscall.O_DIRECT to avoid trashing the page cache.</span></span><br><span class="line">    WriteFlag <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init initializes the transaction.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> init(db *DB) &#123;</span><br><span class="line">    tx.db = db</span><br><span class="line">    tx.pages = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy the meta page since it can be changed by the writer.</span></span><br><span class="line">    <span class="comment">// 拷贝元信息</span></span><br><span class="line">    tx.meta = &amp;meta&#123;&#125;</span><br><span class="line">    db.meta().<span class="built_in">copy</span>(tx.meta)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy over the root bucket.</span></span><br><span class="line">    <span class="comment">// 拷贝根节点</span></span><br><span class="line">    tx.root = newBucket(tx)</span><br><span class="line">    tx.root.bucket = &amp;bucket&#123;&#125;</span><br><span class="line">    <span class="comment">// meta.root=bucket&#123;root:3&#125;</span></span><br><span class="line">    *tx.root.bucket = tx.meta.root</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Increment the transaction id and add a page cache for writable transactions.</span></span><br><span class="line">    <span class="keyword">if</span> tx.writable &#123;</span><br><span class="line">        tx.pages = <span class="built_in">make</span>(<span class="keyword">map</span>[pgid]*page)</span><br><span class="line">        tx.meta.txid += txid(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Begin-实现"><a href="#Begin-实现" class="headerlink" title="Begin()实现"></a>Begin()实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return tx</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Begin(writable <span class="type">bool</span>) (*Tx, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> writable &#123;</span><br><span class="line">		<span class="keyword">return</span> db.beginRWTx()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> db.beginTx()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Commit-实现"><a href="#Commit-实现" class="headerlink" title="Commit()实现"></a>Commit()实现</h2><p>Commit()方法内部实现中，总体思路是：</p>
<ol>
<li>先判定节点要不要合并、分裂</li>
<li>对空闲列表的判断，是否存在溢出的情况，溢出的话，需要重新分配空间</li>
<li>将事务中涉及改动的页进行排序(保证尽可能的顺序IO)，排序后循环写入到磁盘中，最后再执行刷盘</li>
<li>当数据写入成功后，再将元信息页写到磁盘中，刷盘以保证持久化</li>
<li>上述操作中，但凡有失败，当前事务都会进行回滚</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先更新数据然后再更新元信息</span></span><br><span class="line"><span class="comment">// 更新数据成功、元信息未来得及更新机器就挂掉了。数据如何恢复？</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> Commit() <span class="type">error</span> &#123;</span><br><span class="line">		<span class="comment">// Write dirty pages to disk.</span></span><br><span class="line">		startTime = time.Now()</span><br><span class="line">		<span class="keyword">if</span> err := tx.write(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			tx.rollback()</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// Write meta to disk.</span></span><br><span class="line">    <span class="comment">// 元信息写入到磁盘</span></span><br><span class="line">    <span class="keyword">if</span> err := tx.writeMeta(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        tx.rollback()</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// write writes any dirty pages to disk.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> write() <span class="type">error</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Rollback-实现"><a href="#Rollback-实现" class="headerlink" title="Rollback()实现"></a>Rollback()实现</h2><p>Rollback()中，主要对不同事务进行不同操作：</p>
<ol>
<li>如果当前事务是只读事务，则只需要从db中的txs中找到当前事务，然后移除掉即可。</li>
<li>如果当前事务是读写事务，则需要将空闲列表中和该事务关联的页释放掉，同时重新从freelist中加载空闲页。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> Rollback() <span class="type">error</span> &#123;</span><br><span class="line">    _assert(!tx.managed, <span class="string">&quot;managed tx rollback not allowed&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> tx.db == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrTxClosed</span><br><span class="line">    &#125;</span><br><span class="line">    tx.rollback()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> rollback() &#123;</span><br><span class="line">    <span class="keyword">if</span> tx.db == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> tx.writable &#123;</span><br><span class="line">        <span class="comment">// 移除该事务关联的pages</span></span><br><span class="line">        tx.db.freelist.rollback(tx.meta.txid)</span><br><span class="line">        <span class="comment">// 重新从freelist页中读取构建空闲列表</span></span><br><span class="line">        tx.db.freelist.reload(tx.db.page(tx.db.meta().freelist))</span><br><span class="line">    &#125;</span><br><span class="line">    tx.<span class="built_in">close</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WriteTo-和CopyFile-实现"><a href="#WriteTo-和CopyFile-实现" class="headerlink" title="WriteTo()和CopyFile()实现"></a>WriteTo()和CopyFile()实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WriteTo writes the entire database to a writer.</span></span><br><span class="line"><span class="comment">// If err == nil then exactly tx.Size() bytes will be written into the writer.</span></span><br><span class="line"><span class="comment">// 将当前 database 写入到 w</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> WriteTo(w io.Writer) (n <span class="type">int64</span>, err <span class="type">error</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> CopyFile(path <span class="type">string</span>, mode os.FileMode) <span class="type">error</span> &#123;</span><br><span class="line">    f, err := os.OpenFile(path, os.O_RDWR|os.O_CREATE|os.O_TRUNC, mode)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    err = tx.Copy(f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        _ = f.Close()</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章主要详细分析了下，boltdb内部事务的实现机制，再此基础上对事务中核心的几个方法做了代码的分析。到此基本上一个数据库核心的部件都已经实现完毕。那剩下的功能就把各部分功能进行组装起来，实现一个完整对外可用的数据库了。下一章我们来详细分析下boltdb中DB对象的内部一些实现。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/15/database/bblot/unsafe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/15/database/bblot/unsafe/" class="post-title-link" itemprop="url">bblot unsafe</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-15 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-15T00:00:00+08:00">2021-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-18 20:43:37" itemprop="dateModified" datetime="2021-07-18T20:43:37+08:00">2021-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/bblot/" itemprop="url" rel="index"><span itemprop="name">bblot</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 地址加法运算，偏移运算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unsafeAdd</span><span class="params">(base unsafe.Pointer, offset <span class="type">uintptr</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">	<span class="keyword">return</span> unsafe.Pointer(<span class="type">uintptr</span>(base) + offset)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 地址加法运算， 多元素偏移</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unsafeIndex</span><span class="params">(base unsafe.Pointer, offset <span class="type">uintptr</span>, elemsz <span class="type">uintptr</span>, n <span class="type">int</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">	<span class="keyword">return</span> unsafe.Pointer(<span class="type">uintptr</span>(base) + offset + <span class="type">uintptr</span>(n)*elemsz)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从一个地址开始将， 转为字节流</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unsafeByteSlice</span><span class="params">(base unsafe.Pointer, offset <span class="type">uintptr</span>, i, j <span class="type">int</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="comment">// See: https://github.com/golang/go/wiki/cgo#turning-c-arrays-into-go-slices</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// This memory is not allocated from C, but it is unmanaged by Go&#x27;s</span></span><br><span class="line">	<span class="comment">// garbage collector and should behave similarly, and the compiler</span></span><br><span class="line">	<span class="comment">// should produce similar code.  Note that this conversion allows a</span></span><br><span class="line">	<span class="comment">// subslice to begin after the base address, with an optional offset,</span></span><br><span class="line">	<span class="comment">// while the URL above does not cover this case and only slices from</span></span><br><span class="line">	<span class="comment">// index 0.  However, the wiki never says that the address must be to</span></span><br><span class="line">	<span class="comment">// the beginning of a C allocation (or even that malloc was used at</span></span><br><span class="line">	<span class="comment">// all), so this is believed to be correct.</span></span><br><span class="line">	<span class="keyword">return</span> (*[maxAllocSize]<span class="type">byte</span>)(unsafeAdd(base, offset))[i:j:j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 slice 的值域</span></span><br><span class="line"><span class="comment">// unsafeSlice modifies the data, len, and cap of a slice variable pointed to by</span></span><br><span class="line"><span class="comment">// the slice parameter.  This helper should be used over other direct</span></span><br><span class="line"><span class="comment">// manipulation of reflect.SliceHeader to prevent misuse, namely, converting</span></span><br><span class="line"><span class="comment">// from reflect.SliceHeader to a Go slice type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unsafeSlice</span><span class="params">(slice, data unsafe.Pointer, <span class="built_in">len</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	s := (*reflect.SliceHeader)(slice)</span><br><span class="line">	s.Data = <span class="type">uintptr</span>(data)</span><br><span class="line">	s.Cap = <span class="built_in">len</span></span><br><span class="line">	s.Len = <span class="built_in">len</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/15/database/leveldb/leveldb%20%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/15/database/leveldb/leveldb%20%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">leveldb 入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-15 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-15T00:00:00+08:00">2021-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-18 20:43:14" itemprop="dateModified" datetime="2021-07-18T20:43:14+08:00">2021-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leveldb/" itemprop="url" rel="index"><span itemprop="name">leveldb</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/05/operation%20system/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/05/operation%20system/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-05 10:22:18" itemprop="dateCreated datePublished" datetime="2021-07-05T10:22:18+08:00">2021-07-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Percy"
      src="https://ivalue2333.github.io/percy/images/percy.jpg">
  <p class="site-author-name" itemprop="name">Percy</p>
  <div class="site-description" itemprop="description">IOT2014</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">156</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">194</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Percy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
