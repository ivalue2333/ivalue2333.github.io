<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="IOT2014">
<meta property="og:type" content="website">
<meta property="og:title" content="blog | percy">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="blog | percy">
<meta property="og:description" content="IOT2014">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Percy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>blog | percy</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blog | percy</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/21/http/http%E4%B9%8Bgrpc%E4%B9%8Bzrpc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/21/http/http%E4%B9%8Bgrpc%E4%B9%8Bzrpc/" class="post-title-link" itemprop="url">http之grpc之zrpc</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-21 08:29:29" itemprop="dateCreated datePublished" datetime="2021-02-21T08:29:29+08:00">2021-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index"><span itemprop="name">http</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>zRPC 主要有以下几个模块组成：</p>
<ul>
<li>discov: 服务发现模块，基于 etcd 实现服务发现功能</li>
<li>resolver: 服务注册模块，实现了 gRPC 的 resolver.Builder 接口并注册到 gRPC</li>
<li>interceptor: 拦截器，对请求和响应进行拦截处理</li>
<li>balancer: 负载均衡模块，实现了 p2c 负载均衡算法，并注册到 gRPC</li>
<li>client: zRPC 客户端，负责发起请求</li>
<li>server: zRPC 服务端，负责处理请求</li>
</ul>
<p>其中 resolver 和 balancer 模块实现了 gRPC 开放的接口，实现了自定义的 resolver 和 balancer，拦截器模块是整个 zRPC 的功能重点。</p>
<h2 id="resolver-模块"><a href="#resolver-模块" class="headerlink" title="resolver 模块"></a>resolver 模块</h2><p>zRPC 中自定义了 resolver 模块，用来实现服务的注册功能。zRPC 底层依赖 gRPC，在 gRPC 中要想自定义 resolver 需要实现 resolver.Builder 接口：</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>当我们启动我们的 zRPC Server 的时候，调用 Start 方法，会向 etcd 中注册对应的服务地址：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ags keepAliveServer)</span></span> Start(fn RegisterFn) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// 注册服务地址</span></span><br><span class="line">    <span class="keyword">if</span> err := ags.registerEtcd(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    <span class="keyword">return</span> ags.Server.Start(fn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="put-key-value-to-etcd"><a href="#put-key-value-to-etcd" class="headerlink" title="put key value to etcd"></a>put key value to etcd</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// value 是当前服务的地址</span></span><br><span class="line">_, err = client.Put(client.Ctx(), p.fullKey, p.value, clientv3.WithLease(lease))</span><br></pre></td></tr></table></figure>

<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><p>在 grpc.DialContext 函数中会调用 newCCResolverWrapper 函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newCCResolverWrapper uses the resolver.Builder to build a Resolver and</span></span><br><span class="line"><span class="comment">// returns a ccResolverWrapper object which wraps the newly built resolver.</span></span><br><span class="line"><span class="comment">// rb 和 scheme 有关</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCCResolverWrapper</span><span class="params">(cc *ClientConn, rb resolver.Builder)</span></span> (*ccResolverWrapper, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="comment">// build</span></span><br><span class="line">	ccr.resolver, err = rb.Build(cc.parsedTarget, ccr, rbo)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ccr, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="build-接口"><a href="#build-接口" class="headerlink" title="build 接口"></a>build 接口</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Builder creates a resolver that will be used to watch name resolution updates.</span></span><br><span class="line"><span class="keyword">type</span> Builder <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Build creates a new resolver for the given target.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// gRPC dial calls Build synchronously, and fails if the returned error is</span></span><br><span class="line">	<span class="comment">// not nil.</span></span><br><span class="line">	Build(target Target, cc ClientConn, opts BuildOptions) (Resolver, <span class="type">error</span>)</span><br><span class="line">	<span class="comment">// Scheme returns the scheme supported by this resolver.</span></span><br><span class="line">	<span class="comment">// Scheme is defined at https://github.com/grpc/grpc/blob/master/doc/naming.md.</span></span><br><span class="line">	Scheme() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="resolver-接口"><a href="#resolver-接口" class="headerlink" title="resolver 接口"></a>resolver 接口</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Resolver watches for the updates on the specified target.</span></span><br><span class="line"><span class="comment">// Updates include address updates and service config updates.</span></span><br><span class="line"><span class="keyword">type</span> Resolver <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// ResolveNow will be called by gRPC to try to resolve the target name</span></span><br><span class="line">	<span class="comment">// again. It&#x27;s just a hint, resolver can ignore this if it&#x27;s not necessary.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// It could be called multiple times concurrently.</span></span><br><span class="line">	ResolveNow(ResolveNowOptions)</span><br><span class="line">	<span class="comment">// Close closes the resolver.</span></span><br><span class="line">	Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><p>当我们启动 zRPC 客户端的时候，在 gRPC 内部会调用我们自定义 resolver 的 Build 方法，zRPC 通过在 Build 方法内调用执行了 resolver.ClientConn 的 UpdateState 方法，该方法会把服务地址注册到 gRPC 客户端内部：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *discovBuilder)</span></span> Build(target resolver.Target, cc resolver.ClientConn, opts resolver.BuildOptions) (</span><br><span class="line">    resolver.Resolver, <span class="type">error</span>) &#123;</span><br><span class="line">    hosts := strings.FieldsFunc(target.Authority, <span class="function"><span class="keyword">func</span><span class="params">(r <span class="type">rune</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r == EndpointSepChar</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="comment">// 服务发现</span></span><br><span class="line">    sub, err := discov.NewSubscriber(hosts, target.Endpoint)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    update := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> addrs []resolver.Address</span><br><span class="line">        <span class="keyword">for</span> _, val := <span class="keyword">range</span> subset(sub.Values(), subsetSize) &#123;</span><br><span class="line">            addrs = <span class="built_in">append</span>(addrs, resolver.Address&#123;</span><br><span class="line">                Addr: val,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 向gRPC注册服务地址</span></span><br><span class="line">        cc.UpdateState(resolver.State&#123;</span><br><span class="line">            Addresses: addrs,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 监听</span></span><br><span class="line">    sub.AddListener(update)</span><br><span class="line">    update()</span><br><span class="line">    <span class="comment">// 返回自定义的resolver.Resolver</span></span><br><span class="line">    <span class="keyword">return</span> &amp;nopResolver&#123;cc: cc&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 discov 中，通过调用 load 方法从 etcd 中获取指定服务的所有地址：</p>
<p>并通过 watch 监听服务地址的变化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cluster)</span></span> watch(cli EtcdClient, key <span class="type">string</span>) &#123;</span><br><span class="line">    rch := cli.Watch(clientv3.WithRequireLeader(c.context(cli)), makeKeyPrefix(key), clientv3.WithPrefix())</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> wresp, ok := &lt;-rch:</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                logx.Error(<span class="string">&quot;etcd monitor chan has been closed&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> wresp.Canceled &#123;</span><br><span class="line">                logx.Error(<span class="string">&quot;etcd monitor chan has been canceled&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> wresp.Err() != <span class="literal">nil</span> &#123;</span><br><span class="line">                logx.Error(fmt.Sprintf(<span class="string">&quot;etcd monitor chan error: %v&quot;</span>, wresp.Err()))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 监听变化通知更新</span></span><br><span class="line">            c.handleWatchEvents(key, wresp.Events)</span><br><span class="line">        <span class="keyword">case</span> &lt;-c.done:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分主要介绍了 zRPC 中是如何自定义的 resolver，以及基于 etcd 的服务发现原理，通过这部分的介绍大家可以了解到 zRPC 内部服务注册发现的原理，源代码比较多只是粗略的从整个流程上进行了分析，如果大家对 zRPC 的源码比较感兴趣可以自行进行学习</p>
<h2 id="balancer-模块"><a href="#balancer-模块" class="headerlink" title="balancer 模块"></a>balancer 模块</h2><p>避免过载是负载均衡策略的一个重要指标，好的负载均衡算法能很好的平衡服务端资源。常用的负载均衡算法有轮训、随机、Hash、加权轮训等。但为了应对各种复杂的场景，简单的负载均衡算法往往表现的不够好，比如轮训算法当服务响应时间变长就很容易导致负载不再平衡， 因此 zRPC 中自定义了默认负载均衡算法 P2C(Power of Two Choices)，和 resolver 类似，要想自定义 balancer 也需要实现 gRPC 定义的 balancer.Builder 接口，由于和 resolver 类似这里不再带大家一起分析如何自定义 balancer，感兴趣的朋友可以查看 gRPC 相关的文档来进行学习</p>
<p>注意，zRPC 是在客户端进行负载均衡，常见的还有通过 nginx 中间代理的方式</p>
<p>zRPC 框架中默认的负载均衡算法为 P2C，该算法的主要思想是：</p>
<ol>
<li>从可用节点列表中做两次随机选择操作，得到节点 A、B</li>
<li>比较 A、B 两个节点，选出负载最低的节点作为被选中的节点</li>
</ol>
<h4 id="client-1"><a href="#client-1" class="headerlink" title="client"></a>client</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(target <span class="type">string</span>, opts ...ClientOption)</span></span> (*client, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> cli client</span><br><span class="line">    <span class="comment">// WithBalancerName 指定 p2c.Name</span></span><br><span class="line">	opts = <span class="built_in">append</span>([]ClientOption&#123;WithDialOption(grpc.WithBalancerName(p2c.Name))&#125;, opts...)</span><br><span class="line">	<span class="keyword">if</span> err := cli.dial(target, opts...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;cli, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pick"><a href="#pick" class="headerlink" title="pick"></a>pick</h4><p>主要算法逻辑在 Pick 方法中实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *p2cPicker)</span></span> Pick(ctx context.Context, info balancer.PickInfo) (</span><br><span class="line">	conn balancer.SubConn, done <span class="function"><span class="keyword">func</span><span class="params">(balancer.DoneInfo)</span></span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	p.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> chosen *subConn</span><br><span class="line">	<span class="keyword">switch</span> <span class="built_in">len</span>(p.conns) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, balancer.ErrNoSubConnAvailable</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		chosen = p.choose(p.conns[<span class="number">0</span>], <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		chosen = p.choose(p.conns[<span class="number">0</span>], p.conns[<span class="number">1</span>])</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">var</span> node1, node2 *subConn</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; pickTimes; i++ &#123;</span><br><span class="line">			a := p.r.Intn(<span class="built_in">len</span>(p.conns))</span><br><span class="line">			b := p.r.Intn(<span class="built_in">len</span>(p.conns) - <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">if</span> b &gt;= a &#123;</span><br><span class="line">				b++</span><br><span class="line">			&#125;</span><br><span class="line">			node1 = p.conns[a]</span><br><span class="line">			node2 = p.conns[b]</span><br><span class="line">			<span class="keyword">if</span> node1.healthy() &amp;&amp; node2.healthy() &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		chosen = p.choose(node1, node2)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	atomic.AddInt64(&amp;chosen.inflight, <span class="number">1</span>)</span><br><span class="line">	atomic.AddInt64(&amp;chosen.requests, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> chosen.conn, p.buildDoneFunc(chosen), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>choose 方法对随机选择出来的节点进行负载比较从而最终确定选择哪个节点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *p2cPicker)</span></span> choose(c1, c2 *subConn) *subConn &#123;</span><br><span class="line">	start := <span class="type">int64</span>(timex.Now())</span><br><span class="line">	<span class="keyword">if</span> c2 == <span class="literal">nil</span> &#123;</span><br><span class="line">		atomic.StoreInt64(&amp;c1.pick, start)</span><br><span class="line">		<span class="keyword">return</span> c1</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c1.load() &gt; c2.load() &#123;</span><br><span class="line">		c1, c2 = c2, c1</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pick := atomic.LoadInt64(&amp;c2.pick)</span><br><span class="line">	<span class="keyword">if</span> start-pick &gt; forcePick &amp;&amp; atomic.CompareAndSwapInt64(&amp;c2.pick, pick, start) &#123;</span><br><span class="line">		<span class="keyword">return</span> c2</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		atomic.StoreInt64(&amp;c1.pick, start)</span><br><span class="line">		<span class="keyword">return</span> c1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Jd0gGjiCVDFbvnXkRc6CHw">企业级 RPC 框架 zRPC</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/29/golang/golang%20New%20%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/29/golang/golang%20New%20%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">golang 抽象工厂模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-29 16:03:44" itemprop="dateCreated datePublished" datetime="2021-01-29T16:03:44+08:00">2021-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-26 23:35:58" itemprop="dateModified" datetime="2023-02-26T23:35:58+08:00">2023-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>golang 显然不是面向对象的语言，也不是面向对象编程。<strong>但是面向接口编程却不只是面向对象编程语言的专利，毕竟，接口本质上是一种协议定义，只要实现了这些定义了的协议的对象，都是这种接口类型。</strong></p>
<p>今天想要说的是大型项目都不会直接 New 一个接口，很多人可能没有接触过或者没有仔细研究过。这也非常合理，因为对于大部分的业务代码而言，一个单例模式加一个工厂模式，已经能够 cover 住绝大多数的扩张的场景了。</p>
<p>但是当我在研究 KrakenD 的源码中，我发现了更为可扩展的实践（请原谅我现在的见识短浅吧，我亲爱的读者）</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Router 接口只有一个 Run 方法，本质上来说，我们搞一个 工厂函数就可以实现多态的方式。但是一种更佳的实践是使用工厂接口（或者叫抽象工厂模式， 或者说是工厂的工厂）。</p>
<p><strong>例如这里的 Factory 接口， 比如我们的具体实现中有 gin factory, mux factory， 每个 factory 可以持有自己需要的众多对象，并且在 New Router 时，将这些对象赋值给 Router。这就将 Router 依赖的对象从 New Router 时传入，改为了在 New Facotry 时传入。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Router sets up the public layer exposed to the users</span></span><br><span class="line"><span class="keyword">type</span> Router <span class="keyword">interface</span> &#123;</span><br><span class="line">   Run(config.ServiceConfig)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RouterFunc type is an adapter to allow the use of ordinary functions as routers.</span></span><br><span class="line"><span class="comment">// If f is a function with the appropriate signature, RouterFunc(f) is a Router that calls f.</span></span><br><span class="line"><span class="keyword">type</span> RouterFunc <span class="function"><span class="keyword">func</span><span class="params">(config.ServiceConfig)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Run implements the Router interface</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f RouterFunc)</span></span> Run(cfg config.ServiceConfig) &#123; f(cfg) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Factory creates new routers</span></span><br><span class="line"><span class="keyword">type</span> Factory <span class="keyword">interface</span> &#123;</span><br><span class="line">   New() Router</span><br><span class="line">   NewWithContext(context.Context) Router</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="gin-factory"><a href="#gin-factory" class="headerlink" title="gin factory"></a>gin factory</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	Engine         *gin.Engine</span><br><span class="line">	Middlewares    []gin.HandlerFunc</span><br><span class="line">	HandlerFactory HandlerFactory</span><br><span class="line">	ProxyFactory   proxy.Factory</span><br><span class="line">	Logger         logging.Logger</span><br><span class="line">	RunServer      RunServerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> factory <span class="keyword">struct</span> &#123;</span><br><span class="line">	cfg Config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFactory</span><span class="params">(cfg Config)</span></span> router.Factory &#123;</span><br><span class="line">	<span class="keyword">return</span> factory&#123;cfg&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mux-factory"><a href="#mux-factory" class="headerlink" title="mux factory"></a>mux factory</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> factory <span class="keyword">struct</span> &#123;</span><br><span class="line">	cfg Config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	Engine         Engine</span><br><span class="line">	Middlewares    []HandlerMiddleware</span><br><span class="line">	HandlerFactory HandlerFactory</span><br><span class="line">	ProxyFactory   proxy.Factory</span><br><span class="line">	Logger         logging.Logger</span><br><span class="line">	DebugPattern   <span class="type">string</span></span><br><span class="line">	RunServer      RunServerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里的 config 和上面是不一样的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFactory</span><span class="params">(cfg Config)</span></span> router.Factory &#123;</span><br><span class="line">	<span class="keyword">if</span> cfg.DebugPattern == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		cfg.DebugPattern = DefaultDebugPattern</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> factory&#123;cfg&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/27/concurrent%20and%20gc/Golang%20%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%20sysmon/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/27/concurrent%20and%20gc/Golang%20%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%20sysmon/" class="post-title-link" itemprop="url">Golang 系统监控 sysmon</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-27 15:05:46" itemprop="dateCreated datePublished" datetime="2021-01-27T15:05:46+08:00">2021-01-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><h2 id="监控循环"><a href="#监控循环" class="headerlink" title="监控循环"></a>监控循环</h2><h3 id="启动-sysmon"><a href="#启动-sysmon" class="headerlink" title="启动 sysmon"></a>启动 sysmon</h3><p>当 Go 语言程序启动时，运行时会在第一个 Goroutine 中调用 runtime.main 启动主程序，该函数会在系统栈中创建新的线程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> GOARCH != <span class="string">&quot;wasm&quot;</span> &#123;</span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			newm(sysmon, <span class="literal">nil</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>runtime.newm -&gt; runtime.newm1 -&gt; runtime.newsproc -&gt; runtime.sysmon</strong></p>
<ul>
<li>在新创建的线程中，我们会执行存储在 runtime.m 中的 runtime.sysmon 启动系统监控.</li>
<li>运行时执行系统监控不需要处理器，系统监控的 Goroutine 会直接在创建的线程上运行.</li>
</ul>
<p><strong>sysmon 会在循环中完成以下的工作：</strong></p>
<ul>
<li>检查死锁</li>
<li>运行计时器 — 获取下一个需要被触发的计时器；</li>
<li>轮询网络 — 获取需要处理的到期文件描述符；</li>
<li>抢占处理器 — 抢占运行时间较长的或者处于系统调用的 Goroutine；</li>
<li>垃圾回收 — 在满足条件时触发垃圾收集回收内存；</li>
</ul>
<h4 id="sysmon-循环休眠时间"><a href="#sysmon-循环休眠时间" class="headerlink" title="sysmon 循环休眠时间"></a>sysmon 循环休眠时间</h4><p>系统监控在每次循环开始时都会通过 <code>usleep</code> 挂起当前线程，该函数的参数是微秒，运行时会遵循以下的规则决定休眠时间：</p>
<ul>
<li>初始的休眠时间是 20μs；</li>
<li>最长的休眠时间是 10ms；</li>
<li>当系统监控在 50 个循环中都没有唤醒 Goroutine 时，休眠时间在每个循环都会倍增；</li>
</ul>
<h4 id="检查死锁"><a href="#检查死锁" class="headerlink" title="检查死锁"></a>检查死锁</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkdead</span><span class="params">()</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> _, _p_ := <span class="keyword">range</span> allp &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(_p_.timers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	throw(<span class="string">&quot;all goroutines are asleep - deadlock!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>省略</p>
<h3 id="运行计时器"><a href="#运行计时器" class="headerlink" title="运行计时器"></a>运行计时器</h3><p>省略</p>
<h3 id="轮询网络"><a href="#轮询网络" class="headerlink" title="轮询网络"></a>轮询网络</h3><p>如果上一次轮询网络已经过去了 10ms，那么系统监控还会在循环中轮询网络，检查是否有待执行的文件描述符：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">    	lastpoll := <span class="type">int64</span>(atomic.Load64(&amp;sched.lastpoll))</span><br><span class="line">		<span class="keyword">if</span> netpollinited() &amp;&amp; lastpoll != <span class="number">0</span> &amp;&amp; lastpoll+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &lt; now &#123;</span><br><span class="line">			atomic.Cas64(&amp;sched.lastpoll, <span class="type">uint64</span>(lastpoll), <span class="type">uint64</span>(now))</span><br><span class="line">            <span class="comment">// 非阻塞地调用 runtime.netpoll 检查待执行的文件描述符并通过 runtime.injectglist 将所有处于就绪状态的 Goroutine 加入全局运行队列中：</span></span><br><span class="line">			list := netpoll(<span class="number">0</span>) <span class="comment">// non-blocking - returns list of goroutines</span></span><br><span class="line">			<span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">				<span class="comment">// Need to decrement number of idle locked M&#x27;s</span></span><br><span class="line">				<span class="comment">// (pretending that one more is running) before injectglist.</span></span><br><span class="line">				<span class="comment">// Otherwise it can lead to the following situation:</span></span><br><span class="line">				<span class="comment">// injectglist grabs all P&#x27;s but before it starts M&#x27;s to run the P&#x27;s,</span></span><br><span class="line">				<span class="comment">// another M returns from syscall, finishes running its G,</span></span><br><span class="line">				<span class="comment">// observes that there is no work to do and no other running M&#x27;s</span></span><br><span class="line">				<span class="comment">// and reports deadlock.</span></span><br><span class="line">				incidlelocked(<span class="number">-1</span>)</span><br><span class="line">				injectglist(&amp;list)</span><br><span class="line">				incidlelocked(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数会将所有 Goroutine 的状态从 _Gwaiting 切换至 _Grunnable 并加入全局运行队列等待运行，如果当前程序中存在空闲的处理器，会通过 runtime.startm 启动线程来执行这些任务。</p>
<h3 id="抢占处理器"><a href="#抢占处理器" class="headerlink" title="抢占处理器"></a>抢占处理器</h3><p>系统监控会在循环中调用 runtime.retake 抢占处于运行或者系统调用中的处理器，该函数会遍历运行时的全局处理器，每个处理器都存储了一个 runtime.sysmontick</p>
<ul>
<li><p>当处理器处于 _Prunning 或者 _Psyscall 状态时，如果上一次触发调度的时间已经过去了 10ms，我们会通过 <strong>runtime.preemptone</strong> 抢占当前处理器；</p>
</li>
<li><p>当处理器处于 _Psyscall 状态时，在满足以下两种情况下会调用 <strong>runtime.handoffp</strong> 让出处理器的使用权：</p>
<ul>
<li><p>当处理器的运行队列不为空或者不存在空闲处理器时2；</p>
</li>
<li><p>当系统调用时间超过了 10ms 时3；</p>
</li>
</ul>
</li>
</ul>
<p>系统监控通过在循环中抢占处理器来避免同一个 Goroutine 占用线程太长时间造成饥饿问题。</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>在最后，系统监控还会决定是否需要触发强制垃圾回收，runtime.sysmon 会构建 runtime.gcTrigger 并调用 runtime.gcTrigger.test 方法判断是否需要触发垃圾回收：</p>
<p><strong>如果需要触发垃圾回收，我们会将用于垃圾回收的 Goroutine 加入全局队列，让调度器选择合适的处理器去执行。</strong></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>运行时通过系统监控来触发线程的抢占、网络的轮询和垃圾回收，保证 Go 语言运行时的可用性。系统监控能够很好地解决尾延迟的问题，减少调度器调度 Goroutine 的饥饿问题并保证计时器在尽可能准确的时间触发。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/">原文：系统监控</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/26/concurrent%20and%20gc/Golang%20GPM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/26/concurrent%20and%20gc/Golang%20GPM/" class="post-title-link" itemprop="url">Golang GPM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-26 16:34:18" itemprop="dateCreated datePublished" datetime="2021-01-26T16:34:18+08:00">2021-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/">原文-调度器</a></p>
<ol>
<li>G — 表示 Goroutine，它是一个待执行的任务；</li>
<li>M — 表示操作系统的线程，它由操作系统的调度器调度和管理；</li>
<li>P — 表示处理器，它可以被看做运行在线程上的本地调度器，<strong>处理器</strong>；</li>
</ol>
<h2 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h2><h3 id="G-M-P-模型-（1-1）"><a href="#G-M-P-模型-（1-1）" class="headerlink" title="G-M-P 模型 （1.1）"></a>G-M-P 模型 （1.1）</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol>
<li>在当前的 G-M 模型中引入了处理器 P，增加中间层；</li>
<li>在处理器 P 的基础上实现基于工作窃取的调度器；</li>
</ol>
<p>基于工作窃取的多线程调度器将每一个线程绑定到了独立的 CPU 上，这些线程会被不同处理器管理，不同的处理器通过工作窃取对任务进行再分配实现任务的平衡，也能提升调度器和 Go 语言程序的整体性能，今天所有的 Go 语言服务都受益于这一改动。</p>
<p><strong>关键：工作窃取</strong></p>
<h4 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h4><p>解决锁竞争带来的性能问题</p>
<ol>
<li>调度器和锁是全局资源，所有的调度状态都是中心化存储的，锁竞争问严重；</li>
<li>线程需要经常互相传递可运行的 Goroutine，引入了大量的延迟；</li>
<li>每个线程都需要处理内存缓存，导致大量的内存占用并影响数据局部性；</li>
<li>系统调用频繁阻塞和解除阻塞正在运行的线程，增加了额外开销；</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>但是 1.1 版本中的调度器仍然不支持抢占式调度，程序只能依靠 Goroutine 主动让出 CPU 资源才能触发调度。</p>
<h3 id="基于协作的抢占式调度（1-2-1-13）"><a href="#基于协作的抢占式调度（1-2-1-13）" class="headerlink" title="基于协作的抢占式调度（1.2~1.13）"></a>基于协作的抢占式调度（1.2~1.13）</h3><p>Go 语言会在分段栈的机制上实现抢占调度，利用编译器在分段栈上插入的函数，所有 Goroutine 在函数调用时都有机会进入运行时检查是否需要执行抢占。</p>
<h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><ul>
<li>编译器会在调用函数前插入 runtime.morestack；</li>
<li>Go 语言运行时会在垃圾回收暂停程序、系统监控发现 Goroutine 运行超过 10ms 时发出抢占请求 StackPreempt；</li>
<li>当发生函数调用时，可能会执行编译器插入的 runtime.morestack，它调用的 runtime.newstack 会检查 Goroutine 的 stackguard0 字段是否为 StackPreempt；</li>
<li>如果 stackguard0 是 StackPreempt，就会触发抢占让出当前线程；</li>
</ul>
<p>这种实现方式虽然增加了运行时的复杂度，但是实现相对简单，也没有带来过多的额外开销，总体来看还是比较成功的实现，也在 Go 语言中使用了 10 几个版本。因为这里的抢占是通过编译器插入函数实现的，还是需要函数调用作为入口才能触发抢占，所以这是一种<strong>协作式的抢占式调度</strong>。</p>
<h4 id="解决的问题-1"><a href="#解决的问题-1" class="headerlink" title="解决的问题"></a>解决的问题</h4><ul>
<li>某些 Goroutine 可以长时间占用线程，造成其它 Goroutine 的饥饿；</li>
<li>垃圾回收需要暂停整个程序（Stop-the-world，STW），最长可能需要几分钟的时间，导致整个程序无法工作；</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>不够好</p>
<h3 id="基于信号的抢占式调度"><a href="#基于信号的抢占式调度" class="headerlink" title="基于信号的抢占式调度"></a>基于信号的抢占式调度</h3><p>STW 和栈扫描是一个可以抢占的安全点（Safe-points），所以 Go 语言会在这里先加入抢占功能。基于信号的抢占式调度只解决了垃圾回收和栈扫描时存在的问题，它到目前为止没有解决所有问题，但是这种真抢占式调度是调度器走向完备的开始，相信在未来我们会在更多的地方触发抢占。</p>
<h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><p>Goroutine 是 Go 语言调度器中待执行的任务，它在运行时调度器中的地位与线程在操作系统中差不多，但是它占用了更小的内存空间，也降低了上下文切换的开销。</p>
<p>Goroutine 只存在于 Go 语言的运行时，它是 Go 语言在用户态提供的线程，作为一种粒度更细的资源调度单元，如果使用得当能够在高并发的场景下更高效地利用机器的 CPU。</p>
<p>Goroutine 在 Go 语言运行时使用私有结构体 runtime.g 表示。</p>
<h3 id="Goroutine-的状态"><a href="#Goroutine-的状态" class="headerlink" title="Goroutine 的状态"></a>Goroutine 的状态</h3><p>结构体 runtime.g 的 atomicstatus 字段存储了当前 Goroutine 的状态。除了几个已经不被使用的以及与 GC 相关的状态之外，Goroutine 可能处于以下 9 种状态：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>_Gidle</code></td>
<td>刚刚被分配并且还没有被初始化</td>
</tr>
<tr>
<td><code>_Grunnable</code></td>
<td>没有执行代码，没有栈的所有权，存储在运行队列中</td>
</tr>
<tr>
<td><code>_Grunning</code></td>
<td>可以执行代码，拥有栈的所有权，被赋予了内核线程 M 和处理器 P</td>
</tr>
<tr>
<td><code>_Gsyscall</code></td>
<td>正在执行系统调用，拥有栈的所有权，没有执行用户代码，被赋予了内核线程 M 但是不在运行队列上</td>
</tr>
<tr>
<td><code>_Gwaiting</code></td>
<td>由于运行时而被阻塞，没有执行用户代码并且不在运行队列上，但是可能存在于 Channel 的等待队列上</td>
</tr>
<tr>
<td><code>_Gdead</code></td>
<td>没有被使用，没有执行代码，可能有分配的栈</td>
</tr>
<tr>
<td><code>_Gcopystack</code></td>
<td>栈正在被拷贝，没有执行代码，不在运行队列上</td>
</tr>
<tr>
<td><code>_Gpreempted</code></td>
<td>由于抢占而被阻塞，没有执行用户代码并且不在运行队列上，等待唤醒</td>
</tr>
<tr>
<td><code>_Gscan</code></td>
<td>GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在</td>
</tr>
</tbody></table>
<p>虽然 Goroutine 在运行时中定义的状态非常多而且复杂，但是我们可以将这些不同的状态聚合成三种：等待中、可运行、运行中，运行期间会在这三种状态来回切换：</p>
<ul>
<li>等待中：Goroutine 正在等待某些条件满足，例如：系统调用结束等，包括 <code>_Gwaiting</code>、<code>_Gsyscall</code> 和 <code>_Gpreempted</code> 几个状态；</li>
<li>可运行：Goroutine 已经准备就绪，可以在线程运行，如果当前程序中有非常多的 Goroutine，每个 Goroutine 就可能会等待更多的时间，即 <code>_Grunnable</code>；</li>
<li>运行中：Goroutine 正在某个线程上运行，即 <code>_Grunning</code>；</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/sjJgwF"><img src="https://s3.ax1x.com/2021/01/26/sjJgwF.png" alt="sjJgwF.png"></a></p>
<h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><h3 id="CPU-和活跃线程"><a href="#CPU-和活跃线程" class="headerlink" title="CPU 和活跃线程"></a>CPU 和活跃线程</h3><p>Go 语言并发模型中的 M 是操作系统线程。调度器最多可以创建 10000 个线程，但是其中大多数的线程都不会执行用户代码（可能陷入系统调用），最多只会有 <code>GOMAXPROCS</code> 个活跃线程能够正常运行。</p>
<p>在默认情况下，运行时会将 GOMAXPROCS 设置成当前机器的核数，我们也可以在程序中使用 runtime.GOMAXPROCS 来改变最大的活跃线程数。</p>
<p>Go 语言会使用私有结构体 runtime.m 表示操作系统线程，这个结构体也包含了几十个字段.</p>
<h3 id="调度-Goroutine-和运行-Goroutine"><a href="#调度-Goroutine-和运行-Goroutine" class="headerlink" title="调度 Goroutine 和运行 Goroutine"></a>调度 Goroutine 和运行 Goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">	g0   *g</span><br><span class="line">	curg *g</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 g0 是持有调度栈的 Goroutine，<code>curg</code> 是在当前线程上运行的用户 Goroutine，这也是操作系统线程唯一关心的两个 Goroutine。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/sjTse0"><img src="https://s3.ax1x.com/2021/01/26/sjTse0.png" alt="sjTse0.png"></a></p>
<p>g0 是一个运行时中比较特殊的 Goroutine，它会深度参与运行时的调度过程，包括 Goroutine 的创建、大内存分配和 CGO 函数的执行。</p>
<p>runtime.m 结构体中还存在三个与处理器相关的字段，它们分别表示正在运行代码的处理器 p、暂存的处理器 nextp 和执行系统调用之前使用线程的处理器 oldp：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">	p             puintptr</span><br><span class="line">	nextp         puintptr</span><br><span class="line">	oldp          puintptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P"><a href="#P" class="headerlink" title="P"></a>P</h2><p>调度器中的处理器 P 是线程和 Goroutine 的中间层，它能提供线程需要的上下文环境，也会负责调度线程上的等待队列，通过处理器 P 的调度，每一个内核线程都能够执行多个 Goroutine，它能在 Goroutine 进行一些 I&#x2F;O 操作时及时让出计算资源，提高线程的利用率。</p>
<p>runtime.p 是处理器的运行时表示，作为调度器的内部实现，它包含的字段也非常多，其中包括与性能追踪、垃圾回收和计时器相关的字段，这些字段也非常重要，但是在这里就不展示了，我们主要关注处理器中的线程和运行队列：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">	m           muintptr</span><br><span class="line"></span><br><span class="line">	runqhead <span class="type">uint32</span></span><br><span class="line">	runqtail <span class="type">uint32</span></span><br><span class="line">	runq     [<span class="number">256</span>]guintptr</span><br><span class="line">	runnext guintptr</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>反向存储的线程维护着线程与处理器之间的关系，而 <code>runhead</code>、<code>runqtail</code> 和 <code>runq</code> 三个字段表示处理器持有的运行队列，其中存储着待执行的 Goroutine 列表，<code>runnext</code> 中是线程下一个需要执行的 Goroutine。</strong></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>_Pidle</code></td>
<td>处理器没有运行用户代码或者调度器，被空闲队列或者改变其状态的结构持有，运行队列为空</td>
</tr>
<tr>
<td><code>_Prunning</code></td>
<td>被线程 M 持有，并且正在执行用户代码或者调度器</td>
</tr>
<tr>
<td><code>_Psyscall</code></td>
<td>没有执行用户代码，当前线程陷入系统调用</td>
</tr>
<tr>
<td><code>_Pgcstop</code></td>
<td>被线程 M 持有，当前处理器由于垃圾回收被停止</td>
</tr>
<tr>
<td><code>_Pdead</code></td>
<td>当前处理器已经不被使用</td>
</tr>
</tbody></table>
<p>通过分析处理器 P 的状态，我们能够对处理器的工作过程有一些简单理解，例如处理器在执行用户代码时会处于 <code>_Prunning</code> 状态，在当前线程执行 I&#x2F;O 操作时会陷入 <code>_Psyscall</code> 状态。</p>
<h2 id="调度器启动"><a href="#调度器启动" class="headerlink" title="调度器启动"></a>调度器启动</h2><p>调度器的启动过程是我们平时比较难以接触的过程，不过作为程序启动前的准备工作，理解调度器的启动过程对我们理解调度器的实现原理很有帮助，运行时通过 runtime.schedinit 初始化调度器：</p>
<p>调用 runtime.procresize 是调度器启动的最后一步，在这一步过后调度器会完成相应数量处理器的启动，等待用户创建运行新的 Goroutine 并为 Goroutine 调度处理器资源。</p>
<h2 id="创建-Goroutine"><a href="#创建-Goroutine" class="headerlink" title="创建 Goroutine"></a>创建 Goroutine</h2><p>想要启动一个新的 Goroutine 来执行任务时，我们需要使用 Go 语言的 go 关键字，编译器会通过 cmd&#x2F;compile&#x2F;internal&#x2F;gc.state.stmt 和 cmd&#x2F;compile&#x2F;internal&#x2F;gc.state.call 两个方法将该关键字转换成 runtime.newproc 函数调用：</p>
<h3 id="newproc"><a href="#newproc" class="headerlink" title="newproc"></a>newproc</h3><p>runtime.newproc 的入参是参数大小和表示函数的指针 funcval，它会获取 Goroutine 以及调用方的程序计数器，然后调用 runtime.newproc1 函数获取新的 Goroutine 结构体、将其加入处理器的运行队列并在满足条件时调用 runtime.wakep 唤醒新的处理执行 Goroutine：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="type">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">	argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">	gp := getg()</span><br><span class="line">	pc := getcallerpc()</span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		newg := newproc1(fn, argp, siz, gp, pc)</span><br><span class="line"></span><br><span class="line">		_p_ := getg().m.p.ptr()</span><br><span class="line">		runqput(_p_, newg, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> mainStarted &#123;</span><br><span class="line">			wakep()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化-g-结构体（newproc1）"><a href="#初始化-g-结构体（newproc1）" class="headerlink" title="初始化 g 结构体（newproc1）"></a>初始化 g 结构体（newproc1）</h3><p>runtime.gfget 通过两种不同的方式获取新的 runtime.g：</p>
<ul>
<li>从 Goroutine 所在处理器的 gFree 列表或者调度器的 sched.gFree 列表中获取 runtime.g；</li>
<li>调用 runtime.malg 生成一个新的 runtime.g 并将结构体追加到全局的 Goroutine 列表 allgs 中。</li>
</ul>
<h4 id="runtime-gfget"><a href="#runtime-gfget" class="headerlink" title="runtime.gfget"></a>runtime.gfget</h4><p>runtime.gfget 中包含两部分逻辑，它会根据处理器中 gFree 列表中 Goroutine 的数量做出不同的决策：</p>
<ul>
<li>当处理器的 Goroutine 列表为空时，会将调度器持有的空闲 Goroutine 转移到当前处理器上，直到 gFree 列表中的 Goroutine 数量达到 32；</li>
<li>当处理器的 Goroutine 数量充足时，会从列表头部返回一个新的 Goroutine；</li>
</ul>
<h4 id="malg"><a href="#malg" class="headerlink" title="malg"></a>malg</h4><p>当调度器的 gFree 和处理器的 gFree 列表都不存在结构体时，运行时会调用 runtime.malg 初始化新的 runtime.g 结构，如果申请的堆栈大小大于 0，这里会通过 runtime.stackalloc 分配 2KB 的栈空间</p>
<h4 id="allgadd"><a href="#allgadd" class="headerlink" title="allgadd"></a>allgadd</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">allgadd(newg) <span class="comment">// publishes with a g-&gt;status of Gdead so GC scanner doesn&#x27;t look at uninitialized stack.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allgadd</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	lock(&amp;allglock)</span><br><span class="line">    <span class="comment">// 全局变量 allgs append 新的 g</span></span><br><span class="line">	allgs = <span class="built_in">append</span>(allgs, gp)</span><br><span class="line">	allglen = <span class="type">uintptr</span>(<span class="built_in">len</span>(allgs))</span><br><span class="line">	unlock(&amp;allglock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行队列-（runqput）"><a href="#运行队列-（runqput）" class="headerlink" title="运行队列 （runqput）"></a>运行队列 （runqput）</h3><p>runtime.runqput 会将 Goroutine 放到运行队列上，这既可能是全局的运行队列，也可能是处理器本地的运行队列：</p>
<ul>
<li>当 next 为 true 时，将 Goroutine 设置到处理器的 runnext 作为下一个处理器执行的任务；</li>
<li>当 next 为 false 并且本地运行队列还有剩余空间时，将 Goroutine 加入处理器持有的本地运行队列；</li>
<li>当处理器的本地运行队列已经没有剩余空间时就会把本地队列中的一部分 Goroutine 和待加入的 Goroutine 通过 runtime.runqputslow 添加到调度器持有的全局运行队列上；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">retry:</span><br><span class="line">	h := atomic.LoadAcq(&amp;_p_.runqhead) <span class="comment">// load-acquire, synchronize with consumers</span></span><br><span class="line">	t := _p_.runqtail</span><br><span class="line">	<span class="comment">// _p_.runq 是个固定大小为 256 的数组</span></span><br><span class="line">	<span class="keyword">if</span> t-h &lt; <span class="type">uint32</span>(<span class="built_in">len</span>(_p_.runq)) &#123;</span><br><span class="line">		_p_.runq[t%<span class="type">uint32</span>(<span class="built_in">len</span>(_p_.runq))].set(gp)</span><br><span class="line">		atomic.StoreRel(&amp;_p_.runqtail, t+<span class="number">1</span>) <span class="comment">// store-release, makes the item available for consumption</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 没有走上面的逻辑，说明 _P_ 的本地队列已满，只能添加到调度器的全局运行队列</span></span><br><span class="line">	<span class="keyword">if</span> runqputslow(_p_, gp, h, t) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// the queue is not full, now the put above must succeed</span></span><br><span class="line">	<span class="keyword">goto</span> retry</span><br></pre></td></tr></table></figure>

<p>处理器本地的运行队列是一个使用数组构成的环形链表，它最多可以存储 256 个待执行任务。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/svSxXT"><img src="https://s3.ax1x.com/2021/01/26/svSxXT.png" alt="svSxXT.png"></a></p>
<p><strong>简单总结一下，Go 语言有两个运行队列，其中一个是处理器本地的运行队列，另一个是调度器持有的全局运行队列，只有在本地运行队列没有剩余空间时才会使用全局队列。</strong></p>
<h3 id="调度信息"><a href="#调度信息" class="headerlink" title="调度信息"></a>调度信息</h3><p>运行时创建 Goroutine 时会通过下面的代码设置调度相关的信息，前两行代码会分别将程序计数器和 Goroutine 设置成 runtime.goexit 和新创建 Goroutine 运行的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newg.sched.pc = funcPC(goexit) + sys.PCQuantum</span><br><span class="line">newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line">gostartcallfn(&amp;newg.sched, fn)</span><br></pre></td></tr></table></figure>

<p>调度信息的 sp 中存储了 runtime.goexit 函数的程序计数器，而 pc 中存储了传入函数的程序计数器。因为 pc 寄存器的作用就是存储程序接下来运行的位置，所以 pc 的使用比较好理解，但是 sp 中存储的 runtime.goexit 会让人感到困惑，我们需要配合下面的调度循环来理解它的作用。</p>
<h2 id="调度循环"><a href="#调度循环" class="headerlink" title="调度循环"></a>调度循环</h2><p>调度器启动之后，Go 语言运行时会调用 runtime.mstart 以及 runtime.mstart1，前者会初始化 g0 的 stackguard0 和 stackguard1 字段，后者会初始化线程并调用 runtime.schedule 进入调度循环：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// Check the global runnable queue once in a while to ensure fairness.</span></span><br><span class="line">	<span class="comment">// Otherwise two goroutines can completely occupy the local runqueue</span></span><br><span class="line">	<span class="comment">// by constantly respawning each other.</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.p.ptr().schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">		lock(&amp;sched.lock)</span><br><span class="line">           <span class="comment">// globrunqget 全局队列</span></span><br><span class="line">		gp = globrunqget(_g_.m.p.ptr(), <span class="number">1</span>)</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="comment">// p 本地队列</span></span><br><span class="line">	gp, inheritTime = runqget(_g_.m.p.ptr())</span><br><span class="line">	<span class="comment">// We can see gp != nil here even if the M is spinning,</span></span><br><span class="line">	<span class="comment">// if checkTimers added a local goroutine via goready.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">	gp, inheritTime = findrunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="runtime-schedule-（调度入口）"><a href="#runtime-schedule-（调度入口）" class="headerlink" title="runtime.schedule （调度入口）"></a>runtime.schedule （调度入口）</h3><p>runtime.schedule 函数会从下面几个地方查找待执行的 Goroutine：</p>
<ul>
<li>为了保证公平，当全局运行队列中有待执行的 Goroutine 时，通过 schedtick 保证有一定几率会从全局的运行队列中查找对应的 Goroutine；</li>
<li>从处理器本地的运行队列中查找待执行的 Goroutine；</li>
<li>如果前两种方法都没有找到 Goroutine，会通过 runtime.findrunnable 进行阻塞地查找 Goroutine；</li>
</ul>
<h3 id="runtime-findrunnable-（兜底找-g）"><a href="#runtime-findrunnable-（兜底找-g）" class="headerlink" title="runtime.findrunnable （兜底找 g）"></a>runtime.findrunnable （兜底找 g）</h3><p>runtime.findrunnable 的实现非常复杂，这个 300 多行的函数通过以下的过程获取可运行的 Goroutine：</p>
<ul>
<li><p>从本地运行队列、全局运行队列中查找；</p>
</li>
<li><p>从网络轮询器中查找是否有 Goroutine 等待运行；</p>
</li>
<li><p>通过 runtime.runqsteal 尝试从其他随机的处理器中窃取待运行的 Goroutine，该函数还可能窃取处理器的计时器；</p>
</li>
</ul>
<p>因为函数的实现过于复杂，上述的执行过程是经过简化的，总而言之，<strong>当前函数一定会返回一个可执行的 Goroutine，如果当前不存在就会阻塞等待</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findrunnable</span><span class="params">()</span></span> (gp *g, inheritTime <span class="type">bool</span>) &#123;</span><br><span class="line">    		<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> top</span><br><span class="line">			&#125;</span><br><span class="line">			stealRunNextG := i &gt; <span class="number">2</span> <span class="comment">// first look for ready queues with more than 1 g</span></span><br><span class="line">			p2 := allp[enum.position()]</span><br><span class="line">			<span class="keyword">if</span> _p_ == p2 &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 遍历所有的 p 偷取 g</span></span><br><span class="line">			<span class="keyword">if</span> gp := runqsteal(_p_, p2, stealRunNextG); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Steal half of elements from local runnable queue of p2</span></span><br><span class="line"><span class="comment">// and put onto local runnable queue of p.</span></span><br><span class="line"><span class="comment">// Returns one of the stolen elements (or nil if failed).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqsteal</span><span class="params">(_p_, p2 *p, stealRunNextG <span class="type">bool</span>)</span></span> *g &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="runtime-execute-（执行-g）"><a href="#runtime-execute-（执行-g）" class="headerlink" title="runtime.execute （执行 g）"></a>runtime.execute （执行 g）</h3><p>接下来由 runtime.execute 执行获取的 Goroutine，做好准备工作后，它会通过 runtime.gogo 将 Goroutine 调度到当前线程上。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(gp *g, inheritTime <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Assign gp.m before entering _Grunning so running Gs have an</span></span><br><span class="line">	<span class="comment">// M.</span></span><br><span class="line">	_g_.m.curg = gp</span><br><span class="line">	gp.m = _g_.m</span><br><span class="line">	casgstatus(gp, _Grunnable, _Grunning)</span><br><span class="line">	gp.waitsince = <span class="number">0</span></span><br><span class="line">	gp.preempt = <span class="literal">false</span></span><br><span class="line">	gp.stackguard0 = gp.stack.lo + _StackGuard</span><br><span class="line">	<span class="keyword">if</span> !inheritTime &#123;</span><br><span class="line">		_g_.m.p.ptr().schedtick++</span><br><span class="line">	&#125;</span><br><span class="line">    gogo(&amp;gp.sched)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gogo"><a href="#gogo" class="headerlink" title="gogo"></a>gogo</h3><p>在函数调用一节中，我们曾经介绍过 Go 语言的调用惯例，正常的函数调用都会使用 CALL 指令，该指令会将调用方的返回地址加入栈寄存器 SP 中，然后跳转到目标函数；当目标函数返回后，会从栈中查找调用的地址并跳转回调用方继续执行剩下的代码。</p>
<p>runtime.gogo 就利用了 Go 语言的调用惯例成功模拟这一调用过程，通过以下几个关键指令模拟 CALL 的过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOVL gobuf_sp(BX), SP  <span class="comment">// 将 runtime.goexit 函数的 PC 恢复到 SP 中</span></span><br><span class="line">MOVL gobuf_pc(BX), BX  <span class="comment">// 获取待执行函数的程序计数器</span></span><br><span class="line">JMP  BX                <span class="comment">// 开始执行</span></span><br></pre></td></tr></table></figure>

<h3 id="goexit0-gt-schedule"><a href="#goexit0-gt-schedule" class="headerlink" title="goexit0 -&gt; schedule"></a>goexit0 -&gt; schedule</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit0</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	casgstatus(gp, _Grunning, _Gdead)</span><br><span class="line">	gp.m = <span class="literal">nil</span></span><br><span class="line">	...</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	gp.labels = <span class="literal">nil</span></span><br><span class="line">	gp.timer = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	dropg()</span><br><span class="line">	gfput(_g_.m.p.ptr(), gp)</span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在最后 runtime.goexit0 会重新调用 runtime.schedule 触发新一轮的 Goroutine 调度，Go 语言中的运行时调度循环会从 runtime.schedule 开始，最终又回到 runtime.schedule，我们可以认为调度循环永远都不会返回。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/sxi5E8"><img src="https://s3.ax1x.com/2021/01/27/sxi5E8.png" alt="sxi5E8.png"></a></p>
<h2 id="触发调度"><a href="#触发调度" class="headerlink" title="触发调度"></a>触发调度</h2><p>这里简单介绍下所有触发调度的时间点，因为调度器的 runtime.schedule 会重新选择 Goroutine 在线程上执行，所以我们只要找到该函数的调用方就能找到所有触发调度的时间点，经过分析和整理，我们能得到如下的树形结构：</p>
<h3 id="调度时间点"><a href="#调度时间点" class="headerlink" title="调度时间点"></a>调度时间点</h3><p>除了上图中可能触发调度的时间点，运行时还会在线程启动 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mstart"><code>runtime.mstart</code></a> 和 Goroutine 执行结束 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.goexit0"><code>runtime.goexit0</code></a> 触发调度。我们在这里会重点介绍运行时触发调度的几个路径：</p>
<ul>
<li>主动挂起 — <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.gopark"><code>runtime.gopark</code></a> -&gt; <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.park_m"><code>runtime.park_m</code></a></li>
<li>系统调用 — <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.exitsyscall"><code>runtime.exitsyscall</code></a> -&gt; <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.exitsyscall0"><code>runtime.exitsyscall0</code></a></li>
<li>协作式调度 — <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.Gosched"><code>runtime.Gosched</code></a> -&gt; <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.gosched_m"><code>runtime.gosched_m</code></a> -&gt; <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.goschedImpl"><code>runtime.goschedImpl</code></a></li>
<li>系统监控 — <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.sysmon"><code>runtime.sysmon</code></a> -&gt; <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.retake"><code>runtime.retake</code></a> -&gt; <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.preemptone"><code>runtime.preemptone</code></a></li>
</ul>
<h3 id="主动挂起"><a href="#主动挂起" class="headerlink" title="主动挂起"></a>主动挂起</h3><h4 id="gopark"><a href="#gopark" class="headerlink" title="gopark"></a>gopark</h4><p>runtime.gopark 是触发调度最常见的方法，该函数会将当前 Goroutine 暂停，被暂停的任务不会放回运行队列，我们来分析该函数的实现原理：</p>
<p>runtime.gopark 会通过 runtime.mcall 切换到 g0 的栈上调用 runtime.park_m.</p>
<p>runtime.park_m <strong>会将当前 Goroutine 的状态从 _Grunning 切换至 _Gwaiting，调用 runtime.dropg 移除线程和 Goroutine 之间的关联（此时 M 上没有 g，触发调度后为 M 找一个 g），在这之后就可以调用 runtime.schedule 触发新一轮的调度了。</strong></p>
<h4 id="ready"><a href="#ready" class="headerlink" title="ready"></a>ready</h4><p>当 Goroutine 等待的特定条件满足后，运行时会调用 runtime.goready 将因为调用 runtime.gopark 而陷入休眠的 Goroutine 唤醒。</p>
<p>runtime.ready 会将准备就绪的 Goroutine 的状态切换至 _Grunnable 并将其加入处理器的运行队列中，等待调度器的调度。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>省略</p>
<h3 id="协作式调度"><a href="#协作式调度" class="headerlink" title="协作式调度"></a>协作式调度</h3><p>我们在设计原理中介绍过了 Go 语言基于协作式和信号的两种抢占式调度，这里主要介绍其中的协作式调度。runtime.Gosched 函数会主动让出处理器，允许其他 Goroutine 运行。该函数无法挂起 Goroutine，调度器会在可能会将当前 Goroutine 调度到其他线程上：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Gosched yields the processor, allowing other goroutines to run. It does not</span></span><br><span class="line"><span class="comment">// suspend the current goroutine, so execution resumes automatically.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Gosched</span><span class="params">()</span></span> &#123;</span><br><span class="line">	checkTimeouts()</span><br><span class="line">	mcall(gosched_m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gosched_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	goschedImpl(gp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goschedImpl</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	casgstatus(gp, _Grunning, _Grunnable)</span><br><span class="line">	dropg()</span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 经过连续几次跳转，我们最终在 g0 的栈上调用 runtime.goschedImpl，运行时会更新 Goroutine 的状态到 _Grunnable，让出当前的处理器并将 Goroutine 重新放回全局队列，在最后，该函数会调用 runtime.schedule 触发调度。</span></span><br><span class="line">	globrunqput(gp)</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="为什么一定要有上下文？（P，-准确来说，是处理器哈）"><a href="#为什么一定要有上下文？（P，-准确来说，是处理器哈）" class="headerlink" title="为什么一定要有上下文？（P， 准确来说，是处理器哈）"></a>为什么一定要有上下文？（P， 准确来说，是处理器哈）</h3><ol>
<li>阻塞的情况：如果G被阻塞在某个system call操作上，那么不光G会阻塞，执行该G的M也会解绑P(实质是被sysmon抢走了)，与G一起进入sleep状态。如果此时有idle的M，则P与其绑定继续执行其他G；如果没有idle M，但仍然有其他G要去执行，那么就会创建一个新M。（<strong>注意，Go 语言并发模型中的 M 是操作系统线程。调度器最多可以创建 10000 个线程，但是其中大多数的线程都不会执行用户代码（可能陷入系统调用），最多只会有 <code>GOMAXPROCS</code> 个活跃线程能够正常运行。</strong>）</li>
<li>解决了很多 GM 模型的缺点，如锁竞争， 线程传递g开销大，线程内存缓存太多（影响数据局部性）</li>
</ol>
<p>总体来说，M 应该和一个稳定的用户态数据绑定。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/">原文-调度器</a></p>
<p>这个比较厉害：<a target="_blank" rel="noopener" href="https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/">https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/22/message%20queue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8Bpulsar%20broker%20%E9%9B%86%E7%BE%A4%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/22/message%20queue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8Bpulsar%20broker%20%E9%9B%86%E7%BE%A4%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" class="post-title-link" itemprop="url">消息队列之pulsar broker 集群的负载均衡</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-22 19:45:37" itemprop="dateCreated datePublished" datetime="2021-01-22T19:45:37+08:00">2021-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/sTdrdA"><img src="https://s3.ax1x.com/2021/01/23/sTdrdA.md.png" alt="sTdrdA.md.png"></a></p>
<p>namespace, bundle, topic, broker.</p>
<p>例如，一个 namespace 有 4 个 bundle，100 个 topic，2 个 broker，那么这 100 个 topic，会均分到 4 个bundle里， 而这 4 个 bundle 又会均分到 2 个 broker 里。这是理想情况。</p>
<p>再例如，一个 namespace 有 4 个 bundle，1 个 topic，2 个 broker， 那么这 1 个 topic， 只会分配到一个 bundle 里，而这 1 个 bundle 也只会分配到 1个 broker 里。 这就负载不均衡了。这里的 1 个 topic， 也可以是有 100 个 topic， 但是其中一个 topic 的消息量特别大，其他 topic 的消息量特别小。所以对于消息量很大的 topic， 需要使用分区 topic。</p>
<blockquote>
<p>In case of partitioned topics, different partitions are assigned to different brokers. Here “topic” means either a non-partitioned topic or one partition of a topic.</p>
</blockquote>
<h2 id="Pulsar-broker集群负载均衡"><a href="#Pulsar-broker集群负载均衡" class="headerlink" title="Pulsar broker集群负载均衡"></a>Pulsar broker集群负载均衡</h2><p>Pulsar 是一个横向可伸缩的消息系统，其中一个核心需求是：一个合理的集群中的流量必须尽可能均匀地分布在所有可用的 Pulsar brokers 上。</p>
<p>您可以使用多种设置和工具来控制流量分布，这需要了解一些如何在 Pulsar 中管理流量的背景知识。 当然，在大多数情况下，上面提到的核心需求是开箱即用的，您不必担心。</p>
<h2 id="Pulsar-负载管理体系架构"><a href="#Pulsar-负载管理体系架构" class="headerlink" title="Pulsar 负载管理体系架构"></a>Pulsar 负载管理体系架构</h2><p>接下来的部分介绍了 Pulsar 负载管理器（load manager）的基本结构。</p>
<h3 id="动态分配topic"><a href="#动态分配topic" class="headerlink" title="动态分配topic"></a>动态分配topic</h3><ol>
<li>当客户端开始使用一个新的topic的时候，topic会被分配到一个broker上面。</li>
<li>当一个broker crash，该broker上面的topic会被重新分配到别的broker上面</li>
<li>当一个broker过载过后，会分配部分topic到负载更低的broker上面</li>
<li>新加一个broker后，如果以前的broker的负载不到达一定的阈值，是不会分配老的topic到新的broker上的</li>
</ol>
<blockquote>
<p>In case of partitioned topics, different partitions are assigned to different brokers. Here “topic” means either a non-partitioned topic or one partition of a topic.</p>
</blockquote>
<p>又因为 Brokers 的无状态特性，使得根据使用情况动态分配成为可能，如可以快速扩容或缩小集群规模。</p>
<h3 id="分配粒度"><a href="#分配粒度" class="headerlink" title="分配粒度"></a>分配粒度</h3><p>topic的动态分配并不是在topic或者partition级别进行分配的。 而是在namespace的bundle级别进行分配。</p>
<p>一个bundle作为一个整体分配到不同的broker上面。</p>
<p>一个namespace可以配置为包含N个bundle，topic根据hash值分配到不同的bundle上面。</p>
<p>每个 bundle 都是独立的，因此会被独立的分配到不同的 broker。</p>
<h3 id="创建命名空间和包"><a href="#创建命名空间和包" class="headerlink" title="创建命名空间和包"></a>创建命名空间和包</h3><p>当你创建一个新的命名空间时，这个命名空间将使用默认的 bundle 数量。 您可以在 <code>conf/brocher.conf</code> 中设置此选项：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当命名空间创建时没有指定 bundle 数量时，将使用这个默认的值。</span></span><br><span class="line"><span class="attr">defaultNumberOfNamespaceBundles</span>=<span class="string">4</span></span><br></pre></td></tr></table></figure>

<p>你可以更改系统默认设置，或者在创建新的命名空间时指定这个值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/pulsar-admin namespaces create my-tenant/my-namespace --clusters us-west --bundles 16</span></span><br></pre></td></tr></table></figure>

<p>如上命令，创建命名空间时指定了 bundle 数量为16. 因此，这个命名空间里面的所有主题就可以分布到16个 broker 里面。</p>
<p>正常情况下， 应设置 bundle 数量大于 broker数量。因为主题是根据哈希自动分布到 bundle 里面的。 例如，命令空间内有1000个主题，可以使用比如 64 个 bundle ，让流量均匀的分布在 16 个broker上。</p>
<h3 id="拆分命名空间"><a href="#拆分命名空间" class="headerlink" title="拆分命名空间"></a>拆分命名空间</h3><p>由于 bundle 中主题的负载会随着时间的变化而变化，或者在前期很难预测流量的变化。所以，broker 支持将一个 bundle 拆分为两个。 此时新建的 bundle 会被重新分配到其他的 broker。</p>
<p>默认情况下，新拆出来的 bundle 总是立刻分配到其他的broker，以平衡流量分布。</p>
<h3 id="自动负载切分"><a href="#自动负载切分" class="headerlink" title="自动负载切分"></a>自动负载切分</h3><p>Pulsar 的负载管理器支持自动的负载切分。 这意味着，当系统检测到某个 broker 过载时，系统会强制将一些流量自动分配到一些低负载的broker。</p>
<p>即当检测到 broker 过载时，broker 将强制 ”卸载“ bundle 的一些流量较大的子集，以降低 broker 的负载。</p>
<p>默认情况下，自动负载切分是启用的。 你能够通过如下配置项禁用自动负载切分：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用/禁用自动负载拆分</span></span><br><span class="line"><span class="attr">loadBalancerSheddingEnabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<h4 id="Broker-过载阈值"><a href="#Broker-过载阈值" class="headerlink" title="Broker 过载阈值"></a>Broker 过载阈值</h4><p>Broker 是基于 Cpu，网络，和内存使用的阈值来判断是否过载的。 当其中任何一个指标超过阈值时，将会触发切分操作(如果允许的话)。</p>
<p>默认情况下，负载阈值设置为85%：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用阈值确定 broker 是否过载</span></span><br><span class="line"><span class="attr">loadBalancerBrokerOverloadedThresholdPercentage</span>=<span class="string">85</span></span><br></pre></td></tr></table></figure>

<p>Pulsar 会从系统中采集这些指标的使用情况。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来说， pulsar 的负载均衡是在每一个 pulsar broker 参与实现的。在使用过程中，消费者和生产者关注 namespace 和 topic。在负载均衡器中， 新增加了一个 bundle 的概念。一个 namespace 下可以有 N 个 bundle， 这个 N 最好是 broker 集群节点的整数倍。topic 根据 hash 策略被分配到一个 bundle 上，一个 bundle 也对应了一个 broker。这样一个 topic 就始终由一个 broker 来代理。</p>
<p>正是由于以上的原因。所以推荐是使用分区 topic。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://pulsar.apache.org/docs/zh-CN/next/administration-load-balance/">官方doc：pulsar负载均衡</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/21/message%20queue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8Bkafka%20%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84Offset%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/21/message%20queue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8Bkafka%20%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84Offset%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">消息队列之kafka 消费者的Offset管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-21 09:30:37" itemprop="dateCreated datePublished" datetime="2021-01-21T09:30:37+08:00">2021-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-08 19:58:11" itemprop="dateModified" datetime="2023-02-08T19:58:11+08:00">2023-02-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Consumer通过提交Offset来记录当前消费的最后位置，以便于消费者发生崩溃或者有新的消费者加入消费者组，而引发的分区再均衡操作，每个消费者可能会分到不同的分区。我测试的kafka版本是：0.11.0.2，消费者往一个特殊的主题“_consumer_offset”发送消息</p>
<p>消息的内容包括：</p>
<table>
<thead>
<tr>
<th>fields</th>
<th>content</th>
</tr>
</thead>
<tbody><tr>
<td>Key</td>
<td>Consumer Group, topic, partition</td>
</tr>
<tr>
<td>Payload</td>
<td>Offset, metadata, timestamp</td>
</tr>
</tbody></table>
<h3 id="两种-offset-存储方式"><a href="#两种-offset-存储方式" class="headerlink" title="两种 offset 存储方式"></a>两种 offset 存储方式</h3><ul>
<li>特殊主题</li>
<li>zookeeper</li>
</ul>
<h2 id="kafka-api"><a href="#kafka-api" class="headerlink" title="kafka api"></a>kafka api</h2><p>如果是根据kafka默认的api来消费，即【org.apache.kafka.clients.consumer.KafkaConsumer】，我们会配置参【bootstrap.servers】来消费。而其消费者的offset会更新到一个kafka自带的topic【__consumer_offsets】下面，查看当前group的消费进度，则要依靠kafka自带的工具【kafka-consumer-offset-checker】</p>
<h3 id="特殊主题"><a href="#特殊主题" class="headerlink" title="特殊主题"></a>特殊主题</h3><h4 id="Offset-Commit"><a href="#Offset-Commit" class="headerlink" title="Offset Commit"></a>Offset Commit</h4><p>Offset的提交逻辑其实和普通的生产者往kafka发送数据是一样的。</p>
<h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>消费者启动时会为“_consumer_offset”主题创建一个内置的生产者，用于Offset数据的提交。</p>
<h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><p>Broker就是将Offset提交当成是正常的生产请求，逻辑不变。</p>
<p>“_consumer_offset”主题会在集群中的第一个Offset提交请求时被自动创建。</p>
<h3 id="Offset的提交方式"><a href="#Offset的提交方式" class="headerlink" title="Offset的提交方式"></a>Offset的提交方式</h3><p>Offset提交时会有两个问题：重复消费（消费者最少消费一次或者恰好消费一次）和漏消费（消费者最多消费一次）。</p>
<ul>
<li>当提交的Offset小于客户端处理的最后一条消息的Offset,会造成重复消费。 情景：先消费，后提交Offset,如果消费成功、提交失败，消费者下次获取的Offset还是以前的，所以会造成重复消费。</li>
<li>当提交的Offset大于客户端处理的最后一条消息的Offset,会造成漏消费。 情景：先提交Offset，后消费,如果提交成功、消费失败，消费者下次获取的Offset已经是新的，所以会造成漏消费。</li>
</ul>
<p>根据具体的业务情况，选择合适的提交方式，可以有效的解决掉重复消费和漏消费的问题。</p>
<h4 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h4><p>自动提交是最简单的提交方式，通过设置参数，可以开启自动提交也可以设置提交的时间间隔。缺点就是，当消费了一些数据后，还未达到自动的提交时间，这个时候，有新的消费者加入，或者当前消费者挂掉，会出现分区再均衡操作，之后消费者重新在上一次提交的Offset开始消费，造成重复消费。虽然可以缩短自动提交间隔，但是还是无法解决这个问题。</p>
<h4 id="同步提交当前Offset"><a href="#同步提交当前Offset" class="headerlink" title="同步提交当前Offset"></a>同步提交当前Offset</h4><p>关闭手动提交，可以通过同步提交接口来提交当前的Offset，虽然可以获取主动性，但是也牺牲了吞吐量，因为同步提交必然是阻塞的，而且会有重试机制。</p>
<h4 id="异步提交当前Offset"><a href="#异步提交当前Offset" class="headerlink" title="异步提交当前Offset"></a>异步提交当前Offset</h4><p>使用异步提交方式，既有主动性，也可以增加kafka消费的吞吐量，没有重试机制，也解决不掉重复消费的问题。</p>
<h4 id="同步和异步组合提交"><a href="#同步和异步组合提交" class="headerlink" title="同步和异步组合提交"></a>同步和异步组合提交</h4><p>正常使用的时候使用异步提交，速度快。当要关闭消费者的时候，使用同步提交，即使失败了也会一直重试，直到提交成功或者发生无法恢复的错误。不管是同步提交还是异步提交都避免不了重复消费和漏消费的问题。</p>
<h2 id="java-api"><a href="#java-api" class="headerlink" title="java api"></a>java api</h2><p>消费者如果是根据javaapi来消费，也就是【kafka.javaapi.consumer.ConsumerConnector】，我们会配置参数【zookeeper.connect】来消费。这种情况下，消费者的offset会更新到zookeeper的【consumers&#x2F;{group}&#x2F;offsets&#x2F;{topic}&#x2F;{partition}】目录下，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost(CONNECTED) 0] get /kafka/consumers/zoo-consumer-group/offsets/my-topic/0</span><br><span class="line">5662</span><br><span class="line">cZxid = 0x20006d28a</span><br><span class="line">ctime = Wed Apr 12 18:20:51 CST 2017</span><br><span class="line">mZxid = 0x30132b0ed</span><br><span class="line">mtime = Tue Aug 22 18:53:22 CST 2017</span><br><span class="line">pZxid = 0x20006d28a</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 5758</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 4</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904016212656141">https://juejin.cn/post/6844904016212656141</a></p>
<p><a target="_blank" rel="noopener" href="https://zqhxuyuan.github.io/2016/02/18/Kafka-Consumer-Offset-Manager/">https://zqhxuyuan.github.io/2016/02/18/Kafka-Consumer-Offset-Manager/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e6f535fdf2a4">https://www.jianshu.com/p/e6f535fdf2a4</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/15/learn/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/15/learn/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">微服务入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-15 19:40:19" itemprop="dateCreated datePublished" datetime="2021-01-15T19:40:19+08:00">2021-01-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><code>你有一个问题，你考虑用正则解决。那么，好的，你现在有两个问题了。</code></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/65502802">原文-知乎-微服务架构是什么</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>微服务就是职责较为单一的服务实现方式，区别于所有单体服务。</p>
<h2 id="微服务引入的问题"><a href="#微服务引入的问题" class="headerlink" title="微服务引入的问题"></a>微服务引入的问题</h2><p>微服务架构虽然逻辑设计上看是完美的，但就像积木搭建的华丽宫殿一样，经不起风吹草动。微服务架构虽然解决了旧问题，也引入了新的问题：</p>
<h3 id="定位问题困难"><a href="#定位问题困难" class="headerlink" title="定位问题困难"></a>定位问题困难</h3><p>微服务架构整个应用分散成多个服务，定位故障点非常困难。</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul>
<li>链路追踪, trace 技术。</li>
<li>日志收集。</li>
</ul>
<h3 id="稳定性下降"><a href="#稳定性下降" class="headerlink" title="稳定性下降"></a>稳定性下降</h3><p>稳定性下降。服务数量变多导致其中一个服务出现故障的概率增大，并且一个服务故障可能导致整个系统挂掉。事实上，在大访问量的生产场景下，故障总是会出现的。</p>
<h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><ul>
<li>服务自动重启</li>
<li>熔断机制</li>
<li>监控报警系统（防止问题发生）</li>
</ul>
<h3 id="部署管理难度很大"><a href="#部署管理难度很大" class="headerlink" title="部署管理难度很大"></a>部署管理难度很大</h3><p>服务数量非常多，部署、管理的工作量很大。</p>
<h4 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h4><ul>
<li>容器编排（k8s技术）</li>
</ul>
<h3 id="服务协作"><a href="#服务协作" class="headerlink" title="服务协作"></a>服务协作</h3><p>开发方面：如何保证各个服务在持续开发的情况下仍然保持协同合作。</p>
<h3 id="测试难度上升"><a href="#测试难度上升" class="headerlink" title="测试难度上升"></a>测试难度上升</h3><p>测试方面：服务拆分后，几乎所有功能都会涉及多个服务。原本单个程序的测试变为服务间调用的测试。测试变得更加复杂</p>
<h2 id="解决之道"><a href="#解决之道" class="headerlink" title="解决之道"></a>解决之道</h2><h3 id="解决问题的方法论"><a href="#解决问题的方法论" class="headerlink" title="解决问题的方法论"></a>解决问题的方法论</h3><p>对故障的处理一般从两方面入手，一方面尽量减少故障发生的概率，另一方面降低故障造成的影响。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/sOeSbV"><img src="https://s3.ax1x.com/2021/01/25/sOeSbV.png" alt="sOeSbV.png"></a></p>
<h3 id="监控-发现故障的征兆"><a href="#监控-发现故障的征兆" class="headerlink" title="监控 - 发现故障的征兆"></a>监控 - 发现故障的征兆</h3><p>然后小明采用Prometheus作为指标采集器，Grafana配置监控界面和邮件告警。这样一套微服务监控系统就搭建起来了：</p>
<h3 id="定位问题-链路跟踪"><a href="#定位问题-链路跟踪" class="headerlink" title="定位问题 - 链路跟踪"></a>定位问题 - 链路跟踪</h3><p>在微服务架构下，一个用户的请求往往涉及多个内部服务调用。为了方便定位问题，需要能够记录每个用户请求时，微服务内部产生了多少服务调用，及其调用关系。这个叫做链路跟踪。</p>
<p>链路跟踪只能定位到哪个服务出现问题，不能提供具体的错误信息。查找具体的错误信息的能力则需要由日志分析组件来提供。</p>
<h3 id="分析问题-日志分析（ELK）"><a href="#分析问题-日志分析（ELK）" class="headerlink" title="分析问题 - 日志分析（ELK）"></a>分析问题 - 日志分析（ELK）</h3><p>日志分析组件应该在微服务兴起之前就被广泛使用了。即使单体应用架构，当访问数变大、或服务器规模增多时，日志文件的大小会膨胀到难以用文本编辑器进行访问，更糟的是它们分散在多台服务器上面。排查一个问题，需要登录到各台服务器去获取日志文件，一个一个地查找（而且打开、查找都很慢）想要的日志信息。</p>
<p>因此，在应用规模变大时，我们需要一个日志的“<strong>搜索引擎</strong>”。以便于能准确的找到想要的日志。另外，数据源一侧还需要收集日志的组件和展示结果的UI组件：</p>
<h3 id="网关-权限控制，服务治理"><a href="#网关-权限控制，服务治理" class="headerlink" title="网关 - 权限控制，服务治理"></a>网关 - 权限控制，服务治理</h3><p>拆分成微服务后，出现大量的服务，大量的接口，使得整个调用关系乱糟糟的。经常在开发过程中，写着写着，忽然想不起某个数据应该调用哪个服务。或者写歪了，调用了不该调用的服务，本来一个只读的功能结果修改了数据……</p>
<h3 id="服务注册于发现-动态扩容-（k8s-or-etcd-watch）"><a href="#服务注册于发现-动态扩容-（k8s-or-etcd-watch）" class="headerlink" title="服务注册于发现 - 动态扩容 （k8s or etcd watch）"></a>服务注册于发现 - 动态扩容 （k8s or etcd watch）</h3><p>前面的组件，都是旨在降低故障发生的可能性。然而故障总是会发生的，所以另一个需要研究的是如何降低故障产生的影响。</p>
<p>最粗暴的（也是最常用的）故障处理策略就是冗余。一般来说，一个服务都会部署多个实例，这样一来能够分担压力提高性能，二来即使一个实例挂了其他实例还能响应。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/sOn8Bt"><img src="https://s3.ax1x.com/2021/01/25/sOn8Bt.png" alt="sOn8Bt.png"></a></p>
<p>首先，需要部署一个服务发现服务，它提供所有已注册服务的地址信息的服务。DNS也算是一种服务发现服务。然后各个应用服务在启动时自动将自己注册到服务发现服务上。<strong>并且应用服务启动后会实时（定期）从服务发现服务同步各个应用服务的地址列表到本地。</strong>服务发现服务也会定期检查应用服务的健康状态，去掉不健康的实例地址。这样新增实例时只需要部署新实例，实例下线时直接关停服务即可，服务发现会自动检查服务实例的增减。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/sXlTG6"><img src="https://s3.ax1x.com/2021/01/26/sXlTG6.png" alt="sXlTG6.png"></a></p>
<p>服务发现还会跟客户端负载均衡配合使用。由于应用服务已经同步服务地址列表在本地了，所以访问微服务时，可以自己决定负载策略。甚至可以在服务注册时加入一些元数据（服务版本等信息），客户端负载则根据这些元数据进行流量控制，实现A&#x2F;B测试、蓝绿发布等功能。</p>
<p>服务发现有很多组件可以选择，比如说Zookeeper 、Eureka、Consul、Etcd等。<strong>不过小明觉得自己水平不错，想炫技，于是基于Redis自己写了一个……</strong></p>
<h3 id="熔断、限流、服务降级"><a href="#熔断、限流、服务降级" class="headerlink" title="熔断、限流、服务降级"></a>熔断、限流、服务降级</h3><h4 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h4><p>当一个服务因为各种原因停止响应时，调用方通常会等待一段时间，然后超时或者收到错误返回。如果调用链路比较长，可能会导致请求堆积，整条链路占用大量资源一直在等待下游响应。所以当多次访问一个服务失败时，应熔断，标记该服务已停止工作，直接返回错误。直至该服务恢复正常后再重新建立连接。</p>
<h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><p>一个服务挂掉后，上游服务或者用户一般会习惯性地重试访问。这导致一旦服务恢复正常，很可能因为瞬间网络流量过大又立刻挂掉，在棺材里重复着仰卧起坐。因此服务需要能够自我保护——限流。限流策略有很多，最简单的比如当单位时间内请求数过多时，丢弃多余的请求。</p>
<h4 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h4><p>当下游服务停止工作后，如果该服务并非核心业务，则上游服务应该降级，以保证核心业务不中断。比如网上超市下单界面有一个推荐商品凑单的功能，当推荐模块挂了后，下单功能不能一起挂掉，只需要暂时关闭推荐功能即可。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>微服务架构下，测试分为三个层次：</p>
<ol>
<li>端到端测试：覆盖整个系统，一般在用户界面机型测试。</li>
<li>服务测试：针对服务接口进行测试。</li>
<li>单元测试：针对代码单元进行测试。</li>
</ol>
<h3 id="微服务框架"><a href="#微服务框架" class="headerlink" title="微服务框架"></a>微服务框架</h3><p>指标接口、链路跟踪注入、日志引流、服务注册发现、路由规则等组件以及熔断、限流等功能都需要在应用服务上添加一些对接代码。如果让每个应用服务自己实现是非常耗时耗力的。基于DRY的原则，小明开发了一套微服务框架，将与各个组件对接的代码和另外一些公共代码抽离到框架中，所有的应用服务都统一使用这套框架进行开发。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/65502802">原文-知乎-微服务架构是什么</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/10/algorithm/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/10/algorithm/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" class="post-title-link" itemprop="url">算法之滑动窗口</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-10 15:32:58" itemprop="dateCreated datePublished" datetime="2021-01-10T15:32:58+08:00">2021-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="什么是滑动窗口算法"><a href="#什么是滑动窗口算法" class="headerlink" title="什么是滑动窗口算法"></a>什么是滑动窗口算法</h2><h3 id="固定窗口"><a href="#固定窗口" class="headerlink" title="固定窗口"></a>固定窗口</h3><p>固定窗口就像是滑动窗口的一个特例，固定窗口是大小固定且不能随着时间而变化的。</p>
<p>在限流算法里：使用固定窗口算法是一种暴力的方式，可以通过限制某个API在在一个时间片内访问的次数；</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>滑动窗口将固定窗口再等分为多个小的窗口。</p>
<p>在限流算法里：假设我们将1s划分为4个窗口，则每个窗口对应250ms。假设恶意用户还是在上一秒的最后一刻和下一秒的第一刻冲击服务，按照滑动窗口的原理，此时统计上一秒的最后750毫秒和下一秒的前250毫秒，这种方式能够判断出用户的访问依旧超过了1s的访问数量，因此依然会阻拦用户的访问。</p>
<p>滑动窗口具有以下特点：</p>
<p>1、每个小窗口的大小可以均等，dubbo的默认负载均衡算法random就是通过滑动窗口设计的，可以调整每个每个窗口的大小，进行负载。<br> 2、滑动窗口的个数及大小可以根据实际应用进行控制</p>
<h2 id="滑动时间窗口"><a href="#滑动时间窗口" class="headerlink" title="滑动时间窗口"></a>滑动时间窗口</h2><p>滑动时间窗口就是把一段时间片分为多个窗口，然后计算对应的时间落在那个窗口上，来对数据统计；如上图其实就是即时的滑动时间窗口，<strong>随着时间流失，最开始的窗口将会失效，但是也会生成新的窗口</strong>；sentinel的就是通过这个原理来实时的限流数据统计。</p>
<h2 id="go-zero-滑动时间窗口"><a href="#go-zero-滑动时间窗口" class="headerlink" title="go-zero 滑动时间窗口"></a>go-zero 滑动时间窗口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RollingWindow <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock          sync.RWMutex</span><br><span class="line">	size          <span class="type">int</span> <span class="comment">// 有多少个小窗口</span></span><br><span class="line">	window        *window</span><br><span class="line">	interval      time.Duration <span class="comment">// 每个窗口的时间大小，例如 100 ms，表示一个小窗口记录 100ms 内的计数</span></span><br><span class="line">	offset        <span class="type">int</span>           <span class="comment">// offset 表示当前应该更新或者读取哪个 bucket</span></span><br><span class="line">	ignoreCurrent <span class="type">bool</span></span><br><span class="line">	lastTime      time.Duration <span class="comment">// start time of the last bucket</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add adds value to current bucket.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RollingWindow)</span></span> Add(v <span class="type">float64</span>) &#123;</span><br><span class="line">	rw.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rw.lock.Unlock()</span><br><span class="line">	<span class="comment">// 确定当前应该是哪个小窗口（offset）， 顺便更新最近一次访问时间，方便下次计算 span</span></span><br><span class="line">	rw.updateOffset()</span><br><span class="line">	<span class="comment">// 在这个小窗口计数</span></span><br><span class="line">	rw.window.add(rw.offset, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reduce runs fn on all buckets, ignore current bucket if ignoreCurrent was set.</span></span><br><span class="line"><span class="comment">// 注意 golang 的函数式编程，求和实际上是调用放传入 fn</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RollingWindow)</span></span> Reduce(fn <span class="function"><span class="keyword">func</span><span class="params">(b *Bucket)</span></span>) &#123;</span><br><span class="line">	rw.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> rw.lock.RUnlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> diff <span class="type">int</span></span><br><span class="line">	span := rw.span()</span><br><span class="line">	<span class="comment">// ignore current bucket, because of partial data</span></span><br><span class="line">	<span class="comment">// diff 实际上是 rw.size -1 or rw.size - span</span></span><br><span class="line">	<span class="keyword">if</span> span == <span class="number">0</span> &amp;&amp; rw.ignoreCurrent &#123;</span><br><span class="line">		diff = rw.size - <span class="number">1</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		diff = rw.size - span</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> diff &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 计算当前 offset 下标</span></span><br><span class="line">		offset := (rw.offset + span + <span class="number">1</span>) % rw.size</span><br><span class="line">		rw.window.reduce(offset, diff, fn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 从 start 开始 count 个 bucket</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *window)</span></span> reduce(start, count <span class="type">int</span>, fn <span class="function"><span class="keyword">func</span><span class="params">(b *Bucket)</span></span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;</span><br><span class="line">		fn(w.buckets[(start+i)%w.size])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/05677381e155">Sentinel之滑动时间窗口设计</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/07/algorithm/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/07/algorithm/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/" class="post-title-link" itemprop="url">算法之微服务降级</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-07 20:53:33" itemprop="dateCreated datePublished" datetime="2021-01-07T20:53:33+08:00">2021-01-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>个人倾向于， 熔断，限流，隔离，都是一种降级的策略。</p>
<h3 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h3><p><strong>客户端行为</strong>（调用方行为）， 调用方统计一段时间调用失败的次数和总的请求次数，当调用失败达到一定比例时，熔断器打开，直接不调用，返回一个默认的错误。</p>
<h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p><strong>服务端行为</strong>（被调用方行为）， 被调用方统计一段时间内的请求数（也可以是其他指标，例如字节数）， 当一段时间内请求数超过阈值时，返回一个限流的错误。</p>
<h3 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h3><p><strong>客户端行为</strong>（调用方行为）， 调用方为某一类调用初始化固定大小的资源，防止因这种调用出错而导致占用大量的资源。比如我们现在某个接口所在的服务A需要调用服务B，而服务B同时需要调用C服务，此时服务C突然宕机同时此时流量暴涨，调用全部打到服务B上，此时B服务调用C超时大量的线程资源被该接口所占全部hang住，<strong>慢慢服务B中的线程数量则会持续增加直致CPU资源耗尽到100%<strong>，整个服务对外不可用渐渐蔓延到B服务集群中的其他节点，</strong>导致服务级联故障</strong>。</p>
<h4 id="服务级联故障"><a href="#服务级联故障" class="headerlink" title="服务级联故障"></a>服务级联故障</h4><p>当上游服务依赖的下游服务出现故障后，上游服务由于没有做好资源隔离和快速错误等，导致因为下游服务出错，引发上游服务出错，并产生连锁的故障的情况。</p>
<h4 id="线程池隔离"><a href="#线程池隔离" class="headerlink" title="线程池隔离"></a>线程池隔离</h4><p>线程池隔离顾名思义就是通过Java的线程池进行隔离，B服务调用C服务给予固定的线程数量比如10个线程，如果此时C服务宕机了就算大量的请求过来，调用C服务的接口只会占用10个线程不会占用其他工作线程资源，因此B服务就不会出现级联故障。</p>
<p><strong>隔离这种思想本质上是规定一类接口只能使用固定配额的资源，这能有效避免单个接口的异常导致的整体异常。例如k8s中限制一个pod使用内存大小也是同样的道理。</strong></p>
<h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>当整个微服务架构整体的负载超出了预设的上限阈值或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，我们可以将一些 <strong>不重要</strong> 或 <strong>不紧急</strong> 的服务或任务进行服务的 <strong>延迟使用</strong> 或 <strong>暂停使用</strong>。</p>
<ul>
<li>如限制流量上限</li>
<li>如限制事务上限</li>
<li>如限制cpu，内存，磁盘上线</li>
<li>如限制某种功能</li>
<li>如限制某一个群体的用户</li>
</ul>
<h4 id="限制-cpu-使用率"><a href="#限制-cpu-使用率" class="headerlink" title="限制 cpu 使用率"></a>限制 cpu 使用率</h4><p>每个节点定时计算cpu的使用率，计算CPU负载时使用滑动平均来降低CPU负载抖动带来的不稳定。</p>
<p>每次请求到来，检查cpu使用率，如果cpu使用率超过阈值，那么将当前请求直接扔掉。</p>
<h2 id="Java-中的-Hystrix"><a href="#Java-中的-Hystrix" class="headerlink" title="Java 中的 Hystrix"></a>Java 中的 Hystrix</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>分布式系统环境下，服务间类似依赖非常常见，一个业务调用通常依赖多个基础服务。如下图，对于同步调用，<strong>当库存服务不可用时，商品服务请求线程被阻塞，当有大批量请求调用库存服务时，最终可能导致整个商品服务资源耗尽，无法继续对外提供服务。</strong>并且这种不可用可能沿请求调用链向上传递，这种现象被称为雪崩效应。</p>
<h3 id="雪崩效应常见场景"><a href="#雪崩效应常见场景" class="headerlink" title="雪崩效应常见场景"></a>雪崩效应常见场景</h3><ul>
<li>硬件故障：如服务器宕机，机房断电，光纤被挖断等。</li>
<li>流量激增：如异常流量，重试加大流量等。</li>
<li>缓存失效：一般发生在应用重启，所有缓存失效时，以及短时间内大量缓存失效时。大量的缓存不命中，使请求直击后端服务，造成服务提供者超负荷运行，引起服务不可用。</li>
<li>程序BUG：如程序逻辑导致内存泄漏，JVM长时间FullGC等。</li>
<li>同步等待：服务间采用同步调用模式，同步等待造成的资源耗尽。</li>
</ul>
<h3 id="雪崩效应应对策略"><a href="#雪崩效应应对策略" class="headerlink" title="雪崩效应应对策略"></a>雪崩效应应对策略</h3><p>针对造成雪崩效应的不同场景，可以使用不同的应对策略，没有一种通用所有场景的策略，参考如下：</p>
<ul>
<li>硬件故障：多机房容灾、异地多活等。</li>
<li>流量激增：服务自动扩容、流量控制（限流、关闭重试）等。</li>
<li>缓存穿透：缓存预加载、缓存异步加载等。</li>
<li>程序BUG：修改程序bug、及时释放资源等。</li>
<li>同步等待：资源隔离、MQ解耦、不可用服务调用快速失败等。<strong>资源隔离通常指不同服务调用采用不同的线程池；不可用服务调用快速失败一般通过熔断器模式结合超时机制实现。</strong></li>
</ul>
<h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><p>Hystrix如何实现这些设计目标？</p>
<ul>
<li>使用命令模式将所有对外部服务（或依赖关系）的调用包装在HystrixCommand或HystrixObservableCommand对象中，并将该对象放在单独的线程中执行；</li>
<li>每个依赖都维护着一个线程池（或信号量），线程池被耗尽则拒绝请求（而不是让请求排队）。<strong>多个依赖的隔离，限流器</strong></li>
<li>记录请求成功，失败，超时和线程拒绝。</li>
<li>服务错误百分比超过了阈值，熔断器开关自动打开，一段时间内停止对该服务的所有请求。<strong>熔断器</strong></li>
<li>请求失败，被拒绝，超时或熔断时执行降级逻辑。</li>
<li>近实时地监控指标和配置的修改。</li>
</ul>
<h4 id="Hystrix设计思想来源"><a href="#Hystrix设计思想来源" class="headerlink" title="Hystrix设计思想来源!!!"></a>Hystrix设计思想来源!!!</h4><h5 id="舱壁隔离模式"><a href="#舱壁隔离模式" class="headerlink" title="舱壁隔离模式"></a>舱壁隔离模式</h5><p>货船为了进行防止漏水和火灾的扩散,会将货仓分隔为多个，当发生灾害时，将所在货仓进行隔离就可以降低整艘船的风险。</p>
<h5 id="断路器模式"><a href="#断路器模式" class="headerlink" title="断路器模式"></a>断路器模式</h5><p>熔断器就像家里的保险丝，当电流过载了就会跳闸，不过Hystrix的熔断机制相对复杂一些。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020791119">微服务容错 - 隔离熔断限流</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c1c0d8305fb4">学习分布式系统限流、降级、熔断框架就要看这篇文章</a></p>
<p><a target="_blank" rel="noopener" href="https://my.oschina.net/7001/blog/1619842">Hystrix原理与实战（文章略长）</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903830899933198">微服务容错限流Hystrix入门</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/cgjCL59e3CDWhsxzwkuKBg">服务自适应降载保护设计， 实际上是Sentinel自适应限流的简单golang实现</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/26/http/http%E4%B9%8Bhttps%E6%8F%A1%E6%89%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/26/http/http%E4%B9%8Bhttps%E6%8F%A1%E6%89%8B/" class="post-title-link" itemprop="url">http之https握手</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-26 10:02:37" itemprop="dateCreated datePublished" datetime="2020-12-26T10:02:37+08:00">2020-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index"><span itemprop="name">http</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="https-握手过程"><a href="#https-握手过程" class="headerlink" title="https 握手过程"></a>https 握手过程</h2><p>假定客户端叫做爱丽丝，服务器叫做鲍勃。</p>
<ul>
<li>爱丽丝给出协议版本号、一个客户端生成的 随机数（Client random），以及客户端支持的加密方法。</li>
<li>鲍勃确认双方使用的加密方法，并给出数字证书、以及一个 服务器生成的随机数（Server random）。</li>
<li>爱丽丝确认数字证书有效，然后生成一个新的 随机数（Premaster secret），并使用数字证书中鲍勃的公钥，加密这个随机数，发给鲍勃。</li>
<li>鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。</li>
<li>爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成 对话密钥（session key），用来加密接下来的整个对话过程。</li>
</ul>
<p><strong>三点注意</strong></p>
<ul>
<li>生成对话密钥一共需要三个随机数。</li>
<li>握手之后的对话使用 对话密钥（session key） 加密（对称加密），服务器的公钥和私钥只用于加密和解密 对话密钥（session key）（非对称加密），无其他作用。</li>
<li>服务器公钥放在服务器的数字证书之中。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rhrf91"><img src="https://s3.ax1x.com/2020/12/26/rhrf91.png" alt="rhrf91.png"></a></p>
<h2 id="tsl"><a href="#tsl" class="headerlink" title="tsl"></a>tsl</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021559557?_ea=29659396">https://segmentfault.com/a/1190000021559557?_ea=29659396</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Percy"
      src="https://ivalue2333.github.io/percy/images/percy.jpg">
  <p class="site-author-name" itemprop="name">Percy</p>
  <div class="site-description" itemprop="description">IOT2014</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">156</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">194</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Percy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
