<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="IOT2014">
<meta property="og:type" content="website">
<meta property="og:title" content="blog | percy">
<meta property="og:url" content="http://example.com/page/8/index.html">
<meta property="og:site_name" content="blog | percy">
<meta property="og:description" content="IOT2014">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Percy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>blog | percy</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blog | percy</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/31/http/tcp%E4%B9%8B%E8%BF%9E%E6%8E%A5%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/31/http/tcp%E4%B9%8B%E8%BF%9E%E6%8E%A5%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">tcp之连接优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-31 17:20:19" itemprop="dateCreated datePublished" datetime="2020-10-31T17:20:19+08:00">2020-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul>
<li>RTT（从客户端到服务器一个往返的时间），Round-trip time</li>
<li>MSL 是Maximum Segment Lifetime， 最大报文生存时间， 任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</li>
<li>TTL是 Time To Live的缩写，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。</li>
</ul>
<h2 id="TCP-三次握手的性能提升"><a href="#TCP-三次握手的性能提升" class="headerlink" title="TCP 三次握手的性能提升"></a>TCP 三次握手的性能提升</h2><p>linux 在握手过程中 会维护两个队列</p>
<ol>
<li>一个存放 SYN 的队列（半连接队列）</li>
<li>一个存放已经完成连接的队列（全连接队列）</li>
</ol>
<h3 id="优化方案总结"><a href="#优化方案总结" class="headerlink" title="优化方案总结"></a>优化方案总结</h3><h4 id="客户端优化"><a href="#客户端优化" class="headerlink" title="客户端优化"></a>客户端优化</h4><ul>
<li>当客户端发起 SYN 包时，可以通过 tcp_syn_retries 控制其重传的次数。</li>
</ul>
<h4 id="服务端优化"><a href="#服务端优化" class="headerlink" title="服务端优化"></a>服务端优化</h4><ul>
<li>增大 tcp_max_syn_backlog </li>
<li>开启 syncookies 功能<ul>
<li>服务端回复 SYN+ACK 的重传次数由 <code>tcp_synack_retries</code> 参数控制。如果遭受 SYN 攻击，应把 <code>tcp_syncookies</code> 参数设置为 1，表示仅在 SYN 队列满后开启 syncookie 功能，可以保证正常的连接成功建立。</li>
</ul>
</li>
<li>调整 accept 队列长度</li>
<li>TCP Fast Open 功能可以绕过三次握手，使得 HTTP 请求减少了 1 个 RTT 的时间，Linux 下可以通过 <code>tcp_fastopen</code> 开启该功能，同时必须保证服务端和客户端同时支持。</li>
</ul>
<h3 id="服务端优化-amp-amp-半连接队列"><a href="#服务端优化-amp-amp-半连接队列" class="headerlink" title="服务端优化 &amp;&amp; 半连接队列"></a>服务端优化 &amp;&amp; 半连接队列</h3><p>当服务端收到 SYN 包后，服务端会立马回复 SYN+ACK 包。服务端此时的状态是 <code>SYN_RCV</code>。在这个状态下，Linux 内核就会建立一个「半连接队列」来维护「未完成」的握手信息，当半连接队列溢出后，服务端就无法再建立新的连接。</p>
<h4 id="半连接队列"><a href="#半连接队列" class="headerlink" title="半连接队列"></a>半连接队列</h4><p>SYN 攻击，攻击的是就是这个半连接队列。那么如果出现 SYN 攻击时或者其他情况，需要查看半连接队列已满导致的连接失败的情况时，或者优化时，如何操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 如何查看由于 SYN 半连接队列已满，而被丢弃连接的情况</span></span><br><span class="line">netstat -s | grep <span class="string">&quot;SYNs to LISTEN&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 70 SYNs to LISTEN sockets dropped</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面输出的数值是累计值，表示共有多少个 TCP 连接因为半连接队列溢出而被丢弃。隔几秒执行几次，如果有上升的趋势，说明当前存在半连接队列溢出的现象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 如何调整 SYN 半连接队列大小？</span></span><br><span class="line"><span class="comment"># 要想增大半连接队列，不能只单纯增大 tcp_max_syn_backlog 的值，还需一同增大 somaxconn 和 backlog，也就是增大 accept 队列。否则，只单纯增大 tcp_max_syn_backlog 是无效的。</span></span><br></pre></td></tr></table></figure>

<h5 id="关于-backlog-和-somaxconn"><a href="#关于-backlog-和-somaxconn" class="headerlink" title="关于 backlog 和 somaxconn"></a>关于 backlog 和 somaxconn</h5><p>对于 Linux 而言，基本上任意语言实现的通信框架或服务器程序在构造 socket server 时，都提供了 backlog 这个参数，因为在监听端口时，都会调用系统底层 API: int listen(int sockfd, int backlog);</p>
<h6 id="全连接队列长度如何计算？"><a href="#全连接队列长度如何计算？" class="headerlink" title="全连接队列长度如何计算？"></a>全连接队列长度如何计算？</h6><p>如果 backlog 大于内核参数 net.core.somaxconn，则以 net.core.somaxconn 为准，即全连接队列长度 &#x3D; min(backlog, 内核参数 net.core.somaxconn)，net.core.somaxconn 默认为 128。这个很好理解，net.core.somaxconn 定义了系统级别的全连接队列最大长度，backlog 只是应用层传入的参数，不可能超过内核参数，所以 backlog 必须小于等于 net.core.somaxconn。</p>
<p>其实，对于 Nginx&#x2F;Tomcat 等这种 Web 服务器，都提供了 backlog 参数设置入口，当然它们都会有默认值，通常这个默认值都不会太大（包括内核默认的半连接队列和全连接队列长度）。</p>
<h6 id="如何查看服务端进程-accept-队列的长度？"><a href="#如何查看服务端进程-accept-队列的长度？" class="headerlink" title="如何查看服务端进程 accept 队列的长度？"></a>如何查看服务端进程 accept 队列的长度？</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -ltn</span><br></pre></td></tr></table></figure>

<ul>
<li>Recv-Q：当前 accept 队列的大小，也就是当前已完成三次握手并等待服务端 <code>accept()</code> 的 TCP 连接；</li>
<li>Send-Q：accept 队列最大长度，上面的输出结果说明监听 8088 端口的 TCP 服务，accept 队列的最大长度为 128；</li>
</ul>
<h6 id="如何查看由于-accept-连接队列已满，而被丢弃的连接？"><a href="#如何查看由于-accept-连接队列已满，而被丢弃的连接？" class="headerlink" title="如何查看由于 accept 连接队列已满，而被丢弃的连接？"></a>如何查看由于 accept 连接队列已满，而被丢弃的连接？</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -s | grep overflowed</span><br><span class="line">   70 <span class="built_in">times</span> the listen queue of a socket overflowed</span><br></pre></td></tr></table></figure>

<p>上面看到的 70 times ，表示 accept 队列溢出的次数，注意这个是累计值。可以隔几秒钟执行下，如果这个数字一直在增加的话，说明 accept 连接队列偶尔满了。</p>
<p>如果持续不断地有连接因为 accept 队列溢出被丢弃，就应该调大 backlog 以及 somaxconn 参数。</p>
<h5 id="关于-tcp-max-syn-backlog"><a href="#关于-tcp-max-syn-backlog" class="headerlink" title="关于 tcp_max_syn_backlog"></a>关于 tcp_max_syn_backlog</h5><p>半连接队列的最大长度为以下三个参数 backlog、内核参数 net.core.somaxconn、内核参数 tcp_max_syn_backlog 的最小值。即半连接队列长度 &#x3D; min(backlog, 内核参数 net.core.somaxconn，内核参数 tcp_max_syn_backlog)。这个公式实际上规定半连接队列长度不能超过全连接队列长度。</p>
<p><img src="https://pic3.zhimg.com/v2-351442fbc23ab0af4980141cf140001a_r.jpg"></p>
<h4 id="syncookies-功能"><a href="#syncookies-功能" class="headerlink" title="syncookies 功能"></a>syncookies 功能</h4><p>syncookies 的工作原理：服务器根据当前状态计算出一个值，放在己方发出的 SYN+ACK 报文中发出，当客户端返回 ACK 报文时，取出该值验证，如果合法，就认为连接建立成功，如下图所示。</p>
<h3 id="服务端优化-amp-amp-TCP-Fast-Open"><a href="#服务端优化-amp-amp-TCP-Fast-Open" class="headerlink" title="服务端优化 &amp;&amp; TCP Fast Open"></a>服务端优化 &amp;&amp; TCP Fast Open</h3><p>略</p>
<h2 id="TCP-四次挥手的性能提升"><a href="#TCP-四次挥手的性能提升" class="headerlink" title="TCP 四次挥手的性能提升"></a>TCP 四次挥手的性能提升</h2><p>安全关闭连接的方式必须通过四次挥手，它由进程调用 <code>close</code> 和 <code>shutdown</code> 函数发起 FIN 报文（shutdown 参数须传入 SHUT_WR 或者 SHUT_RDWR 才会发送 FIN）。</p>
<p>调用了 close 函数意味着完全断开连接，<strong>完全断开不仅指无法传输数据，而且也不能发送数据。 此时，调用了 close 函数的一方的连接叫做「孤儿连接」，如果你用 netstat -p 命令，会发现连接对应的进程名为空。</strong></p>
<p>使用 close 函数关闭连接是不优雅的。于是，就出现了一种优雅关闭连接的 <code>shutdown</code> 函数，<strong>它可以控制只关闭一个方向的连接</strong>：</p>
<h3 id="优化方案总结-1"><a href="#优化方案总结-1" class="headerlink" title="优化方案总结"></a>优化方案总结</h3><h4 id="主动方"><a href="#主动方" class="headerlink" title="主动方"></a>主动方</h4><ul>
<li>调整 Fin 报文重传次数<ul>
<li>主动发起 FIN 报文断开连接的一方，如果迟迟没收到对方的 ACK 回复，则会重传 FIN 报文，重传的次数由 <code>tcp_orphan_retries</code> 参数决定。</li>
</ul>
</li>
<li>调整 time_wait 状态的个数上线<ul>
<li>当主动方接收到 FIN 报文，并返回 ACK 后，主动方的连接进入 TIME_WAIT 状态。这一状态会持续 1 分钟，为了防止 TIME_WAIT 状态占用太多的资源，<code>tcp_max_tw_buckets</code> 定义了最大数量，超过时连接也会直接释放。</li>
</ul>
</li>
<li>复用time_wait 状态的连接<ul>
<li>当 TIME_WAIT 状态过多时，还可以通过设置 <code>tcp_tw_reuse</code> 和 <code>tcp_timestamps</code> 为 1 ，将 TIME_WAIT 状态的端口复用于作为客户端的新连接，注意该参数只适用于客户端。</li>
</ul>
</li>
</ul>
<h4 id="被动方"><a href="#被动方" class="headerlink" title="被动方"></a>被动方</h4><h2 id="TCP-传输数据的性能提升"><a href="#TCP-传输数据的性能提升" class="headerlink" title="TCP 传输数据的性能提升"></a>TCP 传输数据的性能提升</h2><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是滑动窗口的由来。</p>
<p><strong>接收方根据它的缓冲区，可以计算出后续能够接收多少字节的报文，这个数字叫做接收窗口。</strong>当内核接收到报文时，必须用缓冲区存放它们，这样剩余缓冲区空间变小，接收窗口也就变小了；当进程调用 read 函数后，数据被读入了用户空间，内核缓冲区就被清空，这意味着主机可以接收更多的报文，接收窗口就会变大。</p>
<p>因此，接收窗口并不是恒定不变的，接收方会把当前可接收的大小放在 TCP 报文头部中的<strong>窗口字段</strong>，这样就可以起到窗口大小通知的作用。</p>
<p>发送方的窗口等价于接收方的窗口吗？如果不考虑拥塞控制，发送方的窗口大小「约等于」接收方的窗口大小，因为窗口通知报文在网络传输是存在时延的，所以是约等于的关系。</p>
<p>这样看来，只要进程能及时地调用 read 函数读取数据，并且接收缓冲区配置得足够大，那么接收窗口就可以无限地放大，发送方也就无限地提升发送速度。</p>
<p><strong>这是不可能的，因为网络的传输能力是有限的，当发送方依据发送窗口，发送超过网络处理能力的报文时，路由器会直接丢弃这些报文。因此，缓冲区的内存并不是越大越好。</strong></p>
<h3 id="带宽时延积"><a href="#带宽时延积" class="headerlink" title="带宽时延积"></a>带宽时延积</h3><p>比如最大带宽是 100 MB&#x2F;s，网络时延（RTT）是 10ms 时，意味着客户端到服务端的网络一共可以存放 100MB&#x2F;s * 0.01s &#x3D; 1MB 的字节。</p>
<p>这个 1MB 是带宽和时延的乘积，所以它就叫「带宽时延积」（缩写为 BDP，Bandwidth Delay Product）。同时，这 1MB 也表示「飞行中」的 TCP 报文大小，它们就在网络线路、路由器等网络设备上。如果飞行报文超过了 1 MB，就会导致网络过载，容易丢包。</p>
<h3 id="发送缓冲区与带宽时延积的关系"><a href="#发送缓冲区与带宽时延积的关系" class="headerlink" title="发送缓冲区与带宽时延积的关系"></a>发送缓冲区与带宽时延积的关系</h3><ul>
<li>如果发送缓冲区「超过」带宽时延积，超出的部分就没办法有效的网络传输，同时导致网络过载，容易丢包；</li>
<li>如果发送缓冲区「小于」带宽时延积，就不能很好的发挥出网络的传输效率。</li>
</ul>
<p>所以，发送缓冲区的大小最好是往带宽时延积靠近。</p>
<h3 id="缓冲区的数值"><a href="#缓冲区的数值" class="headerlink" title="缓冲区的数值"></a>缓冲区的数值</h3><p><strong>发送缓冲区是自行调节的</strong>，当发送方发送的数据被确认后，并且没有新的数据要发送，就会把发送缓冲区的内存释放掉。</p>
<p><strong>接收缓冲区可以根据系统空闲内存的大小来调节接收窗口：</strong></p>
<ul>
<li>如果系统的空闲内存很多，就可以自动把缓冲区增大一些，这样传给对方的接收窗口也会变大，因而提升发送方发送的传输数据数量；</li>
<li>反之，如果系统的内存很紧张，就会减少缓冲区，这虽然会降低传输效率，可以保证更多的并发连接正常工作；</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/146752547">原文-深度好文</a></p>
<p> <a target="_blank" rel="noopener" href="https://jaminzhang.github.io/linux/understand-Linux-backlog-and-somaxconn-kernel-arguments/">linux内核参数</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/30/algorithm/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8FID-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/30/algorithm/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8FID-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">算法之分布式ID-雪花算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-30 14:33:37" itemprop="dateCreated datePublished" datetime="2020-10-30T14:33:37+08:00">2020-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="分布式ID的特点"><a href="#分布式ID的特点" class="headerlink" title="分布式ID的特点"></a>分布式ID的特点</h2><ul>
<li>全局唯一性<ul>
<li>不能出现有重复的ID标识，这是基本要求。</li>
</ul>
</li>
<li>递增性<ul>
<li>确保生成ID对于用户或业务是递增的。</li>
</ul>
</li>
<li>高可用性<ul>
<li>确保任何时候都能生成正确的ID。</li>
</ul>
</li>
<li>高性能性<ul>
<li>在高并发的环境下依然表现良好。</li>
</ul>
</li>
</ul>
<h2 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h2><p><img src="https://s3.ax1x.com/2020/11/30/DRTYp6.jpg"></p>
<p><strong>1.第一位</strong> 占用1bit，其值始终是0，没有实际作用。</p>
<p> <strong>2.时间戳</strong> 占用41bit，精确到毫秒，总共可以容纳约69年的时间。</p>
<p> <strong>3.工作机器id</strong> 占用10bit，其中高位5bit是数据中心ID，低位5bit是工作节点ID，做多可以容纳1024个节点。</p>
<p> <strong>4.序列号</strong> 占用12bit，每个节点每毫秒0开始不断累加，最多可以累加到4095，一共可以产生4096个ID。</p>
<p>每个节点每毫秒可以产生 4096 个 ID， 最多支持 1024 个节点，所以，极限是每毫秒产生 400 w 个 ID。</p>
<h3 id="组成部分（64bit）"><a href="#组成部分（64bit）" class="headerlink" title="组成部分（64bit）"></a>组成部分（64bit）</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/85837641">分布式ID神器之雪花算法简介</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/30/algorithm/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81-%E8%BF%9E%E7%BB%AD%E6%BC%8F%E6%96%97%E6%A1%B6%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/30/algorithm/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81-%E8%BF%9E%E7%BB%AD%E6%BC%8F%E6%96%97%E6%A1%B6%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">算法之微服务限流-连续漏斗桶算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-30 14:33:37" itemprop="dateCreated datePublished" datetime="2020-10-30T14:33:37+08:00">2020-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>在开发高并发系统时有三把利器用来保护系统：<strong>缓存、降级和限流</strong></p>
<ul>
<li><strong>缓存</strong>：缓存的目的是提升系统访问速度和增大系统处理容量</li>
<li><strong>降级</strong>：降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行</li>
<li><strong>限流</strong>：限流的目的是通过对并发访问&#x2F;请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理</li>
</ul>
<h2 id="漏斗桶概览"><a href="#漏斗桶概览" class="headerlink" title="漏斗桶概览"></a>漏斗桶概览</h2><p>文献中描述了两种不同的应用漏斗类比的方法。[1] [2] [3] [4]这些给出了似乎是两种不同的算法，这两种算法都称为漏斗算法，通常不参考其他方法。这导致了关于漏桶算法是什么及其性质的困惑。</p>
<p>在其中一种类比的实现中，存储桶的类比是计数器或变量，与流量或事件调度分开。[1] [3] [4]此计数器仅用于检查流量或事件是否符合限制：<strong>当每个数据包到达进行检查或发生事件的点时，该计数器就会递增，这等效于间歇地向其中添加水的方式桶。计数器也以固定的速率递减，这与水从水桶漏出的方式相同。</strong>结果，计数器中的值代表类似桶中的水位。如果在数据包到达时或事件发生时计数器保持在指定的限值以下，即存储桶未溢出，则表明其符合带宽和突发性限值或平均和峰值速率事件限值。因此，在此版本中，水的类似物由数据包或事件携带，在到达或发生时添加到水桶中，然后泄漏出去。此版本在这里称为漏斗式计量表。</p>
<p>在第二个版本中，桶的类似物是交通流中的一个队列。[2]此队列用于直接控制流量：数据包到达时将其输入到队列中，相当于将水添加到桶中。然后通常以固定的速率，例如从队列中将这些分组从队列中删除（先到先服务）。向前传输，相当于水从桶中漏出。结果，为队列提供服务的速率直接控制流量的向前传输速率。因此，<strong>它强加一致性而不是检查一致性</strong>，并且在以固定速率为队列提供服务的情况下（以及数据包的长度均相同），所得到的流量必然没有突发性或抖动。因此，在此版本中，流量本身就是流过水桶的水的类似物。目前尚不清楚这种应用类比的版本如何用于检查离散事件的发生率。此版本在此处称为泄漏存储桶作为队列。</p>
<p>作为仪表的泄漏桶与令牌桶算法完全相同（即镜像），即，向泄漏桶加水的过程恰好反映了在合格数据包到达时从令牌桶中删除令牌的过程，即从漏水桶漏水完全反映了定期向令牌桶中添加令牌的过程，漏水桶不会溢出的测试也反映了令牌桶包含足够的令牌并且不会“下溢”的测试。因此，在给定等效参数的情况下，这两种算法将看到相同的流量，即符合或不符合。可以将漏斗作为队列视为漏斗作为仪表的特例。[6]</p>
<h2 id="AS-A-METER"><a href="#AS-A-METER" class="headerlink" title="AS A METER"></a>AS A METER</h2><p>乔纳森·S·特纳（Jonathan S. Turner）对漏斗算法的原始描述有功劳[7]，其描述如下：“与每个在连接上传输的用户相关的计数器，每当用户发送一个数据包时就增加，并周期性地减少。 计数器增加后超过阈值，网络将丢弃该数据包。用户指定计数器减少的速率（这确定平均带宽）和阈值（突发性的度量）”。[1] 在这种情况下，存储桶（类似于计数器）被用作计量器来测试数据包的一致性，而不是用作直接控制数据包的队列。</p>
<p>ITU-T在建议I.371和ATM论坛的UNI规范中给出了对该算法的本质上相同的仪表版本（通用信元速率算法）的另一种描述。[3] [4] ITU-T给出了以下描述，其中术语“单元”等效于特纳描述[1]中的数据包：“<strong>连续状态泄漏桶可以看作是一个容量有限的桶，其实际值内容会以每个时间单位1个单位的内容的连续速率耗尽，并且每个合格单元格的内容以增量T递增…如果在单元格到达时，存储桶的内容小于或等于极限值τ，则[4]该单元格是合格的；否则，该单元格是不合格的。</strong>存储桶的容量（计数器的上限）为（T +τ）“。[4]这些规范还指出，由于其有限的容量，如果在测试一致性时漏斗的内容物大于极限值，并且因此单元格不合格，则漏斗保持不变；否则，漏斗将保持不变。也就是说，如果会使水桶溢出，则根本不添加水。</p>
<p>可以将泄漏存储桶算法作为一种可以在流量监管或流量整形中使用的仪表的操作概念描述如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">emission_interval = period / rate <span class="comment"># 60 / 100 # 一个包需要 0.6 秒才能处理完 0.6s/package</span></span><br><span class="line">increment = emission_interval * cost <span class="comment"># 0.6 * cost 比如本次的数据包需要使用几个速率</span></span><br><span class="line">burst_offset = 60s <span class="comment"># 时间的长度 是 60s</span></span><br></pre></td></tr></table></figure>

<ul>
<li>与每个虚拟连接或用户关联的固定容量的存储桶以固定的速率泄漏。<ul>
<li>速率 &#x3D; 时长 &#x2F;  数据包个数， 例如，在一分钟内，只能处理， 100 个 数据包，那么速率是 60 &#x2F;  100</li>
</ul>
</li>
<li>如果漏斗是空的，它将停止泄漏。</li>
<li>为了使包装符合要求，必须向桶中添加一定量的水：符合要求的包所添加的特定量对于所有包都可以相同，或者与包的长度成比例。</li>
<li>如果此水量会使水桶超出其容量，则说明包不合格，水桶中的水保持不变。</li>
</ul>
<h3 id="图解如下"><a href="#图解如下" class="headerlink" title="图解如下"></a>图解如下</h3><p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/f1798b7201b347849e02c289cba284e6.png" alt="图解漏斗桶算法"></p>
<h3 id="lua-script"><a href="#lua-script" class="headerlink" title="lua script"></a>lua script</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Copyright (c) 2017 Pavel Pravosud</span></span><br><span class="line"><span class="comment">-- https://github.com/rwz/redis-gcra/blob/master/vendor/perform_gcra_ratelimit.lua</span></span><br><span class="line">redis.replicate_commands()</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> rate_limit_key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> burst = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> rate = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">local</span> period = ARGV[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">local</span> cost = <span class="built_in">tonumber</span>(ARGV[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> emission_interval = period / rate</span><br><span class="line"><span class="keyword">local</span> increment = emission_interval * cost</span><br><span class="line"><span class="keyword">local</span> burst_offset = emission_interval * burst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> jan_1_2017 = <span class="number">1483228800</span></span><br><span class="line"><span class="keyword">local</span> now = redis.call(<span class="string">&quot;TIME&quot;</span>)</span><br><span class="line">now = (now[<span class="number">1</span>] - jan_1_2017) + (now[<span class="number">2</span>] / <span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> tat = redis.call(<span class="string">&quot;GET&quot;</span>, rate_limit_key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> tat <span class="keyword">then</span></span><br><span class="line">  tat = now</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  tat = <span class="built_in">tonumber</span>(tat)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">tat = <span class="built_in">math</span>.<span class="built_in">max</span>(tat, now)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> new_tat = tat + increment</span><br><span class="line"><span class="keyword">local</span> allow_at = new_tat - burst_offset</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> diff = now - allow_at</span><br><span class="line"><span class="keyword">local</span> remaining = <span class="built_in">math</span>.<span class="built_in">floor</span>(diff / emission_interval + <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> remaining &lt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">local</span> reset_after = tat - now</span><br><span class="line">  <span class="keyword">local</span> retry_after = diff * <span class="number">-1</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="comment">-- allowed</span></span><br><span class="line">    <span class="number">0</span>, <span class="comment">-- remaining</span></span><br><span class="line">    <span class="built_in">tostring</span>(retry_after),</span><br><span class="line">    <span class="built_in">tostring</span>(reset_after),</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> reset_after = new_tat - now</span><br><span class="line">redis.call(<span class="string">&quot;SET&quot;</span>, rate_limit_key, new_tat, <span class="string">&quot;EX&quot;</span>, <span class="built_in">math</span>.<span class="built_in">ceil</span>(reset_after))</span><br><span class="line"><span class="keyword">local</span> retry_after = <span class="number">-1</span></span><br><span class="line"><span class="keyword">return</span> &#123;cost, remaining, <span class="built_in">tostring</span>(retry_after), <span class="built_in">tostring</span>(reset_after)&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AS-A-QUEUE"><a href="#AS-A-QUEUE" class="headerlink" title="AS A QUEUE"></a>AS A QUEUE</h2><p>uber-go 实现的漏斗桶算法 (as a queue)， 比较简单的非分布式漏斗桶，<a target="_blank" rel="noopener" href="https://github.com/uber-go/ratelimit/blob/a7b5fef1e7d73c4f8832efdd129a81996cf12ad0/ratelimit.go#L108">代码如下</a></p>
<p>主要是基于 sleep 函数做速率控制。所以核心实际上是计算 需要睡眠的时间， 需要睡眠的时间由两部分组成，一部分是每一个请求需要花费的时间 perRequest, 另一个是之前的所有请求所使用了的时间 now.Sub(oldState.last)， 如果这个时间为正数， 说明前面一段时间处理不是很忙碌，现在能处理更多的请求。如果这个时间为负数，说明前面已经排队了很多请求，这里需要更多的睡眠时间。</p>
<ul>
<li>如果是第一次调用 Take 函数，那么直接返回，并设置 state.last &#x3D; now</li>
<li>如果是非第一次调用 Take 函数，那么计算当前请求需要休眠的时间 <code>newState.sleepFor += t.perRequest - now.Sub(oldState.last)</code><ul>
<li>其中 perRequest 表示每一个请求需要的理论平均时间，例如该 limiter 初始化为 100 qps，那么 preRequest 就是 0.01 s， 对应的初始化代码 <code>perRequest: time.Second / time.Duration(rate)</code></li>
</ul>
</li>
<li>然后更新 state.last <code>newState.last = now; newState.last = newState.last.Add(newState.sleepFor)</code></li>
<li>然后 sleep</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">func (t *limiter) Take() time.Time &#123;</span><br><span class="line">	newState := state&#123;&#125;</span><br><span class="line">	taken := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">for</span> !taken &#123;</span><br><span class="line">		now := t.clock.Now()</span><br><span class="line"></span><br><span class="line">		previousStatePointer := atomic.LoadPointer(&amp;t.state)</span><br><span class="line">		oldState := (*state)(previousStatePointer)</span><br><span class="line"></span><br><span class="line">		newState = state&#123;&#125;</span><br><span class="line">		newState.last = now</span><br><span class="line"></span><br><span class="line">		// If this is our first request, <span class="keyword">then</span> we allow it.</span><br><span class="line">		<span class="keyword">if</span> oldState.last.<span class="function"><span class="title">IsZero</span></span>() &#123;</span><br><span class="line">			taken = atomic.CompareAndSwapPointer(&amp;t.state, previousStatePointer, unsafe.Pointer(&amp;newState))</span><br><span class="line">			<span class="built_in">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// sleepFor calculates how much time we should <span class="built_in">sleep</span> based on</span><br><span class="line">		// the perRequest budget and how long the last request took.</span><br><span class="line">		// Since the request may take longer than the budget, this number</span><br><span class="line">		// can get negative, and is summed across requests.</span><br><span class="line">		newState.sleepFor += t.perRequest - now.Sub(oldState.last)</span><br><span class="line">		// We shouldn<span class="string">&#x27;t allow sleepFor to get too negative, since it would mean that</span></span><br><span class="line"><span class="string">		// a service that slowed down a lot for a short period of time would get</span></span><br><span class="line"><span class="string">		// a much higher RPS following that.</span></span><br><span class="line"><span class="string">		if newState.sleepFor &lt; t.maxSlack &#123;</span></span><br><span class="line"><span class="string">			newState.sleepFor = t.maxSlack</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		if newState.sleepFor &gt; 0 &#123;</span></span><br><span class="line"><span class="string">			newState.last = newState.last.Add(newState.sleepFor)</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		taken = atomic.CompareAndSwapPointer(&amp;t.state, previousStatePointer, unsafe.Pointer(&amp;newState))</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	t.clock.Sleep(newState.sleepFor)</span></span><br><span class="line"><span class="string">	return newState.last</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Leaky_bucket">wiki leaky bucket</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/go-redis/redis_rate">go redis 实现分布式漏斗桶算法 (as a meter)</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/uber-go/ratelimit">uber-go 实现的漏斗桶(as a queue)</a></p>
<p>下一篇谷歌实现的令牌桶算法，有时间再看了，<a target="_blank" rel="noopener" href="https://github.com/golang/time">https://github.com/golang/time</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/19/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%8C%87%E6%A0%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/19/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%8C%87%E6%A0%87/" class="post-title-link" itemprop="url">分布式系统之指标</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-19 20:22:33" itemprop="dateCreated datePublished" datetime="2020-10-19T20:22:33+08:00">2020-10-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-31 19:33:52" itemprop="dateModified" datetime="2023-01-31T19:33:52+08:00">2023-01-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="高并发（High-Concurrency）"><a href="#高并发（High-Concurrency）" class="headerlink" title="高并发（High Concurrency）"></a>高并发（High Concurrency）</h2><p>高并发通常是指，通过设计保证<strong>系统能够同时并行处理很多请求</strong>。 高并发相关常用的一些指标有<strong>响应时间</strong>（Response Time），<strong>吞吐量</strong>（Throughput），<strong>每秒查询率</strong>QPS（Query Per Second），<strong>并发用户数</strong>等。</p>
<p><strong>响应时间</strong>：系统对请求做出响应的时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间。</p>
<p><strong>吞吐量</strong>：单位时间内处理的请求数量。</p>
<p><strong>QPS</strong>：每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。</p>
<p><strong>并发用户数</strong>：同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。</p>
<h3 id="如何提升"><a href="#如何提升" class="headerlink" title="如何提升"></a>如何提升</h3><ul>
<li><p>垂直扩展（Scale Up） </p>
<ul>
<li>增强单机硬件性能（优先）， 例如更好的磁盘，cpu，网卡，带宽</li>
<li>提升单机架构性能：例如：使用Cache来减少IO次数</li>
</ul>
</li>
<li><p>水平扩展（Scale Out）</p>
<ul>
<li>增加服务器数量（前提是系统设计支持水平扩展）</li>
</ul>
</li>
</ul>
<h2 id="高可用（High-Availability）"><a href="#高可用（High-Availability）" class="headerlink" title="高可用（High Availability）"></a>高可用（High Availability）</h2><p>高可用性（High Availability）通常来描述一个系统经过<strong>专门</strong>的设计，从而<strong>减少停工时间</strong>，而保持其服务的高度可用性(一直都能用)，指标通常就是说的多少个9。</p>
<ul>
<li><strong>6个9的性能</strong>：系统可用的概率为99.9999%</li>
</ul>
<h3 id="如何提升-1"><a href="#如何提升-1" class="headerlink" title="如何提升"></a>如何提升</h3><ul>
<li>避免单点：使用单个服务器，一旦该服务器意外宕机，将导致服务不可用</li>
<li>健康检查：<strong>监控</strong>服务器状态，挂了就进行<strong>故障恢复</strong></li>
</ul>
<h2 id="高性能（High-Performance）"><a href="#高性能（High-Performance）" class="headerlink" title="高性能（High Performance）"></a>高性能（High Performance）</h2><p>高性能（High Performance）就是指<strong>程序处理速度快，所占内存少，cpu占用率低</strong>。</p>
<p>高并发和高性能是紧密相关的，提高应用的性能，是肯定可以提高系统的并发能力的。</p>
<p>应用性能优化的时候，对于<strong>计算密集型和IO密集型</strong>还是有很大差别，需要分开来考虑。</p>
<h3 id="如何提升-2"><a href="#如何提升-2" class="headerlink" title="如何提升"></a>如何提升</h3><p>高性能主要是针对代码优化</p>
<ul>
<li>减少 IO 阻塞导致的 CPU 闲置</li>
<li>减少 锁 导致的串行化</li>
<li>避免大量创建对象和线程（使用对象池和线程池， 或者叫做<strong>池化技术</strong>）</li>
</ul>
<h2 id="高可靠（High-Reliability）"><a href="#高可靠（High-Reliability）" class="headerlink" title="高可靠（High Reliability）"></a>高可靠（High Reliability）</h2><p>可靠性是指系统可以无故障地持续运行。</p>
<h3 id="与高可用性的区别"><a href="#与高可用性的区别" class="headerlink" title="与高可用性的区别"></a>与高可用性的区别</h3><p>可靠性是指系统可以无故障地持续运行。与可用性相反，可靠性是根据时间间隔而不是任何时刻来进行定义的。</p>
<p>有两个极端的例子可以很好的说明这两个概念的区别:</p>
<ol>
<li>假想一个服务，可靠性很高，平均来说可以稳定运行10年，但是一旦服务中断，要用一年的时间来恢复，那么它的可用性只有90%。</li>
<li>假想另一个服务，可靠性很差，运行10秒就会宕机，但是恢复服务只需要1ms, 那么它的可用性是99.99%</li>
</ol>
<h2 id="可伸缩性-x2F-可扩展性-Scalable-x2F-scalability"><a href="#可伸缩性-x2F-可扩展性-Scalable-x2F-scalability" class="headerlink" title="可伸缩性&#x2F;可扩展性(Scalable&#x2F;scalability)"></a>可伸缩性&#x2F;可扩展性(Scalable&#x2F;scalability)</h2><p>wiki cn</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可缩放性（Scalability），又译为“可规模性”，形容词是“可规模化”，是指问题规模和处理器数目之间的函数关系。</span><br></pre></td></tr></table></figure>

<p>wiki en</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Scalability is the property of a system to handle a growing amount of work by adding resources to the system.[1]</span><br><span class="line"></span><br><span class="line">In an economic context, a scalable business model implies that a company can increase sales given increased resources. For example, a package delivery system is scalable because more packages can be delivered by adding more delivery vehicles. However, if all packages had to first pass through a single warehouse for sorting, the system would not be scalable, because one warehouse can handle only a limited number of packages.[2]</span><br><span class="line"></span><br><span class="line">In computing, scalability is a characteristic of computers, networks, algorithms, networking protocols, programs and applications. An example is a search engine, which must support increasing numbers of users, and the number of topics it indexes.[3] Webscale is a computer architectural approach that brings the capabilities of large-scale cloud computing companies into enterprise data centers.</span><br></pre></td></tr></table></figure>

<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>个人感觉 wiki 的解释很棒，可扩展性，就是可规模性，就是当规模成倍增加时，处理器的数目只需要做对应的增加，就可以达到目标的一种能力。搜索引擎就是一种典型的可扩展的设计，因为当需要索引的数据成倍的增加时，不会因为某个系统的环节而导致无法索引所有的数据。</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/107282067">高可靠和高可用的区别</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/16/distribute/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%20k8s%E3%80%902%E3%80%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/16/distribute/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%20k8s%E3%80%902%E3%80%91/" class="post-title-link" itemprop="url">虚拟化之开始使用 k8s【2】</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-16 17:10:22" itemprop="dateCreated datePublished" datetime="2020-10-16T17:10:22+08:00">2020-10-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">虚拟化</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="kube-proxy-和-service"><a href="#kube-proxy-和-service" class="headerlink" title="kube-proxy 和 service"></a>kube-proxy 和 service</h2><p>配置好网络之后，集群是什么情况呢？我们可以创建 pod，也能通过 ReplicationController 来创建特定副本的 pod（这是更推荐也是生产上要使用的方法，即使某个 rc 中只有一个 pod 实例）。可以从集群中获取每个 pod ip 地址，然后也能在集群内部直接通过 <code>podIP:Port</code> 来获取对应的服务。</p>
<p>但是还有一个问题：<strong>pod 是经常变化的，每次更新 ip 地址都可能会发生变化</strong>，如果直接访问容器 ip 的话，会有很大的问题。而且进行扩展的时候，rc 中会有新的 pod 创建出来，出现新的 ip 地址，我们需要一种更灵活的方式来访问 pod 的服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用场景</span></span><br><span class="line">podIp=`kcpg robotserver-pro | awk <span class="string">&#x27;&#123;print $6&#125;&#x27;</span>` &amp;&amp; curl <span class="string">&quot;<span class="variable">$&#123;podIp&#125;</span>:8050/ai_answer&quot;</span> -X POST</span><br></pre></td></tr></table></figure>

<h3 id="Service-和-cluster-IP"><a href="#Service-和-cluster-IP" class="headerlink" title="Service 和 cluster IP"></a>Service 和 cluster IP</h3><p>针对这个问题，kubernetes 的解决方案是“服务”（service），每个服务都一个固定的虚拟 ip（这个 ip 也被称为 cluster IP），自动并且动态地绑定后面的 pod，所有的网络请求直接访问服务 ip，服务会自动向后端做转发。Service 除了提供稳定的对外访问方式之外，还能起到负载均衡（Load Balance）的功能，自动把请求流量分布到后端所有的服务上，服务可以做到对客户透明地进行水平扩展（scale）。</p>
<p>而实现 service 这一功能的关键，就是 kube-proxy。kube-proxy 运行在每个节点上，监听 API Server 中服务对象的变化，通过管理 iptables 来实现网络的转发。</p>
<blockquote>
<p><strong>NOTE</strong>: kube-proxy 要求 NODE 节点操作系统中要具备 &#x2F;sys&#x2F;module&#x2F;br_netfilter 文件，而且还要设置 bridge-nf-call-iptables&#x3D;1，如果不满足要求，那么 kube-proxy 只是将检查信息记录到日志中，kube-proxy 仍然会正常运行，但是这样通过 Kube-proxy 设置的某些 iptables 规则就不会工作。</p>
</blockquote>
<p>kube-proxy 有两种实现 service 的方案：userspace 和 iptables</p>
<ul>
<li>userspace 是在用户空间监听一个端口，所有的 service 都转发到这个端口，然后 kube-proxy 在内部应用层对其进行转发。因为是在用户空间进行转发，所以效率也不高</li>
<li>iptables 完全使用 iptables 来实现 service，是目前默认的方式，也是推荐的方式，效率很高（只有内核中 netfilter 一些损耗）。</li>
</ul>
<p>现在还有一种叫做 ipvs 的实现方案。</p>
<p>这篇文章通过 iptables 模式运行 kube-proxy，后面的分析也是针对这个模式的，userspace 只是旧版本支持的模式，以后可能会放弃维护和支持。</p>
<h3 id="kube-proxy-参数介绍"><a href="#kube-proxy-参数介绍" class="headerlink" title="kube-proxy 参数介绍"></a>kube-proxy 参数介绍</h3><p>…</p>
<h2 id="实例启动和测试"><a href="#实例启动和测试" class="headerlink" title="实例启动和测试"></a>实例启动和测试</h2><h3 id="whoami-镜像"><a href="#whoami-镜像" class="headerlink" title="whoami 镜像"></a>whoami 镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://github.com/hypriot/rpi-whoami</span></span><br><span class="line">docker pull cizixs/whoami:v0.5</span><br></pre></td></tr></table></figure>

<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>为了方便测试，我们创建一个 rc，里面有三个 pod。这个 pod 运行的是 <a target="_blank" rel="noopener" href="https://github.com/cizixs/whoami"><code>cizixs/whoami</code> 容器</a>，它是一个简单的 HTTP 服务器，监听在 3000 端口，访问它会返回容器的 hostname。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat whoami-rc.yml</span></span><br></pre></td></tr></table></figure>

<p>创建部署， <code>kubectl create -f ./whoami-rc.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">whoami</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">whoami</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">whoami</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">whoami</span></span><br><span class="line">        <span class="attr">env:</span> <span class="string">dev</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">whoami</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">cizixs/whoami:v0.5</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3000</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MESSAGE</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">viola</span></span><br></pre></td></tr></table></figure>

<p>我们为每个 pod 设置了两个 label：<code>app=whoami</code> 和 <code>env=dev</code>，这两个标签很重要，也是后面服务进行绑定 pod 的关键。</p>
<p>为了使用 service，我们还要定义另外一个文件，并通过 <code>kubectl create -f ./whoami-svc.yml</code> 来创建出来对象：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">whoami</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">whoami</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">3000</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">whoami</span></span><br><span class="line">    <span class="attr">env:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>selector</code> 告诉 kubernetes 这个 service 和后端哪些 pod 绑定在一起，这里包含的键值对会对所有 pod 的 <code>labels</code> 进行匹配，只要完全匹配，service 就会把 pod 作为后端。也就是说，service 和 rc 并不是对应的关系，一个 service 可能会使用多个 rc 管理的 pod 作为后端应用。</p>
<p><code>ports</code> 字段指定服务的端口信息：</p>
<ul>
<li><code>port</code>：虚拟 ip 要绑定的 port，每个 service 会创建出来一个虚拟 ip，通过访问 <code>vip:port</code> 就能获取服务的内容。这个 port 可以用户随机选取，因为每个服务都有自己的 vip，也不用担心冲突的情况</li>
<li><code>targetPort</code>：pod 中暴露出来的 port，这是运行的容器中具体暴露出来的端口，一定不能写错</li>
<li><code>protocol</code>：提供服务的协议类型，可以是 <code>TCP</code> 或者 <code>UDP</code></li>
</ul>
<p>创建之后可以列出 service ，发现我们创建的 service 已经分配了一个虚拟 ip (10.108.161.211)，这个虚拟 ip 地址是不会变化的（除非 service 被删除）。查看 service 的详情可以看到它的 endpoints 列出，对应了具体提供服务的 pod 地址和端口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">|&gt;<span class="comment"># kc get svc | grep whoami</span></span><br><span class="line"><span class="built_in">whoami</span>                                            ClusterIP      10.108.161.211   &lt;none&gt;                                                 3000/TCP                                       90s</span><br><span class="line"></span><br><span class="line"><span class="comment"># endpoints 中就是 pod 的ip + port，而这是易变的</span></span><br><span class="line">|&gt;<span class="comment"># kc describe svc whoami</span></span><br><span class="line">Name:              <span class="built_in">whoami</span></span><br><span class="line">Namespace:         test-ks</span><br><span class="line">Labels:            name=<span class="built_in">whoami</span></span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          app=<span class="built_in">whoami</span>,<span class="built_in">env</span>=dev</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP:                10.108.161.211</span><br><span class="line">Port:              &lt;<span class="built_in">unset</span>&gt;  3000/TCP</span><br><span class="line">TargetPort:        3000/TCP</span><br><span class="line">Endpoints:         10.244.0.111:3000,10.244.0.112:3000,10.244.0.113:3000</span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>默认的 service 类型是 <code>ClusterIP</code>，这个也可以从上面输出看出来。在这种情况下，只能从集群内部访问这个 IP，不能直接从集群外部访问服务。如果想对外提供服务，我们后面会讲解决方案。</p>
<p>测试一下，访问 service 服务的时候可以看到它会随机地访问后端的 pod，给出不同的返回：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接通过 pod ip + port 访问</span></span><br><span class="line">|&gt;<span class="comment"># curl &quot;10.244.10.130:3000&quot;</span></span><br><span class="line">viola from whoami-hj7g8</span><br><span class="line"></span><br><span class="line"><span class="comment"># vip:port 访问 service，然后访问到 pod</span></span><br><span class="line"></span><br><span class="line">root@localhost ~]<span class="comment"># curl http://10.108.161.211:3000</span></span><br><span class="line">viola from whoami-8fpqp</span><br><span class="line">[root@localhost ~]<span class="comment"># curl http://10.108.161.211:3000</span></span><br><span class="line">viola from whoami-c0x6h</span><br><span class="line">[root@localhost ~]<span class="comment"># curl http://10.108.161.211:3000</span></span><br><span class="line">viola from whoami-8fpqp</span><br><span class="line">[root@localhost ~]<span class="comment"># curl http://10.108.161.211:3000</span></span><br><span class="line">viola from whoami-dc9ds</span><br></pre></td></tr></table></figure>

<p><strong>NOTE</strong>: 需要注意的是，服务分配的 cluster IP 是一个虚拟 ip，如果你尝试 <code>ping</code> 这个 IP 会发现它没有任何响应，这也是刚接触 kubernetes service 的人经常会犯的错误。实际上，这个虚拟 IP 只有和它的 port 一起的时候才有作用，直接访问它，或者想访问该 IP 的其他端口都是徒劳。</p>
<h3 id="外部能够访问的服务"><a href="#外部能够访问的服务" class="headerlink" title="外部能够访问的服务"></a>外部能够访问的服务</h3><p>上面创建的服务只能在集群内部访问，这在生产环境中还不能直接使用。如果希望有一个能直接对外使用的服务，可以使用 <code>NodePort</code> 或者 <code>LoadBalancer</code> 类型的 Service。我们先说说 <code>NodePort</code>，它的意思是在所有 worker 节点上暴露一个端口，这样外部可以直接通过访问 <code>nodeIP:Port</code> 来访问应用。</p>
<p>我们先把刚才创建的服务删除：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># kubectl delete rc whoami</span></span><br><span class="line">replicationcontroller <span class="string">&quot;whoami&quot;</span> deleted</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># kubectl delete svc whoami</span></span><br><span class="line">service <span class="string">&quot;whoami&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<h4 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh install2.sh <span class="variable">$&#123;ns&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>nodePort</code> 类型的服务会在所有的 worker 节点（运行了 kube-proxy）上统一暴露出端口对外提供服务，也就是说外部可以任意选择一个节点进行访问。比如我本地集群有三个节点：<code>172.17.8.100</code>、<code>172.17.8.101</code> 和 <code>172.17.8.102</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># curl http://172.17.8.100:31647</span></span><br><span class="line">viola from whoami-mc2fg</span><br><span class="line">[root@localhost ~]<span class="comment"># curl http://172.17.8.101:31647</span></span><br><span class="line">viola from whoami-8zc3d</span><br><span class="line">[root@localhost ~]<span class="comment"># curl http://172.17.8.102:31647</span></span><br><span class="line">viola from whoami-z6skj</span><br></pre></td></tr></table></figure>

<p>有了 <code>nodePort</code>，用户可以通过外部的 Load Balance 或者路由器把流量转发到任意的节点，对外提供服务的同时，也可以做到负载均衡的效果。</p>
<p><code>nodePort</code> 类型的服务并不影响原来虚拟 IP 的访问方式，内部节点依然可以通过 <code>vip:port</code> 的方式进行访问。</p>
<h2 id="创建服务（原理解析）"><a href="#创建服务（原理解析）" class="headerlink" title="创建服务（原理解析）"></a>创建服务（原理解析）</h2><p>在 Kubernetes 中创建一个新的 Service 对象需要两大模块同时协作，其中一个模块是控制器，它需要在每次客户端创建新的 Service 对象时，生成其他用于暴露一组 Pod 的 Kubernetes 对象，也就是 Endpoint 对象；另一个模块是 kube-proxy，它运行在 Kubernetes 集群中的每一个节点上，会根据 Service 和 Endpoint 的变动改变节点上 iptables 或者 ipvs 中保存的规则。</p>
<ul>
<li>控制器， 用于生成 endpoints 对象</li>
<li>kube-proxy</li>
</ul>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>控制器模块其实总共有两个部分监听了 Service 变动的事件，其中一个是 <code>ServiceController</code>、另一个是 <code>EndpointController</code>，我们分别来看两者如何应对 Service 的变动。</p>
<h4 id="EndpointController"><a href="#EndpointController" class="headerlink" title="EndpointController"></a>EndpointController</h4><p>EndpointController 本身并没有通过 Informer 监听 Endpoint 资源的变动，但是它却同时订阅了 Service 和 Pod 资源的增删事件，对于 Service 资源来讲，EndpointController 会通过以下的方式进行处理：</p>
<p>EndpointController 中的 syncService 方法是用于创建和删除 Endpoint 资源最重要的方法，在这个方法中我们会根据 <strong>Service 对象规格中的选择器 Selector 获取集群中存在的所有 Pod，并将 Service 和 Pod 上的端口进行映射生成一个 EndpointPort 结构体</strong>：</p>
<h4 id="查看-service-的endPoint"><a href="#查看-service-的endPoint" class="headerlink" title="查看 service 的endPoint"></a>查看 service 的endPoint</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以看到两个副本的 podIp</span></span><br><span class="line">|&gt;<span class="comment"># kcpg chatbot-client</span></span><br><span class="line">chatbot-client-ks-deploy-64d5f6cc84-dpp78                         1/1     Running     0          7d6h    172.0.7.197    alizjk-112191-prod-ks-kubelet-alg   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">chatbot-client-ks-deploy-64d5f6cc84-lx8ww                         1/1     Running     0          7d6h    172.0.3.20     zjk-023112158-kubelet-ks-qc         &lt;none&gt;           &lt;none&gt;</span><br><span class="line">|root@zjk-023112154-kubelet-ks-master ~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到</span></span><br><span class="line"><span class="comment"># 1. service 的 type 和 clusterIP</span></span><br><span class="line"><span class="comment"># 2. endPoints,可以看到对应的就是上面两个 podIp</span></span><br><span class="line"><span class="comment"># 3. 这里有两组 endPoint, 一组是 http， 一组是 prof</span></span><br><span class="line">|&gt;<span class="comment"># kc describe service chatbot-client-ks-service</span></span><br><span class="line">Name:              chatbot-client-ks-service</span><br><span class="line">Namespace:         ks-prod</span><br><span class="line">Labels:            app=chatbot-client-ks</span><br><span class="line">Annotations:       kubectl.kubernetes.io/last-applied-configuration:</span><br><span class="line">                     &#123;<span class="string">&quot;apiVersion&quot;</span>:<span class="string">&quot;v1&quot;</span>,<span class="string">&quot;kind&quot;</span>:<span class="string">&quot;Service&quot;</span>,<span class="string">&quot;metadata&quot;</span>:&#123;<span class="string">&quot;annotations&quot;</span>:&#123;&#125;,<span class="string">&quot;labels&quot;</span>:&#123;<span class="string">&quot;app&quot;</span>:<span class="string">&quot;chatbot-client-ks&quot;</span>&#125;,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;chatbot-client-ks-service&quot;</span>,<span class="string">&quot;...</span></span><br><span class="line"><span class="string">Selector:          app=chatbot-client-ks</span></span><br><span class="line"><span class="string">Type:              ClusterIP</span></span><br><span class="line"><span class="string">IP:                172.96.243.64</span></span><br><span class="line"><span class="string">Port:              http  8080/TCP</span></span><br><span class="line"><span class="string">TargetPort:        8080/TCP</span></span><br><span class="line"><span class="string">Endpoints:         172.0.3.20:8080,172.0.7.197:8080</span></span><br><span class="line"><span class="string">Port:              prof  8081/TCP</span></span><br><span class="line"><span class="string">TargetPort:        8081/TCP</span></span><br><span class="line"><span class="string">Endpoints:         172.0.3.20:8081,172.0.7.197:8081</span></span><br><span class="line"><span class="string">Session Affinity:  None</span></span><br><span class="line"><span class="string">Events:            &lt;none&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h3><p>在 Kubernetes 集群中的每一个节点都运行着一个 kube-proxy 进程，这个进程会负责监听 Kubernetes 主节点中 Service 的增加和删除事件并修改运行代理的配置，为节点内的客户端提供流量的转发和负载均衡等功能，但是当前 kube-proxy 的代理模式目前来看有三种：</p>
<h4 id="iptable"><a href="#iptable" class="headerlink" title="iptable"></a>iptable</h4><p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/8cee2fb2a2804f9884e3093dcec1ed32.png"></p>
<p>iptables 作为一种代理模式，它同样实现了 OnServiceUpdate、OnEndpointsUpdate 等方法，这两个方法会分别调用相应的变更追踪对象。</p>
<p>主要功能就是根据 <code>Service</code> 和 <code>Endpoint</code> 对象的变更生成一条一条的 iptables 规则.</p>
<p>当我们使用 iptables 的方式启动节点上的代理时，所有的流量都会先经过 PREROUTING 或者 OUTPUT 链，随后进入 Kubernetes 自定义的链入口 KUBE-SERVICES、单个 Service 对应的链 KUBE-SVC-XXXX 以及每个 Pod 对应的链 KUBE-SEP-XXXX，经过这些链的处理，最终才能够访问当一个服务的真实 IP 地址。</p>
<p>当我们使用 iptables 的方式启动节点上的代理时，所有的流量都会先经过 <code>PREROUTING</code> 或者 <code>OUTPUT</code> 链，随后进入 Kubernetes 自定义的链入口 KUBE-SERVICES、单个 Service 对应的链 <code>KUBE-SVC-XXXX</code> 以及每个 Pod 对应的链 <code>KUBE-SEP-XXXX</code>，经过这些链的处理，最终才能够访问当一个服务的真实 IP 地址。</p>
<h4 id="ipvs"><a href="#ipvs" class="headerlink" title="ipvs"></a>ipvs</h4><p>ipvs 就是用于解决在大量 Service 时，iptables 规则同步变得不可用的性能问题。与 iptables 比较像的是，ipvs 的实现虽然也基于 netfilter 的钩子函数，<strong>但是它却使用哈希表作为底层的数据结构并且工作在内核态</strong>，这也就是说 ipvs 在重定向流量和同步代理规则有着更好的性能。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Kubernetes 中的 Service 将一组 Pod 以统一的形式对外暴露成一个服务，它利用运行在内核空间的 iptables 或者 ipvs 高效地转发来自节点内部和外部的流量。除此之外，作为非常重要的 Kubernetes 对象，Service 不仅在逻辑上提供了微服务的概念，还引入 LoadBalancer 类型的 Service 无缝对接云服务商提供的复杂资源。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a target="_blank" rel="noopener" href="https://cizixs.com/2017/03/30/kubernetes-introduction-service-and-kube-proxy/">主要的参考</a></p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/kubernetes-service/">service 原理</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/11/concurrent%20and%20gc/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%90%9C%E9%9B%86%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/11/concurrent%20and%20gc/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%90%9C%E9%9B%86%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">【gc】常见的垃圾搜集算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-11 14:54:39" itemprop="dateCreated datePublished" datetime="2020-09-11T14:54:39+08:00">2020-09-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<p>这里垃圾回收是指语言层面的对堆上的不再使用的对象，释放他们占用的空间。语言层面上的垃圾回收是一种自动内存管理（automatic memory management that consists of determining which objects should be deallocated (“garbage collected”)）</p>
<p>通过这篇文章，你会知道：</p>
<ul>
<li><p>垃圾手机常见的判断对象是否可以回收的算法：引用计数法，跟可达分析法。</p>
</li>
<li><p>垃圾回收的常见的几种算法：标记清理， 标记整理，标记复制，分代收集，三色标记。</p>
</li>
</ul>
<h2 id="判断对象是否可回收"><a href="#判断对象是否可回收" class="headerlink" title="判断对象是否可回收"></a>判断对象是否可回收</h2><h3 id="引用计数算法（reference-counting）"><a href="#引用计数算法（reference-counting）" class="headerlink" title="引用计数算法（reference counting）"></a>引用计数算法（reference counting）</h3><p>引用计数的思想非常简单：每个单元（对象）维护一个域（<strong>再对象头里</strong>），保存其它单元指向它的引用数量（类似有向图的入度）。如果多一个对这个对象的引用（指针），那么计数加一；而删除某个指向这个对象的引用（指针），那么计数减一。当其引用计数为 0 的时候，该单元会被进行回收。</p>
<ul>
<li>优点<ul>
<li>渐进式。内存管理与用户程序的执行交织在一起，将 GC 的代价分散到整个程序。</li>
<li>内存单元能够很快被回收。相比于其他垃圾回收算法，堆被耗尽或者达到某个阈值才会进行垃圾回收。</li>
<li>算法易于实现。</li>
</ul>
</li>
<li>缺点<ul>
<li>原始的引用计数不能处理循环引用。</li>
<li>维护引用计数降低运行效率。这是引用计数的代价，其他的垃圾收集也会有对应的代价方式。</li>
</ul>
</li>
</ul>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>通过一系列称为 “GC Roots” 的对象作为起始点，从这个节点向下搜索，搜索走过的路径就是引用链，当一个对象到 GC Roots 没有任何引用链相连，也就是从 GC Roots 到这个对象不可达，则这个对象不可达，可以被回收。</p>
<p>Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：</p>
<ul>
<li>虚拟机栈中局部变量表中引用的对象</li>
<li>本地方法栈中 JNI 中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<h4 id="简述Java方法区"><a href="#简述Java方法区" class="headerlink" title="简述Java方法区"></a>简述Java方法区</h4><p>方法区又被称为静态区，是程序中永远唯一的元素存储区域。和堆一样，是各个线程共享的内存区域。它用于存储已被虚拟机加载的 类信息、常量、静态变量、即时编译器编译后的代码等数据。很多开发者更愿意把方法区称为“永久代”(Perm Gen)(Permanent Generation) 「总是存放不会轻易改变的内容」。在目前已经发布的JDK 1.7 的HotSpot中，已经把原本放在永久代的字符串常量池移至堆中。运行时常量池(Runtime Constant Pool)是方法区的一部分。</p>
<h2 id="常见垃圾收集算法"><a href="#常见垃圾收集算法" class="headerlink" title="常见垃圾收集算法"></a>常见垃圾收集算法</h2><h3 id="标记-清除（mark-and-sweep）"><a href="#标记-清除（mark-and-sweep）" class="headerlink" title="标记-清除（mark and sweep）"></a>标记-清除（mark and sweep）</h3><p>标记-清扫算法是一种基于追踪的自动内存管理。内存单元在程序运行过程中并不会在变成垃圾立刻回收，而是保持不可达状态，直到到达某个阈值或者固定时间长度。这个时候系统会挂起用户程序，也就是 STW（Stop The World，GC 的时候挂起用户程序），转而执行垃圾回收程序。垃圾回收程序对所有的存活单元进行一次全局遍历确定哪些单元可以回收。算法分两个部分：标记（mark）和清扫（sweep）。标记阶段表明所有的存活单元，清扫阶段将垃圾单元回收。如下图：</p>
<p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/c28455ee7a7148d9acdef45cd4c92f6a.png"></p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。</p>
<p>在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。</p>
<p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>可以处理循环引用的问题。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>在垃圾回收阶段会停止运行程序，大大增加程序的响应时间和不稳定性。</li>
<li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li>
</ul>
<h3 id="标记-整理（Mark-Czompact）"><a href="#标记-整理（Mark-Czompact）" class="headerlink" title="标记-整理（Mark-Czompact）"></a>标记-整理（Mark-Czompact）</h3><p>为了提升内存的利用率，科学家提出了标记-整理算法，该算法的起始过程和标记-清除算法相同，先标记处待回收对象的内存区域，但是在清除时不是对所有可回收对象清除，而是让所有存活对象往内存空间的一边移动，把存活对象边界外的内存直接清空掉。</p>
<p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/d23544599e114ca8a2933e0e63715d95.png"></p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>不会产生内存碎片</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>需要移动大量对象，处理效率比较低。</li>
<li>在移动存活对象的过程中，需要全程暂停用户程序的执行，被设计者称为“<strong>Stop The World</strong>”。</li>
</ul>
<h3 id="标记-复制算法（Mark-Copying）"><a href="#标记-复制算法（Mark-Copying）" class="headerlink" title="标记-复制算法（Mark-Copying）"></a>标记-复制算法（Mark-Copying）</h3><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p>
<p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/f42881aa1270470ab02640bb3276789a.png"></p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul>
<li>比较快</li>
</ul>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>主要不足是只使用了内存的一半。</li>
</ul>
<h3 id="分代收集（generation-collector）"><a href="#分代收集（generation-collector）" class="headerlink" title="分代收集（generation collector）"></a>分代收集（generation collector）</h3><p>分代收集算法本质上是<strong>标记-复制算法</strong>，它把堆内存中较大的一块区域作为新生代区域，新生代区域中分为一个Eden区域和两个Survivor区域，Eden和Survivor的比例默认是8:1，因为在Eden区域，绝大数对象都熬不过第一轮GC（98%），所以每个Survivor区域只需要10%的空间就足矣了，每一次触发Minor GC时，就会将Eden区和Survivor区存活的对象复制到另外一个Survivor区域中，然后清除掉被回收的对象，每次都依据这样的步骤进行垃圾收集。</p>
<p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/9d97083cd1e549b1a6738f6f0c7fe8f6.png"></p>
<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul>
<li>效率较高</li>
</ul>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>实现复杂，且依赖于 标记-复制 垃圾收集算法</li>
</ul>
<h4 id="分配在old的情况"><a href="#分配在old的情况" class="headerlink" title="分配在old的情况"></a>分配在old的情况</h4><p><strong>大对象</strong>。当对象所占连续内存非常大时，不会分配在Eden区，如果分配在Eden区，那么对象存活时产生的复制操作将导致效率大大降低。</p>
<p>…</p>
<h4 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h4><blockquote>
<p>需要先了解针对不同区域进行收集的名词：Minor GC（新生代收集）、Major GC（老年代收集）、Full GC（整个Java堆和方法区的收集）、Mixed GC（新生代收集和部分老年代的收集，目前只有G1收集器有这种行为）</p>
</blockquote>
<p>发生GC(MinorGC或者FullGC)时，都会将用户线程停顿并进行垃圾收集，在Minor GC中，STW的时间较短，只涉及Eden和survivor区域的对象清除和复制操作，而Full GC则是对整个堆内存进行垃圾收集，对象的扫描、标记和清除操作工作量大大提高，所以Full GC会导致用户线程停顿较长时间，如果频繁地发生Full GC，那么用户线程将无法正常执行。</p>
<h3 id="三色标记（Tri-color-marking）"><a href="#三色标记（Tri-color-marking）" class="headerlink" title="三色标记（Tri-color_marking）"></a>三色标记（Tri-color_marking）</h3><p>三色标记法是一个逻辑上的抽象，将对象分成<strong>白：未搜索，灰：正搜索，黑：已搜索。</strong></p>
<p>有三种集合：白色，黑色，灰色</p>
<ul>
<li>白色集合，或者叫危险集合，是垃圾回收的候选对象的集合</li>
<li>黑色集合，黑色集合是根集合可达的集合，且没有白色集合中对象的传出引用，不参与垃圾回收</li>
<li>灰色集包含从根可到达的所有对象，但尚未扫描以查找对“白色”对象的引用。 由于已知它们可以从根部到达，因此它们不能被垃圾收集，并且在扫描后将最终成为黑色集合。</li>
</ul>
<p>三色标记详细的请看 golang垃圾回收</p>
<h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><ul>
<li>stop the world 时间较短</li>
</ul>
<h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>三色标记必须引入写屏障，这带来了一些额外的开销</li>
<li>写屏障还会带来垃圾残留，因为一些可能被用到的对象在标记过程中会被标记为灰节点</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="http://idiotsky.top/2017/08/16/gc-three-color/">一张图了解三色标记</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking">维基百科-三色标记</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md">java垃圾收集算法</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/02/database/mysql%20%E5%88%86%E5%8C%BA%E5%88%86%E8%A1%A8%E5%88%86%E5%BA%93%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/02/database/mysql%20%E5%88%86%E5%8C%BA%E5%88%86%E8%A1%A8%E5%88%86%E5%BA%93%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">mysql 分区分表分库入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-02 11:53:58" itemprop="dateCreated datePublished" datetime="2020-09-02T11:53:58+08:00">2020-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-11 20:01:19" itemprop="dateModified" datetime="2022-10-11T20:01:19+08:00">2022-10-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<p>以下无特殊说明，都是 mysql InnoDB 引擎下讨论。</p>
<h2 id="水平和垂直的概念"><a href="#水平和垂直的概念" class="headerlink" title="水平和垂直的概念"></a>水平和垂直的概念</h2><p>水平：同一张表的<strong>不同行记录</strong>分配到不同的物理文件中</p>
<p>垂直：同一张表的<strong>不同列记录</strong>分配到不同的物理文件中</p>
<h2 id="分区概述"><a href="#分区概述" class="headerlink" title="分区概述"></a>分区概述</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看是否开启了分区</span></span><br><span class="line">show variables like <span class="string">&#x27;%partition%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="range-分区"><a href="#range-分区" class="headerlink" title="range 分区"></a>range 分区</h3><p>MySQL 在 5.1 支持了分区，且分区不是在存储引擎层完成的。分区就是将一个表或者索引拆分为多个文件，将一个文件分解为几个物理分区的文件。MySQL 只支持水平分区，不支持垂直分区。MySQL 是局部分区，即一个分区中即存放了数据，也存放了索引。而全局分区是指，数据存放在各个分区中，所有数据的索引存在在同一个文件中。</p>
<h4 id="range分区"><a href="#range分区" class="headerlink" title="range分区"></a>range分区</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use mydb;</span><br><span class="line">drop table mytable;</span><br><span class="line">create table mytable(id int) engine=innodb partition by range(id)(partition p0 values less than(10), partition p1 values less than(20));</span><br><span class="line"></span><br><span class="line">insert into mytable values(1);</span><br><span class="line">insert into mytable values(11);</span><br><span class="line"># 这里执行会报错</span><br><span class="line">insert into mytable values(30); </span><br><span class="line"></span><br><span class="line"># 注意看两个的分区不同</span><br><span class="line">explain partitions select * from mytable where id=1;</span><br><span class="line">explain partitions select * from mytable where id&lt;30;</span><br></pre></td></tr></table></figure>

<h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>mytable</td>
<td>p0</td>
<td>ALL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>1</td>
<td>100.00</td>
<td>Using where</td>
</tr>
<tr>
<td>2</td>
<td>SIMPLE</td>
<td>mytable</td>
<td>p0,p1</td>
<td>ALL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>2</td>
<td>50.00</td>
<td>Using where</td>
</tr>
</tbody></table>
<p>启用分区后，表不再是由一个ibd文件组成，而是由建立分区时的各个分区ibd文件。</p>
<h3 id="list-分区"><a href="#list-分区" class="headerlink" title="list 分区"></a>list 分区</h3><h3 id="hash-分区"><a href="#hash-分区" class="headerlink" title="hash 分区"></a>hash 分区</h3><h2 id="分库分表概述"><a href="#分库分表概述" class="headerlink" title="分库分表概述"></a>分库分表概述</h2><h3 id="数据库的瓶颈"><a href="#数据库的瓶颈" class="headerlink" title="数据库的瓶颈"></a>数据库的瓶颈</h3><h4 id="IO-瓶颈"><a href="#IO-瓶颈" class="headerlink" title="IO 瓶颈"></a>IO 瓶颈</h4><ul>
<li>磁盘读IO瓶颈，热点数据太多，数据库缓存放不下，每次查询时会产生大量的IO，降低查询速度 -&gt; <strong>分库和垂直分表</strong>。</li>
<li>网络IO瓶颈，请求的数据太多，网络带宽不够 -&gt; 分库。</li>
</ul>
<h4 id="CPU瓶颈"><a href="#CPU瓶颈" class="headerlink" title="CPU瓶颈"></a>CPU瓶颈</h4><ul>
<li>SQL问题，如SQL中包含join，group by，order by，非索引字段条件查询等，增加CPU运算的操作 -&gt; SQL优化，建立合适的索引，在业务Service层进行业务计算。</li>
<li>单表数据量太大，查询时扫描的行太多，SQL效率低，CPU率先出现瓶颈 -&gt; 水平分表。</li>
</ul>
<h3 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h3><p>以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。</p>
<ul>
<li>场景<ul>
<li>系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库。</li>
</ul>
</li>
</ul>
<h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><p>以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。</p>
<ul>
<li>场景<ul>
<li>系统绝对并发量并没有上来，只是单表的<strong>数据量太多</strong>，影响了SQL效率，加重了CPU负担，以至于成为瓶颈。</li>
</ul>
</li>
</ul>
<h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>以<strong>表</strong>为依据，按照业务归属不同，将不同的<strong>表</strong>拆分到不同的<strong>库</strong>中。</p>
<ul>
<li>场景<ul>
<li>系统绝对并发量上来了，并且可以抽象出单独的业务模块。4.分析：到这一步，基本上就可以服务化了。</li>
</ul>
</li>
</ul>
<h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>以<strong>字段</strong>为依据，按照字段的活跃性，将<strong>表</strong>中字段拆到不同的<strong>表</strong>（主表和扩展表）中。</p>
<ul>
<li>场景<ul>
<li>系统绝对并发量并没有上来，表的记录并不多，但是字段多，并且热点数据和非热点数据在一起，单行数据所需的存储空间较大。以至于数据库缓存的数据行减少，查询时会去读磁盘数据产生大量的随机读IO，产生IO瓶颈。</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUxOTc4NjEyMw==&mid=2247492541&idx=2&sn=fa772b9854267ba569405093156f2dd8&chksm=f9f6f859ce81714fa016c99955441c2de3ae90bbb0944c5ec846ea69c491e3891aa63a7a3afb&mpshare=1&scene=1&srcid=0901jHoHa4jHaENwOvwZgnU1&sharer_sharetime=1598940267356&sharer_shareid=2728d3a0eb6a32c660939921ae4b72ce&key=694ad12351d974dc25477b1afe15572a8153138db1620ba49874aa27bf5b622af9cb0ad8664141c5b8863bf4f49cc79807bfa096714dd1514ac95db0076957bdf681acf20bd0fa460b5d316e2c021cf1398ce66d18fa042ee71d1c04c0f281bf3de396ab6f527a6dbdffc3ebf4b7150355c41c80caced7c3eb3708fbdba38d3f&ascene=1&uin=MjQ3MzQ1MDUyNQ==&devicetype=Windows+10+x64&version=62090529&lang=zh_CN&exportkey=A4dI+N7UqB1bvsl2fWKR1u0=&pass_ticket=W37LZJj35wtgefD7LjgGM9gP1KY0TU1+6M4x0gG1h+Hc5beiytDTWprI7S+S4dUf">分库分表</a></p>
<p>《MySQL技术内幕(InnoDB存储引擎)第2版》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/01/database/mysql%20%E4%BA%8B%E5%8A%A1%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/01/database/mysql%20%E4%BA%8B%E5%8A%A1%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">mysql 事务入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-01 20:59:25" itemprop="dateCreated datePublished" datetime="2020-09-01T20:59:25+08:00">2020-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<p>以下无特殊说明，都是 mysql InnoDB 引擎下讨论。</p>
<h2 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h2><p>1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。</p>
<p>2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。</p>
<p>3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p>
<p> 4、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</p>
<h2 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h2><ul>
<li>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</li>
<li>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)</li>
<li>可重复读(Repeated Read)：可重复读。<strong>在同一个事务内的查询都与事务开始时刻一致的</strong>，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读。</li>
<li>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</li>
</ul>
<h2 id="事务隔离等级"><a href="#事务隔离等级" class="headerlink" title="事务隔离等级"></a>事务隔离等级</h2><table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>（读已提交）不可重复读（read-committed）</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<h3 id="脏读，不可重复读，幻读"><a href="#脏读，不可重复读，幻读" class="headerlink" title="脏读，不可重复读，幻读"></a>脏读，不可重复读，幻读</h3><p>1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p>
<p>2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</p>
<p>3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A修改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p>
<h2 id="查询MySQL隔离等级及设置隔离等级"><a href="#查询MySQL隔离等级及设置隔离等级" class="headerlink" title="查询MySQL隔离等级及设置隔离等级"></a>查询MySQL隔离等级及设置隔离等级</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 查询隔离等级</span><br><span class="line">select @@tx_isolation;</span><br><span class="line"></span><br><span class="line"># 设置隔离等级为 read commiteed</span><br><span class="line">SET session transaction isolation level read committed;</span><br><span class="line">SET SESSION binlog_format = &#x27;ROW&#x27;;（或者是MIXED）</span><br><span class="line"></span><br><span class="line">SET session transaction isolation level read uncommitted;</span><br><span class="line"></span><br><span class="line">SET session transaction isolation level repeatable read;</span><br><span class="line"></span><br><span class="line">SET session transaction isolation level serializable;</span><br></pre></td></tr></table></figure>

<h2 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h2><p>我们都知道事务的几种性质，数据库为了维护这些性质，尤其是一致性和隔离性，一般使用加锁这种方式。<strong>同时数据库又是个高并发的应用，同一时间会有大量的并发访问，如果加锁过度，会极大的降低并发处理能力。所以对于加锁的处理，可以说就是数据库对于事务处理的精髓所在。</strong>这里通过分析MySQL中InnoDB引擎的加锁机制，来抛砖引玉，让读者更好的理解，在事务处理中数据库到底做了什么。</p>
<h3 id="一次封锁or两段锁？"><a href="#一次封锁or两段锁？" class="headerlink" title="一次封锁or两段锁？"></a>一次封锁or两段锁？</h3><p>因为有大量的并发访问，为了预防死锁，一般应用中推荐使用一次封锁法，就是在方法的开始阶段，已经预先知道会用到哪些数据，然后全部锁住，在方法运行之后，再全部解锁。这种方式可以有效的避免循环死锁，但在数据库中却不适用，因为在事务开始阶段，数据库并不知道会用到哪些数据。</p>
<p>数据库遵循的是两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫两段锁）</p>
<ul>
<li>加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁（共享锁，其它事务可以继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得X锁（排它锁，其它事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。</li>
<li>解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。</li>
</ul>
<h3 id="事务中的加锁方式"><a href="#事务中的加锁方式" class="headerlink" title="事务中的加锁方式"></a>事务中的加锁方式</h3><p>MySQL中锁的种类很多，有常见的表锁和行锁，表锁是对一整张表加锁，虽然可分为读锁和写锁，但毕竟是锁住整张表，会导致并发能力下降，一般是做ddl处理时使用。行锁则是锁住数据行，这种加锁方法比较复杂，但是由于只锁住有限的数据，对于其它数据不加限制，所以并发能力强，MySQL一般都是用行锁来处理并发事务。这里主要讨论的也就是行锁。</p>
<h3 id="Read-Committed（读取提交内容）"><a href="#Read-Committed（读取提交内容）" class="headerlink" title="Read Committed（读取提交内容）"></a>Read Committed（读取提交内容）</h3><p>如果一个条件无法通过索引快速过滤，存储引擎层面就会将<strong>所有记录加锁</strong>后返回，再由MySQL Server层进行过滤。</p>
<p>但在实际使用过程当中，MySQL做了一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录释放锁 (违背了二段锁协议的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。</p>
<p>这种情况同样适用于MySQL的默认隔离级别RR。所以对一个数据量很大的表做批量修改的时候，如果无法使用相应的索引，MySQL Server过滤数据的的时候特别慢，就会出现虽然没有修改某些行的数据，但是它们还是被锁住了的现象。</p>
<h3 id="Repeatable-Read（可重读）"><a href="#Repeatable-Read（可重读）" class="headerlink" title="Repeatable Read（可重读）"></a>Repeatable Read（可重读）</h3><h4 id="不可重复读和幻读的区别"><a href="#不可重复读和幻读的区别" class="headerlink" title="不可重复读和幻读的区别"></a>不可重复读和幻读的区别</h4><p>很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。</p>
<p>如果使用锁机制来实现这两种隔离级别，在可重复读中，<strong>该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别。</strong></p>
<h2 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><p>悲观锁就是加锁，但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。</p>
<p>乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。**读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据，需要重新做读取数据，更新数据的尝试，<code>直到成功</code>**。</p>
<p>这就引出了 MVCC</p>
<p>Multi-Version Concurrency Control 多版本并发控制，MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问；在编程语言中实现事务内存。</p>
<h2 id="MVCC在MySQL的InnoDB中的实现"><a href="#MVCC在MySQL的InnoDB中的实现" class="headerlink" title="MVCC在MySQL的InnoDB中的实现"></a>MVCC在MySQL的InnoDB中的实现</h2><h3 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h3><p><img src="https://pic4.zhimg.com/80/v2-e1844f5816a332018183559d1573d80e_720w.jpg"></p>
<p>可以看到在InnoDB中，每一行都有2个隐藏列DATA_TRX_ID和DATA_ROLL_PTR(如果没有定义主键，则还有个隐藏主键列)：</p>
<ol>
<li>DATA_TRX_ID表示最近修改该行数据的事务ID （<strong>数据行版本号</strong>）。</li>
<li>DATA_ROLL_PTR则表示指向该行回滚段的指针，该行上所有旧的版本，在undo中都通过链表的形式组织，而该值，就是指向undo中该行的历史记录链表（<strong>删除版本号</strong>）。</li>
</ol>
<p>整个MVCC的关键就是通过DATA_TRX_ID和DATA_ROLL_PTR这两个隐藏列来实现的。</p>
<p>MVCC 使用了一种不同的手段，<strong>每个连接到数据库的读者，在某个瞬间看到的是数据库的一个快照，</strong>写者写操作造成的变化在写操作完成之前（或者数据库事务提交之前）对于其他的读者来说是不可见的。</p>
<p>当一个 MVCC 数据库需要更新一条数据记录的时候，它不会直接用新数据覆盖旧数据，而是将旧数据标记为过时（obsolete）并在别处增加新版本的数据。这样就会有存储多个版本的数据，但是只有一个是最新的。<strong>这种方式允许读者读取在他读之前已经存在的数据，即使这些在读的过程中半路被别人修改、删除了，也对先前正在读的用户没有影响。</strong>这种多版本的方式避免了填充删除操作在内存和磁盘存储结构造成的空洞的开销，但是需要系统周期性整理（sweep through）以真实删除老的、过时的数据。</p>
<h3 id="DATA-TRX-ID-DATA-ROLL-PTR"><a href="#DATA-TRX-ID-DATA-ROLL-PTR" class="headerlink" title="DATA_TRX_ID, DATA_ROLL_PTR"></a>DATA_TRX_ID, DATA_ROLL_PTR</h3><ul>
<li><p>MVCC逻辑流程-插入：插入的过程中会把全局事务ID记录到列 DB_TRX_ID 中去。</p>
</li>
<li><p>MVCC逻辑流程-删除：删除操作会把全局事务ID记录到 DB_ROLL_PT 中，不更改 DB_TRX_ID 。</p>
</li>
<li><p>MVCC逻辑流程-修改：修改数据的时候 会先复制一条当前记录行数据，同时标记这条数据的数据行版本号为当前是事务版本号，最后把原来的数据行的删除版本号标记为当前事务版本号。（<strong>相当于插入了一条，删除了一条</strong>）</p>
</li>
<li><p>MVCC逻辑流程-查询：</p>
<ul>
<li><p>查找数据行版本号早于当前事务版本号的数据行记录。</p>
<ul>
<li>也就是说，数据行的版本号要小于或等于当前是事务的系统版本号，这样也就确保了读取到的数据是当前事务开始前已经存在的数据，或者是自身事务改变过的数据。（<strong>不会查到新增的数据和因为修改而新增的数据</strong>）</li>
</ul>
</li>
<li><p>查找删除版本号要么为NULL，要么大于当前事务版本号的记录。</p>
<ul>
<li>这样确保查询出来的数据行记录在事务开启之前没有被删除。（<strong>确保被删除的数据和被修改的数据能被查到</strong>）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="MVCC-示例"><a href="#MVCC-示例" class="headerlink" title="MVCC 示例"></a>MVCC 示例</h3><p>创建 table</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> test_zq;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_zq (id <span class="type">int</span> (<span class="number">11</span>),test_id <span class="type">int</span> (<span class="number">11</span>)); </span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `test_zq` (`id`, `test_id`) <span class="keyword">values</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;18&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `test_zq` (`id`, `test_id`) <span class="keyword">values</span>(<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;8&#x27;</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_zq;</span><br></pre></td></tr></table></figure>

<h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</td>
<td>begin;</td>
</tr>
<tr>
<td>select * from test_zq;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update test_zq set test_id &#x3D; 100 where id &#x3D; 1;</td>
</tr>
<tr>
<td></td>
<td>insert into test_zq select 5, 101;</td>
</tr>
<tr>
<td></td>
<td>commit;</td>
</tr>
<tr>
<td>select * from test_zq;  (操作A3)</td>
<td></td>
</tr>
<tr>
<td>commit;</td>
<td></td>
</tr>
<tr>
<td>select * from test_zq;</td>
<td></td>
</tr>
</tbody></table>
<p>有赖于 MVCC 的控制，在操作A3 中保证了，和事务A刚开始时读取到的数据是相同的。<strong>保证了可重复读</strong>。</p>
<h3 id="“快照读”与“当前读”的区别"><a href="#“快照读”与“当前读”的区别" class="headerlink" title="“快照读”与“当前读”的区别"></a>“快照读”与“当前读”的区别</h3><p>我们且看，在RR级别中，通过MVCC机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，是不及时的数据，不是数据库当前的数据！这在一些对于数据的时效特别敏感的业务中，就很可能出问题。</p>
<p>对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库当前版本数据的方式，叫当前读 (current read)。很显然，在MVCC中：</p>
<ul>
<li>快照读：就是select<ul>
<li>select * from table ….;</li>
</ul>
</li>
<li>当前读：特殊的读操作，插入&#x2F;更新&#x2F;删除操作，属于当前读，处理的都是当前的数据，需要加锁。<ul>
<li>select * from table where ? lock in share mode;</li>
<li>select * from table where ? for update;</li>
<li>insert;</li>
<li>update ;</li>
<li>delete;</li>
</ul>
</li>
</ul>
<p><strong>MVCC 相当于只保证了<code>快照读</code>的可重复读及不发生幻读，但是如何保证<code>当前读</code>的不发生幻读，这就是 Next-key 锁了。</strong></p>
<h2 id="Next-Key锁-（临键锁）"><a href="#Next-Key锁-（临键锁）" class="headerlink" title="Next-Key锁 （临键锁）"></a>Next-Key锁 （临键锁）</h2><p>Next-Key锁（临键锁）是行锁和GAP（间隙锁）的合并，行锁上文已经介绍了，接下来说下GAP间隙锁。<strong>行锁可以防止不同事务版本的数据修改提交时造成数据冲突的情况。但如何避免别的事务插入数据就成了问题。</strong>我们可以看看RR级别和RC级别的对比</p>
<h3 id="RC下的当前读的幻读及RR下当前读的无幻读"><a href="#RC下的当前读的幻读及RR下当前读的无幻读" class="headerlink" title="RC下的当前读的幻读及RR下当前读的无幻读"></a>RC下的当前读的幻读及RR下当前读的无幻读</h3><p>准备数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into class_teacher select NULL, &#x27;初三一班&#x27;, 30;</span><br></pre></td></tr></table></figure>

<p>RC 下执行</p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务 B</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</td>
<td>begin;</td>
</tr>
<tr>
<td>select id,class_name,teacher_id from class_teacher where teacher_id&#x3D;30;</td>
<td></td>
</tr>
<tr>
<td>update class_teacher set class_name&#x3D;’初三四班’ where teacher_id&#x3D;30;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into class_teacher values (null,’初三二班’,30);</td>
</tr>
<tr>
<td></td>
<td>commit; （这里先提交了，因为可以提交成功）</td>
</tr>
<tr>
<td>select id,class_name,teacher_id from class_teacher where teacher_id&#x3D;30;  当前读产生了幻读，因为明明在当前事务已经将所有teacher_id&#x3D;30的数据修改了，但是还是有teacher_id&#x3D;30的数据。</td>
<td></td>
</tr>
<tr>
<td>commit;</td>
<td></td>
</tr>
<tr>
<td>select * from class_teacher;</td>
<td></td>
</tr>
</tbody></table>
<p>RR 下 执行</p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务 B</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</td>
<td>begin;</td>
</tr>
<tr>
<td>select id,class_name,teacher_id from class_teacher where teacher_id&#x3D;30;</td>
<td></td>
</tr>
<tr>
<td>update class_teacher set class_name&#x3D;’初三四班’ where teacher_id&#x3D;30;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into class_teacher values (null,’初三二班’,30);</td>
</tr>
<tr>
<td></td>
<td>waiting （主要的区别就是这里会阻塞，因为加了锁）</td>
</tr>
<tr>
<td>select id,class_name,teacher_id from class_teacher where teacher_id&#x3D;30;</td>
<td></td>
</tr>
<tr>
<td>commit;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>commit;</td>
</tr>
<tr>
<td>select * from class_teacher;</td>
<td></td>
</tr>
</tbody></table>
<p>通过对比我们可以发现，在 RC 级别中，事务 A 修改了所有 teacher_id&#x3D;30 的数据，但是当事务 B insert 进新数据后，事务A发现莫名其妙多了一行 teacher_id&#x3D;30 的数据，而且没有被之前的 update 语句所修改，这就是“当前读”的幻读。</p>
<p>RR级别中，事务A在update后加锁，事务B无法插入新数据，这样事务A在update前后读的数据保持一致，避免了幻读。这个锁，就是Gap锁。</p>
<h3 id="间隙锁-行锁解决-RR-当前读的幻读问题"><a href="#间隙锁-行锁解决-RR-当前读的幻读问题" class="headerlink" title="间隙锁 + 行锁解决 RR 当前读的幻读问题"></a>间隙锁 + 行锁解决 RR 当前读的幻读问题</h3><h3 id="next-key-示例"><a href="#next-key-示例" class="headerlink" title="next-key 示例"></a>next-key 示例</h3><p>添加需要的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into class_teacher select NULL, &#x27;初三一班&#x27;, 5;</span><br><span class="line">insert into class_teacher select NULL, &#x27;初三二班&#x27;, 30;</span><br><span class="line">select * from class_teacher;</span><br></pre></td></tr></table></figure>

<p>执行事务</p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
<th>事务C</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</td>
<td>begin;</td>
<td>begin;</td>
</tr>
<tr>
<td>select * from class_teacher;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>update class_teacher set class_name&#x3D;’初一一班’ where teacher_id&#x3D;20;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into class_teacher values (null,’初三五班’,10);</td>
<td>insert into class_teacher values (null,’初三五班’,40);</td>
</tr>
<tr>
<td></td>
<td>waiting …..（阻塞了，直到A commit）</td>
<td>commit; （随时都可以commit，没有被锁住）</td>
</tr>
<tr>
<td>select * from class_teacher;</td>
<td></td>
<td>成功</td>
</tr>
<tr>
<td>commit;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>commit;（事务A commit之后，阻塞才会结束）</td>
<td></td>
</tr>
<tr>
<td>select * from class_teacher;</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>update的teacher_id&#x3D;20是在(5，30]区间，即使没有修改任何数据，Innodb也会在这个区间加gap锁，而其它区间不会影响，事务C正常插入。</p>
<p>如果使用的是没有索引的字段，比如update class_teacher set teacher_id&#x3D;7 where class_name&#x3D;‘初三八班（即使没有匹配到任何数据）’,那么会给全表加入gap锁。同时，它不能像上文中行锁一样经过MySQL Server过滤自动解除不满足条件的锁，因为没有索引，则这些字段也就没有排序，也就没有区间。除非该事务提交，否则其它事务无法插入任何数据。</p>
<p><strong>行锁防止别的事务修改或删除，GAP锁防止别的事务新增，行锁和GAP锁结合形成的的Next-Key锁（临键锁）共同解决了RR级别在写数据时的幻读问题。</strong></p>
<h2 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h2><p>这个级别很简单，读加共享锁，写加排他锁，读写互斥。使用的悲观锁的理论，实现简单，数据更加安全，但是并发能力非常差。如果你的业务并发的特别少或者没有并发，同时又要求数据及时可靠的话，可以使用这种模式。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="演示table"><a href="#演示table" class="headerlink" title="演示table"></a>演示table</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">drop table class_teacher;</span><br><span class="line">CREATE TABLE class_teacher (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `class_name` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL,</span><br><span class="line">  `teacher_id` int(11) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `idx_teacher_id` (`teacher_id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>

<h2 id="究极总结认真看"><a href="#究极总结认真看" class="headerlink" title="究极总结认真看"></a>究极总结认真看</h2><p>**RR 模式下，MySQL 实际上实现了 可重复读，并且解决了大部分的幻读问题。这是由以下两个东西解决的。MVCC 解决了<code>快照读</code>的不可重复读和幻读问题，而 Next-key Lock 解决了 <code>当前读</code> 不可重复读的问题及 部分的幻读问题。为什么是部分的幻读问题，这是因为加的是一个间隙锁，在间隙之外的区间，仍然会出现幻读问题 **</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2014/08/20/innodb-lock.html">美团技术团队：Innodb中的事务隔离级别和锁的关系</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huanongying/p/7021555.html">https://www.cnblogs.com/huanongying/p/7021555.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/whoamiyang/article/details/51901888">轻松理解MYSQL MVCC 实现机制</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5c68a4056fb9a049e063e0ab">https://juejin.im/post/5c68a4056fb9a049e063e0ab</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/01/database/mysql%20%E7%B4%A2%E5%BC%95%E5%AF%B9null%E7%9A%84%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/01/database/mysql%20%E7%B4%A2%E5%BC%95%E5%AF%B9null%E7%9A%84%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">mysql 索引对null的处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-01 20:00:00" itemprop="dateCreated datePublished" datetime="2020-09-01T20:00:00+08:00">2020-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-24 20:15:47" itemprop="dateModified" datetime="2021-06-24T20:15:47+08:00">2021-06-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><em>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。</em>这句的前半句是不对的（可参考官网说明： <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/is-null-optimization.html%EF%BC%89%EF%BC%8C%E4%BD%86%E6%98%AF%E5%90%8E%E5%8D%8A%E5%8F%A5%E7%9A%84%E7%BB%93%E8%AE%BA%E7%A1%AE%E6%98%AF%E5%8F%AF%E4%BB%A5%E9%87%87%E7%BA%B3%E7%9A%84%E3%80%82">https://dev.mysql.com/doc/refman/5.7/en/is-null-optimization.html），但是后半句的结论确是可以采纳的。</a></p>
<p>虽然MySQL可以在含有null的列上使用索引，但不代表null和其他数据在索引中是一样的。不建议列上允许为空，最好限制 not null ，并设置一个默认值，比如0和’’空字符串等，如果是datetime类型，可以设置成’1970-01-01 00:00:00’这样的值。对MySQL来说，null 是一个特殊的值，Conceptually, NULL means “a missing unknown value” and it is treated somewhat differently from other values。 对null做算术运算的结果都是null，count时不会包括null行，null 比空字符串需要更多的存储空间等。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>可以看到只要索引中用了 is not null 或者 is null 这种用法，就会导致索引失效。</p>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">use mydb;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">drop table t1;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE `t1` (</span></span><br><span class="line"><span class="string">  `id` int(11) NOT NULL,</span></span><br><span class="line"><span class="string">  `a` int(11) DEFAULT NULL,</span></span><br><span class="line"><span class="string">  `b` int(11) DEFAULT NULL,</span></span><br><span class="line"><span class="string">  `c` int(11) DEFAULT NULL,</span></span><br><span class="line"><span class="string">  PRIMARY KEY (`id`),</span></span><br><span class="line"><span class="string">  KEY `a` (`a`)</span></span><br><span class="line"><span class="string">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">alter table t1 drop index a,add index idx_ab(a,b);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">show create table t1;</span></span><br><span class="line"><span class="string">explain select id, a from t1 where a = 10;</span></span><br><span class="line"><span class="string">explain select id, a from t1 where a is not null;</span></span><br><span class="line"><span class="string">explain select id, a from t1 where a = 10 and b = 5;</span></span><br><span class="line"><span class="string">explain select id, a from t1 where a = 10 and b is not null;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"></span><br><span class="line">engine = create_engine(<span class="string">&quot;mysql+mysqldb://root:123456@127.0.0.1:3306/mydb&quot;</span>, max_overflow=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_many_data</span>():</span><br><span class="line">    delete_all()</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 插入数据 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        engine.execute(</span><br><span class="line">            <span class="string">&quot;INSERT INTO t1(id, a, b, c) VALUES (&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;);&quot;</span>.<span class="built_in">format</span>(i, i, i, i)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        engine.execute(</span><br><span class="line">            <span class="string">&quot;INSERT INTO t1(id, a) VALUES (&#123;&#125;, &#123;&#125;);&quot;</span>.<span class="built_in">format</span>(i + <span class="number">10</span>, i, )</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        engine.execute(</span><br><span class="line">            <span class="string">&quot;INSERT INTO t1(id) VALUES (&#123;&#125;);&quot;</span>.<span class="built_in">format</span>(i + <span class="number">20</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete_all</span>():</span><br><span class="line">    engine.execute(<span class="string">&quot;delete from t1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    create_many_data()</span><br><span class="line"></span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/01/database/mysql%20%E7%B4%A2%E5%BC%95%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/01/database/mysql%20%E7%B4%A2%E5%BC%95%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">mysql 索引入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-01 16:39:25" itemprop="dateCreated datePublished" datetime="2020-09-01T16:39:25+08:00">2020-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-03 19:27:25" itemprop="dateModified" datetime="2022-11-03T19:27:25+08:00">2022-11-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<p>以下无特殊说明，都是 mysql InnoDB 引擎下讨论。</p>
<p>我们清楚InnoDB中主键索引B+树是如何组织数据、查询数据的，我们总结一下：</p>
<ol>
<li>InnoDB存储引擎的最小存储单元是页，页可以用于存放数据也可以用于存放键值(id)+指针，在B+树中叶子节点存放数据，非叶子节点存放键值+指针。</li>
<li>索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而在去数据页中查找到需要的数据；</li>
</ol>
<p>B+树数据页面结构</p>
<p><img src="https://pic1.zhimg.com/v2-45c408ecdf23e67e30670bc72be83149_r.jpg"></p>
<h2 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h2><p>InnoDB是索引组织表， 所以 InnoDB 必须有主键索引。大多数情况下主键索引都是一列自增的 ID。详细规则如下：</p>
<ul>
<li>如果一个主键被定义了，那么这个主键就是作为聚集索引</li>
<li>如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚集索引</li>
<li>如果没有主键也没有合适的唯一索引，那么innodb内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的列，改列的值会随着数据的插入自增。</li>
</ul>
<p><strong>索引组织表也就意味着，主键索引文件就是数据文件，因为主键索引文件的叶节点包含完整的数据记录。</strong></p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="从数据结构角度"><a href="#从数据结构角度" class="headerlink" title="从数据结构角度"></a>从数据结构角度</h3><ul>
<li>B+树索引(O(log(n)))</li>
<li>hash索引<ul>
<li>仅仅能满足”&#x3D;”,”IN”和”&lt;&#x3D;&gt;”查询，不能使用范围查询</li>
<li>其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到叶节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。</li>
<li><strong>只有Memory存储引擎显示支持hash索引</strong></li>
</ul>
</li>
<li>FULLTEXT索引（现在MyISAM和InnoDB引擎都支持了）</li>
<li>InnoDB 自适应哈希索引（不是一种索引）<ul>
<li>自适应哈希仅由数据库创建并使用，对范围查询无效，只对字典类型（等值查询）的查询有效。</li>
</ul>
</li>
</ul>
<h3 id="从物理存储角度"><a href="#从物理存储角度" class="headerlink" title="从物理存储角度"></a>从物理存储角度</h3><ul>
<li>聚集索引（clustered index）</li>
<li>非聚集索引（non-clustered index）</li>
</ul>
<h3 id="从逻辑角度"><a href="#从逻辑角度" class="headerlink" title="从逻辑角度"></a>从逻辑角度</h3><ul>
<li>主键索引：主键索引是一种特殊的唯一索引，不允许有空值</li>
<li>普通索引或者单列索引</li>
<li>多列索引（复合索引， 联合索引）：复合索引指多个字段上创建的索引。使用复合索引时遵循最左前缀集合</li>
<li>唯一索引或者非唯一索引</li>
</ul>
<h3 id="从使用效果来说"><a href="#从使用效果来说" class="headerlink" title="从使用效果来说"></a>从使用效果来说</h3><ul>
<li>覆盖索引（非聚集索引）<ul>
<li>覆盖索引：一个查询的结果从索引中就能全部获得，也称为索引覆盖（**(索引 + id**) 覆盖了查询结果）。</li>
<li>主键索引查询只会查一次，而非主键索引需要回表查询多次（<strong>回表</strong>）。但是如果使用覆盖索引，那么还是只会查一次。</li>
</ul>
</li>
</ul>
<h2 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h2><h3 id="为什么使用复合索引"><a href="#为什么使用复合索引" class="headerlink" title="为什么使用复合索引"></a>为什么使用复合索引</h3><p>参考另一篇文章</p>
<p>多个字段的顺序，一般是根据业务需求，将区分度高的放在左边。</p>
<h2 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h2><h3 id="B-Tree-的优劣势"><a href="#B-Tree-的优劣势" class="headerlink" title="B+Tree 的优劣势"></a>B+Tree 的优劣势</h3><p>InnoDB 的主键索引使用的是 B+Tree，节点存储着主键索引的值（方便做等值查询），叶子节点存储着完整的数据，且使用链表（双向链表）连接（方便范围查询）。</p>
<ul>
<li>适合范围查询，适合等值查询</li>
<li>可以使用索引完成排序</li>
<li>支持复合索引的最左匹配原则</li>
<li>大量重复的键值只会导致索引的区分度小，如果业务需要可以强制走索引<ul>
<li><code>select * from mytable force index(day_index) where day = 20200101 limit 2，强制走day_index索引</code></li>
</ul>
</li>
</ul>
<h3 id="hash-的优劣势"><a href="#hash-的优劣势" class="headerlink" title="hash 的优劣势"></a>hash 的优劣势</h3><ul>
<li>哈希索引适合等值查询，无法进行范围查询</li>
<li>哈希索引无法利用索引完成排序</li>
<li>哈希索引的多列索引不支持最左匹配原则</li>
<li>大量重复的键值会导致大量的哈希碰撞</li>
</ul>
<h3 id="B-Tree-的优劣势-1"><a href="#B-Tree-的优劣势-1" class="headerlink" title="B-Tree 的优劣势"></a>B-Tree 的优劣势</h3><ul>
<li>适合等值查询, 不适合范围查询</li>
<li>不可以使用索引完成排序</li>
<li>支持复合索引的最左匹配原则</li>
<li>因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（而B+树的非叶子结点只需要存储主键和指针就可以了）（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；</li>
<li>大量重复的键值只会导致索引的区分度小，如果业务需要可以强制走索引<ul>
<li><code>db.users.find(&#123;&quot;age&quot;:1,&quot;username&quot;: &quot;percy&quot;&#125;).hint(&#123;&quot;username&quot;:1,&quot;age&quot;:1&#125;)</code></li>
</ul>
</li>
</ul>
<h4 id="为什么-MongoDB-使用-B-Tree"><a href="#为什么-MongoDB-使用-B-Tree" class="headerlink" title="为什么 MongoDB 使用 B-Tree"></a>为什么 MongoDB 使用 B-Tree</h4><p>MongoDB 作为面向文档的数据库，与数据之间的关系相比，它更看重以文档为中心的组织方式（<strong>因为 B 树的所有节点都能存储数据</strong>），所以选择了查询单个文档性能较好的 B 树，这个选择对遍历数据的查询也可以保证可以接受的时延；</p>
<h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><h3 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h3><p>一条 SQL 语句的查询，可以有不同的执行方案，至于最终选择哪种方案，是查询优化器选择的。流程如下：</p>
<ul>
<li>根据搜索条件，找出所有可以使用的索引</li>
<li>计算全表扫描的代价</li>
<li>计算不同索引的查询代价</li>
<li>对比各种执行方案的代价，找出成本最低的那个</li>
</ul>
<h3 id="索引分析-explain"><a href="#索引分析-explain" class="headerlink" title="索引分析  explain"></a>索引分析  explain</h3><p>可以通过explain查看sql语句的执行计划，通过执行计划来分析索引使用情况</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">| mytable | CREATE TABLE `mytable` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `num` float DEFAULT NULL,</span><br><span class="line">  `name` varchar(255) DEFAULT NULL,</span><br><span class="line">  `day` int(11) DEFAULT NULL,</span><br><span class="line">  `date` datetime DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `name_day_key` (`name`,`day`),</span><br><span class="line">  KEY `day_name_key` (`day`,`name`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=30007 DEFAULT CHARSET=utf8 |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">explain select * from mytable where name = &#x27;percy&#x27; and day &gt; 959 and day &lt; 1000;</span><br><span class="line">explain select * from mytable where day &gt; 959 and day &lt; 999;</span><br></pre></td></tr></table></figure>

<p>结果如下, </p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>mytable</td>
<td>NULL</td>
<td>range</td>
<td>name_day_key,day_name_key</td>
<td>name_day_key</td>
<td>773</td>
<td>NULL</td>
<td>1</td>
<td>100.00</td>
<td>Using index condition</td>
</tr>
<tr>
<td>2</td>
<td>SIMPLE</td>
<td>mytable</td>
<td>NULL</td>
<td>range</td>
<td>day_name_key</td>
<td>day_name_key</td>
<td>5</td>
<td>NULL</td>
<td>1</td>
<td>100.00</td>
<td>Using index condition</td>
</tr>
</tbody></table>
<p>Using index condition 表示使用了索引下推</p>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>常用的类型有： ALL, index,  range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）</p>
<p>ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行</p>
<p>index: Full Index Scan，index与ALL区别为index类型只遍历索引树</p>
<p>range:只检索给定范围的行，使用一个索引来选择行</p>
<p>ref: 触发联合索引最左原则（不知道的搜下），或者这个索引不是主键，也不是唯一索引（换句话说，如果这个在这个索引基础之上查询的结果多于一行）。</p>
<p>const: 仅仅能查出一条的SQL语句并且用于Primary key 或 unique索引；</p>
<h5 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h5><p>面的笔记是根据我自己的 mysql 服务的版本号来的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select version();</span><br><span class="line">+------------+</span><br><span class="line">| version()  |</span><br><span class="line">+------------+</span><br><span class="line">| 5.6.16-log |</span><br><span class="line">+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>随便放一个查询结果，我们要说的就是这里的<code>type</code>的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain SELECT id,title FROM seo_php_article where is_delete=0 order by id asc limit 66500,500;</span><br><span class="line">+----+-------------+-----------------+------+---------------+-----------+---------+-------+-------+-----------------------------+</span><br><span class="line">| id | select_type | table           | type | possible_keys | key       | key_len | ref   | rows  | Extra                       |</span><br><span class="line">+----+-------------+-----------------+------+---------------+-----------+---------+-------+-------+-----------------------------+</span><br><span class="line">|  1 | SIMPLE      | seo_php_article | ref  | is_delete     | is_delete | 1       | const | 67500 | Using where; Using filesort |</span><br><span class="line">+----+-------------+-----------------+------+---------------+-----------+---------+-------+-------+-----------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>The type column of EXPLAIN output describes how tables are joined. The following list describes the join types, ordered from the best type to the worst:</p>
<p>下面的从好到坏依次解释：</p>
<h6 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h6><blockquote>
<p><strong>All rows with matching index values are read from this table for each combination of rows from the previous tables.</strong> ref is used if the join uses only a leftmost prefix of the key or if the key is not a PRIMARY KEY or UNIQUE index (in other words, if the join cannot select a single row based on the key value). If the key that is used matches only a few rows, this is a good join type.</p>
</blockquote>
<p><strong>第一句没理解透</strong>，先理解到多行匹配吧。</p>
<p>触发条件：触发联合索引最左原则（不知道的搜下），或者这个索引不是主键，也不是唯一索引（换句话说，如果这个在这个索引基础之上查询的结果多于一行）。</p>
<p>如果使用那个索引只匹配到非常少的行，也是不错的。</p>
<blockquote>
<p>ref can be used for indexed columns that are compared using the &#x3D; or &lt;&#x3D;&gt; operator. In the following examples, MySQL can use a ref join to process ref_table:</p>
</blockquote>
<p>在对已经建立索引列进行<code>=</code>或者<code>&lt;=&gt;</code>操作的时候，<code>ref</code>会被使用到。与<code>eq_ref</code>不同的是匹配到了多行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 根据索引（非主键，非唯一索引），匹配到多行</span><br><span class="line">SELECT * FROM ref_table WHERE key_column=expr;</span><br><span class="line"></span><br><span class="line"># 多表关联查询，单个索引，多行匹配</span><br><span class="line">SELECT * FROM ref_table,other_table</span><br><span class="line">  WHERE ref_table.key_column=other_table.column;</span><br><span class="line"></span><br><span class="line"># 多表关联查询，联合索引，多行匹配</span><br><span class="line">SELECT * FROM ref_table,other_table</span><br><span class="line">  WHERE ref_table.key_column_part1=other_table.column</span><br><span class="line">  AND ref_table.key_column_part2=1;</span><br></pre></td></tr></table></figure>

<h6 id="range"><a href="#range" class="headerlink" title="range"></a>range</h6><blockquote>
<p>Only rows that are in a given range are retrieved, using an index to select the rows. The key column in the output row indicates which index is used. The key_len contains the longest key part that was used. The ref column is NULL for this type.</p>
</blockquote>
<p>只有给定范围内的行才能被检索，使用索引来查询出多行。 输出行中的类决定了会使用哪个索引。 <code>key_len</code>列表示使用的最长的 key 部分。 这个类型的<code>ref</code>列是NULL。</p>
<p><strong>range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 &#x3D;, &lt;&gt;, &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, IS NULL, &lt;&#x3D;&gt;, BETWEEN, IN() 操作中.当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.</strong></p>
<blockquote>
<p>range can be used when a key column is compared to a constant using any of the &#x3D;, &lt;&gt;, &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, IS NULL, &lt;&#x3D;&gt;, BETWEEN, or IN() operators:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 常量比较，可能多行（但是这里的例子和上面 ref 的第一个例子不一样吗？）</span><br><span class="line">SELECT * FROM tbl_name</span><br><span class="line">  WHERE key_column = 10;</span><br><span class="line"></span><br><span class="line"># 范围查找</span><br><span class="line">SELECT * FROM tbl_name</span><br><span class="line">  WHERE key_column BETWEEN 10 and 20;</span><br><span class="line"></span><br><span class="line"># 范围查找</span><br><span class="line">SELECT * FROM tbl_name</span><br><span class="line">  WHERE key_column IN (10,20,30);</span><br><span class="line"></span><br><span class="line"># 多条件加范围查找</span><br><span class="line">SELECT * FROM tbl_name</span><br><span class="line">  WHERE key_part1 = 10 AND key_part2 IN (10,20,30);</span><br></pre></td></tr></table></figure>

<h6 id="index"><a href="#index" class="headerlink" title="index"></a>index</h6><blockquote>
<p>The index join type is the same as ALL, except that the index tree is scanned. This occurs two ways:</p>
<ol>
<li>If the index is a covering index for the queries and can be used to satisfy all data required from the table, only the index tree is scanned. In this case, the Extra column says Using index. An index-only scan usually is faster than ALL because the size of the index usually is smaller than the table data.</li>
<li>A full table scan is performed using reads from the index to look up data rows in index order. Uses index does not appear in the Extra column.</li>
</ol>
</blockquote>
<p><code>index</code>类型和<code>ALL</code>类型一样，区别就是<code>index</code>类型是扫描的索引树。以下两种情况会触发：</p>
<ol>
<li>如果索引是查询的覆盖索引，就是说索引查询的数据可以满足查询中所需的所有数据，则只扫描索引树，不需要回表查询。 在这种情况下，explain 的 <code>Extra</code> 列的结果是 <code>Using index</code>。仅索引扫描通常比ALL快，因为索引的大小通常小于表数据。</li>
<li>全表扫描会按索引的顺序来查找数据行。使用索引不会出现在<code>Extra</code>列中。</li>
</ol>
<p><strong>例如查询索引列的全部数据</strong></p>
<h6 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a>ALL</h6><blockquote>
<p>A full table scan is done for each combination of rows from the previous tables. This is normally not good if the table is the first table not marked const, and usually very bad in all other cases. Normally, you can avoid ALL by adding indexes that enable row retrieval from the table based on constant values or column values from earlier tables.</p>
</blockquote>
<p>全表扫描就不用看了，赶快优化吧。</p>
<h3 id="索引失效分析"><a href="#索引失效分析" class="headerlink" title="索引失效分析"></a>索引失效分析</h3><h4 id="偶现"><a href="#偶现" class="headerlink" title="偶现"></a>偶现</h4><h4 id="必现"><a href="#必现" class="headerlink" title="必现"></a>必现</h4><ul>
<li>like 的错误使用<ul>
<li>like语句要使索引生效，like后不能以%开始，也就是说 （like %字段名%） 、（like %字段名）这类语句会使索引失效，而（like 字段名）、（like 字段名%）这类语句索引是可以正常使用。</li>
</ul>
</li>
</ul>
<h2 id="MYSQL5-6的索引小优化"><a href="#MYSQL5-6的索引小优化" class="headerlink" title="MYSQL5.6的索引小优化"></a>MYSQL5.6的索引小优化</h2><h3 id="MRR-multi-range-read"><a href="#MRR-multi-range-read" class="headerlink" title="MRR(multi range read)"></a>MRR(multi range read)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看是否开启</span><br><span class="line">select @@optimizer_switch;</span><br></pre></td></tr></table></figure>

<h3 id="Index-Condition-Pushdown-索引下推"><a href="#Index-Condition-Pushdown-索引下推" class="headerlink" title="Index Condition Pushdown 索引下推"></a>Index Condition Pushdown 索引下推</h3><p>从mysql 5.6 开始支持，之前的 mysql 数据库版本不支持索引下推。不支持时，在根据索引查询时，首先根据索引查找记录，然后根据 where 语句过滤记录。在支持索引下推后，mysql 数据库会在取出索引的同时，判断是否可以进行 where 条件过滤。</p>
<p><strong>可以简单理解有两层， sql server 和 存储引擎层</strong></p>
<p>第一个查询可以使用索引下推， 如下面举例，那么使用 day 索引查询，使用 name（由于使用这种like的写法导致索引失效） 做过滤。如果在5.6 以前，没有索引下推。那么引擎层就把 所以 查出来的数据全部返回给 sql server， sql server 再通过 name 来过滤。仔细想想，和覆盖索引的原理实际上有几分相似。Using index condition 表示使用了索引下推。</p>
<p>第二个查询不能使用索引下推，因为没有 day + num 的索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 查询是否开启 默认是开启的</span><br><span class="line">select @@optimizer_switch;</span><br><span class="line"></span><br><span class="line"># 设置</span><br><span class="line">set optimizer_swithch=&#x27;index_condition_pushdown=off&#x27;;</span><br><span class="line"></span><br><span class="line"># 此处使用了索引下推</span><br><span class="line">explain select * from mytable where day &gt; 95 and day &lt; 99 and name like &quot;%percy%&quot;;</span><br><span class="line"></span><br><span class="line"># 此处没有使用索引下推， 需要 sql server 拿到数据后过滤</span><br><span class="line">explain select * from mytable where day &gt; 95 and day &lt; 99 and num &gt; 100;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>mytable</td>
<td>NULL</td>
<td>range</td>
<td>day_name_key</td>
<td>day_name_key</td>
<td>5</td>
<td>NULL</td>
<td>900</td>
<td>11.11</td>
<td>Using index condition</td>
</tr>
<tr>
<td>1</td>
<td>SIMPLE</td>
<td>mytable</td>
<td>NULL</td>
<td>range</td>
<td>day_name_key</td>
<td>day_name_key</td>
<td>5</td>
<td>NULL</td>
<td>900</td>
<td>33.33</td>
<td>Using index condition; Using where</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000003832312">索引分类</a></p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/whys-the-design-mongodb-b-tree/">为什么 MongoDB 使用 B 树</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/192883190">知乎文章， msyql 面试</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904017332535304">索引下推</a></p>
<p><a target="_blank" rel="noopener" href="https://mengkang.net/1124.html">explain type</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008131735">explain type 使用</a></p>
<p>《MySQL技术内幕(InnoDB存储引擎)第2版》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Percy"
      src="https://ivalue2333.github.io/percy/images/percy.jpg">
  <p class="site-author-name" itemprop="name">Percy</p>
  <div class="site-description" itemprop="description">IOT2014</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">156</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">194</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Percy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
