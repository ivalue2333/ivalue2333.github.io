<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="IOT2014">
<meta property="og:type" content="website">
<meta property="og:title" content="blog | percy">
<meta property="og:url" content="http://example.com/page/10/index.html">
<meta property="og:site_name" content="blog | percy">
<meta property="og:description" content="IOT2014">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Percy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>blog | percy</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blog | percy</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/08/14/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B%E4%B9%8Bredis%E9%9B%86%E7%BE%A4%E4%B9%8B%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/14/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B%E4%B9%8Bredis%E9%9B%86%E7%BE%A4%E4%B9%8B%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">分布式系统实例之redis集群之集群搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-14 19:59:01" itemprop="dateCreated datePublished" datetime="2020-08-14T19:59:01+08:00">2020-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="主从模式（master-x2F-slaver）"><a href="#主从模式（master-x2F-slaver）" class="headerlink" title="主从模式（master&#x2F;slaver）"></a>主从模式（master&#x2F;slaver）</h2><p>redis的主从模式，使用异步复制，slave节点异步从master节点复制数据，master节点提供读写服务，slave节点只提供读服务（这个是默认配置，可以通过修改配置文件 slave-read-only 控制）。<strong>master节点可以有多个从节点。</strong>配置一个slave节点只需要在redis.conf文件中指定 slaveof master-ip master-port 即可。</p>
<h3 id="从节点开启主从复制，有3种方式："><a href="#从节点开启主从复制，有3种方式：" class="headerlink" title="从节点开启主从复制，有3种方式："></a>从节点开启主从复制，有3种方式：</h3><p><code>slaveof 192.168.81.135 6379</code></p>
<ul>
<li><strong>配置文件</strong><ul>
<li>在从服务器的配置文件中加入：slaveof<masterip><masterport></li>
</ul>
</li>
<li><strong>启动命令</strong><ul>
<li>redis-server启动命令后加入：slaveof<masterip><masterport></li>
</ul>
</li>
<li><strong>客户端命令</strong><ul>
<li>Redis服务器启动后直接通过客户端执行命令：slaveof<masterip><masterport>，则该Redis实例成为从节点。</li>
</ul>
</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p><code>vi master-6739.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">port 6379</span><br><span class="line">logfile &quot;6379.log&quot;</span><br><span class="line">dbfilename &quot;dump-6379.rdb&quot;</span><br><span class="line">daemonize yes</span><br><span class="line">rdbcompression yes</span><br></pre></td></tr></table></figure>

<p><code>vi slave-6380.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">port 6380</span><br><span class="line">logfile &quot;6380.log&quot;</span><br><span class="line">dbfilename &quot;dump-6380.rdb&quot;</span><br><span class="line">daemonize yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">slaveof 192.168.81.135 6379</span><br></pre></td></tr></table></figure>

<p><em>master-6739.conf，为主节点配置文件，slave-6380.conf，slave-6381.conf为从节点配置文件</em><br><em>在从节点的配置文件中使用：slaveof 指定master节点</em></p>
<h4 id="docker-部署"><a href="#docker-部署" class="headerlink" title="docker 部署"></a>docker 部署</h4><p>参看： go-mod&#x2F;k8s&#x2F;docker&#x2F;redis</p>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">|root@zjk-qa-k8s-node010 /data/percy/redis-5.0.9</span><br><span class="line">|&gt;# src/redis-cli -p 7379</span><br><span class="line">127.0.0.1:7379&gt; set name percy</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7379&gt; exit</span><br><span class="line">|root@zjk-qa-k8s-node010 /data/percy/redis-5.0.9</span><br><span class="line">|&gt;# src/redis-cli -p 7380</span><br><span class="line">127.0.0.1:7380&gt; get name</span><br><span class="line">&quot;percy&quot;</span><br><span class="line">127.0.0.1:7380&gt; set name2 percy2</span><br><span class="line">(error) READONLY You can&#x27;t write against a read only replica.  </span><br><span class="line">127.0.0.1:7380&gt; </span><br></pre></td></tr></table></figure>

<ul>
<li>主节点写入的数据，从节点可以读取</li>
<li>从节点默认不能写数据</li>
</ul>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h4 id="数据丢失"><a href="#数据丢失" class="headerlink" title="数据丢失"></a>数据丢失</h4><p>master服务挂了之后，重启服务后，slave节点会与master节点进行一次完整的重同步操作，所以由于master节点没有持久化，就导致slave节点上的数据也会丢失掉。所以在配置了Redis的主从模式的时候，应该打开主服务器的持久化功能。到这，redis的主从模式就已经完成了。</p>
<h4 id="谈谈我认为主从模式的必要性："><a href="#谈谈我认为主从模式的必要性：" class="headerlink" title="谈谈我认为主从模式的必要性："></a>谈谈我认为主从模式的必要性：</h4><p>主从模式的一个作用是备份数据，这样当一个节点损坏（指不可恢复的硬件损坏）时，数据因为有备份，可以方便恢复。<br>另一个作用是负载均衡，所有客户端都访问一个节点肯定会影响Redis工作效率，有了主从以后，查询操作就可以通过查询从节点来完成。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>一个Master可以有多个Slaves </p>
</li>
<li><p>默认配置下，master节点可以进行读和写，slave节点只能进行读操作，写操作被禁止 不要修改配置让slave节点支持写操作，没有意义，</p>
<ul>
<li><p>原因一，写入的数据不会被同步到其他节点；</p>
</li>
<li><p>原因二，当master节点修改同一条数据后，slave节点的数据会被覆盖掉</p>
</li>
</ul>
</li>
<li><p>slave节点挂了不影响其他slave节点的读和master节点的读和写，重新启动后会将数据从master节点同步过来 </p>
</li>
<li><p>master节点挂了以后，不影响slave节点的读，Redis将不再提供写服务，master节点启动后Redis将重新对外提供写服务。 </p>
</li>
<li><p>master节点挂了以后，不会将slave节点重新选一个master</p>
</li>
</ul>
<h4 id="主从节点的缺点"><a href="#主从节点的缺点" class="headerlink" title="主从节点的缺点"></a>主从节点的缺点</h4><p>master节点挂了以后，redis就不能对外提供写服务了，因为剩下的slave不能成为master<br>这个缺点影响是很大的，尤其是对生产环境来说，是一刻都不能停止服务的，所以一般的生产坏境是不会单单只有主从模式的。所以有了下面的sentinel模式。</p>
<h2 id="sentinel模式-（哨兵模式）"><a href="#sentinel模式-（哨兵模式）" class="headerlink" title="sentinel模式 （哨兵模式）"></a>sentinel模式 （哨兵模式）</h2><p>Redis哨兵模式，用现在流行的话可以说就是一个“哨兵机器人”，给“哨兵机器人”进行相应的配置之后，这个”机器人”可以7*24小时工作，它能能够自动帮助你做一些事情，如监控，提醒，自动处理故障等。</p>
<p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance），Redis 的 Sentinel 为Redis提供了高可用性。使用哨兵模式创建一个可以不用人为干预而应对各种故障的Redis部署。</p>
<p>该系统执行以下三个任务：</p>
<ul>
<li>监控（Monitoring）：Sentinel会不断地检查你的主服务器和从服务器是否允许正常。</li>
<li>提醒（Notification）：当被监控的某个Redis服务器出现问题时，Sentinel可以通过API向管理员或者其他应用程序发送通知。</li>
<li>自动故障迁移（Automatic failover）: <ul>
<li>（1）当一个主服务器不能正常工作时，Sentinel会开始一次自动故障迁移操作，他会将失效主服务器的其中一个从服务器升级为新的主服务器，并让失效主服务器的其他从服务器改为复制新的主服务器</li>
<li>（2）客户端试图连接失败的主服务器时，集群也会向客服端返回新主服务器的地址，集群可以使用新主服务器代替失效服务器。</li>
</ul>
</li>
</ul>
<h3 id="sentinel的分布式特性"><a href="#sentinel的分布式特性" class="headerlink" title="sentinel的分布式特性"></a>sentinel的分布式特性</h3><p>Redis Sentinel 是一个分布式系统， 你可以在一个架构中运行多个 Sentinel 进程（progress）， 这些进程使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息， 并使用投票协议（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器。</p>
<p>单个sentinel进程来监控redis集群是不可靠的，当sentinel进程宕掉后(sentinel本身也有单点问题，single-point-of-failure)整个集群系统将无法按照预期的方式运行。所以有必要将sentinel集群，一个健壮的部署至少需要三个哨兵实例。</p>
<h3 id="docker-部署-1"><a href="#docker-部署-1" class="headerlink" title="docker 部署"></a>docker 部署</h3><p>参看： go-mod&#x2F;k8s&#x2F;docker&#x2F;redis</p>
<h3 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|&gt;# redis-cli -h 127.0.0.1 -p 27379 info sentinel</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Sentinel</span></span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">sentinel_simulate_failure_flags:0</span><br><span class="line">master0:name=mymaster,status=ok,address=127.0.0.1:7379,slaves=2,sentinels=1</span><br></pre></td></tr></table></figure>

<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">shutdown 主节点</span></span><br><span class="line">|&gt;# redis-cli -p 7379</span><br><span class="line">127.0.0.1:7379&gt; shutdown</span><br><span class="line">not connected&gt; exit</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">7380 切换为了主节点， 可以写入数据</span></span><br><span class="line">|&gt;# redis-cli -p 7380</span><br><span class="line">127.0.0.1:7380&gt; set age 12</span><br></pre></td></tr></table></figure>

<h2 id="cluster模式"><a href="#cluster模式" class="headerlink" title="cluster模式"></a>cluster模式</h2><p>Redis Cluster是Redis官方的一个高可用分布式解决方案。Redis Cluster中共有2 ^ 14（16384）个槽，创建集群后，需要将这些槽均分给各个节点。</p>
<p>cluster可以说是sentinel和主从模式的结合体，通过cluster可以实现主从和master重选功能，所以如果配置两个副本三个分片的话，就需要六个Redis实例。 </p>
<p>因为Redis的数据是根据一定规则分配到cluster的不同机器的，当数据量过大时，可以新增机器进行扩容这种模式适合数据量巨大的缓存要求，当数据量不是很大使用sentinel即可。</p>
<h3 id="节点配置"><a href="#节点配置" class="headerlink" title="节点配置"></a>节点配置</h3><table>
<thead>
<tr>
<th>节点名称</th>
<th>端口号</th>
<th>主&#x2F;从节点</th>
<th>复制的节点</th>
</tr>
</thead>
<tbody><tr>
<td>redis-7005</td>
<td>7005</td>
<td>主节点</td>
<td>—</td>
</tr>
<tr>
<td>redis-7004</td>
<td>7004</td>
<td>主节点</td>
<td>—</td>
</tr>
<tr>
<td>redis-7003</td>
<td>7003</td>
<td>主节点</td>
<td>—</td>
</tr>
<tr>
<td>redis-7002</td>
<td>7002</td>
<td>从节点</td>
<td>redis-7003</td>
</tr>
<tr>
<td>redis-7001</td>
<td>7001</td>
<td>从节点</td>
<td>redis-7005</td>
</tr>
<tr>
<td>redis-7000</td>
<td>7000</td>
<td>从节点</td>
<td>redis-7004</td>
</tr>
</tbody></table>
<h3 id="docker-部署-2"><a href="#docker-部署-2" class="headerlink" title="docker 部署"></a>docker 部署</h3><p>参看： go-mod&#x2F;k8s&#x2F;docker&#x2F;redis&#x2F;cluster&#x2F;v2</p>
<h4 id="查看启动"><a href="#查看启动" class="headerlink" title="查看启动"></a>查看启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|&gt;# docker logs 026b1864a49c</span><br><span class="line">1:C 18 Aug 2020 03:37:00.175 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">1:C 18 Aug 2020 03:37:00.175 # Redis version=6.0.6, bits=64, commit=00000000, modified=0, pid=1, just started</span><br><span class="line">1:C 18 Aug 2020 03:37:00.175 # Configuration loaded</span><br><span class="line">1:M 18 Aug 2020 03:37:00.176 * No cluster configuration found, I&#x27;m 4efdfb5b0dadeec44d23f97038e5d29a01e000b0</span><br></pre></td></tr></table></figure>

<p>可以看到Redis在集群模式下启动，因为初始的时候没有集群配置，所以自动创建了配置(文件名就是在redis-6379.conf中指定的)。</p>
<p>然后来看一下自动创建的及集群配置。这个文件记录了集群的初始状态，前面那个很长的字符串就是节点ID。</p>
<h3 id="cluster-模式下的-smart-client"><a href="#cluster-模式下的-smart-client" class="headerlink" title="cluster 模式下的 smart client"></a>cluster 模式下的 smart client</h3><p>可以看到 set name 时， 不管你在哪个节点， cluster 都会告诉你，正确的节点是哪一个，并且不会帮你执行这个操作， client 必须 聪明的拿到正确节点的地址，然后连接上正确的节点上去执行 set get.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">|root@zjk-qa-k8s-node010 /tmp/percy/v2</span><br><span class="line">|&gt;# redis-cli -p 7000</span><br><span class="line">127.0.0.1:7000&gt; set name percy</span><br><span class="line">(error) MOVED 5798 127.0.0.1:7001</span><br><span class="line">127.0.0.1:7000&gt; </span><br><span class="line">|root@zjk-qa-k8s-node010 /tmp/percy/v2</span><br><span class="line">|&gt;# redis-cli -p 7001</span><br><span class="line">127.0.0.1:7001&gt; set name percy</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7001&gt; </span><br><span class="line">|root@zjk-qa-k8s-node010 /tmp/percy/v2</span><br><span class="line">|&gt;# redis-cli -p 7002</span><br><span class="line">127.0.0.1:7002&gt; get name</span><br><span class="line">(error) MOVED 5798 127.0.0.1:7001</span><br><span class="line">127.0.0.1:7002&gt; </span><br><span class="line">|root@zjk-qa-k8s-node010 /tmp/percy/v2</span><br><span class="line">|&gt;# redis-cli -p 7001</span><br><span class="line">127.0.0.1:7001&gt; get name</span><br><span class="line">&quot;percy&quot;</span><br><span class="line">127.0.0.1:7001&gt;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022702973">redis主从及哨兵</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35457078/article/details/100999417">docker搭建redis集群</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/08/11/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%88%86%E5%8C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/11/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%88%86%E5%8C%BA/" class="post-title-link" itemprop="url">分布式系统之数据分区</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-11 10:49:39" itemprop="dateCreated datePublished" datetime="2020-08-11T10:49:39+08:00">2020-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>分布式数据处理系统第一个要解决的问题就是如何将数据进行拆分，利用多台计算机处理大规模数据。对于数据量很大的数据集，单机无法保存或者处理时，通过对数据集进行水平拆分，将不同的数据子集存放到不同的处理节点，这种对数据进行拆分的方式叫做 <strong>分区（partition）</strong>。</p>
<p>不同数据库中对分区的名称定义有所差异，<strong>有些称之为分区（partition），有些称之为分片（sharding），还有一些称之为区域（Region）</strong>，但是其含义都是基本相同的。需要注意的是，这里的分区跟 CAP 中的网络分区和单机的单机分区表没有关系。</p>
<p>分区<code>partition</code>在不同数据库有不同的称谓</p>
<ul>
<li><code>Shard</code> [分片] <code>MongoDB</code>,<code>Elasticsearch</code></li>
<li><code>Region</code>[区域] <code>HBase</code></li>
<li><code>tablet</code>[表块] <code>BigTable</code></li>
<li><code>vnode</code> [虚节点] <code>Cassandra</code>,<code>Riak</code></li>
</ul>
<p>对于大部分实现方案，数据被分区后，各个分区由不同的独立、完整的数据库进行保存和处理，然后由一个或多个协调节点进行请求的路由处理。</p>
<ul>
<li><strong>CN</strong>: 协调节点（coordinator node），根据分区策略对数据做分区处理。</li>
<li><strong>DN</strong>: 数据节点（data node），用于保存数据，独立维护自己的元数据，通常都是完整的数据库，每个 DN 保存一个数据子集，每个数据子集都是一个分区。</li>
</ul>
<h2 id="分区需要考虑的问题"><a href="#分区需要考虑的问题" class="headerlink" title="分区需要考虑的问题"></a>分区需要考虑的问题</h2><ol>
<li>具体如何划分原始数据集？</li>
<li>当原问题的规模变大的时候，能否通过增加节点来动态适应？</li>
<li>当某个节点故障的时候，能否将该节点上的任务均衡的分摊到其他节点？</li>
<li>对于可修改的数据（比如数据库数据），如果某节点数据量变大，能否以及如何将部分数据迁移到其他负载较小的节点，及达到动态均衡的效果？</li>
<li>元数据的管理（即数据与物理节点的对应关系）规模？元数据更新的频率以及复杂度？</li>
</ol>
<h2 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h2><p>对于一个分布式数据处理系统，将数据分布到多个分区有两种比较典型的方案：</p>
<ol>
<li>一种是根据键做哈希，根据哈希值选择对应的数据节点。</li>
<li>另一种是范围分区，某一段连续的键都保存在一个数据节点上。</li>
<li>还有一种是一致性哈希， 将机器计算哈希值映射到一个[0, 2^32-1]的环上，数据键也做哈希映射</li>
</ol>
<h3 id="哈希分区-partition-hashing"><a href="#哈希分区-partition-hashing" class="headerlink" title="哈希分区 (partition hashing)"></a>哈希分区 (partition hashing)</h3><p>哈希分区是最常见的数据分区方式，通过按照数据的key、或者用户指定的一个或者多个字段计算哈希，然后将计算后的哈希与计算节点进行映射，从而将不同哈希值的数据分布到不同节点上。</p>
<p>例如，有3条记录<code>(key1, value1), (key2, value2), (key3, value3)</code> 通过对键进行计算哈希（对 key 进行 md5哈希，然后取前两个字符作为哈希值），哈希桶个数255个，当前有两个分区，偶数哈希值放到分区0，奇数哈希值放到分区1，计算后的数据分布如下图所示。</p>
<p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/c6b39ef728bd44f4aec762368f5317e2.png"></p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>哈希分区的一个优点是，<strong>保存的元数据很简单，只需要保存桶与分区的映射关系即可</strong>。但是缺点也很明显，可扩展性差，如果增加一个节点进行扩容，<strong>则需要对所有数据进行重新计算哈希</strong>，然后对数据进行重新分布，对于均匀分布的哈希函数而言，一般而言，在扩容时每个分区都需要扩容，通过成倍增加节点，然后通过调整映射关系，重新分布一半的数据到新分区。另一个缺点是，如果哈希函数选择不合理，则<strong>很容易出现数据倾斜</strong>，导致某个分区数据量很大。</p>
<h3 id="范围分区-（partition-range）"><a href="#范围分区-（partition-range）" class="headerlink" title="范围分区 （partition range）"></a>范围分区 （partition range）</h3><p>按数据范围分区是另一个常见的分布方式，通过按照数据的key、或者用户指定的一个或者多个字段计算所在的分区范围，从而确定数据所在的分区。</p>
<p>例如，一个简单的例子：key 小于等于 r 的分布到分区0，key 小于等于 z 的数据分布到分区1，三条记录<code>(a, value1), (r, value2), (x, value3)</code>则分别分布到了分区0，分区0，分区1中。</p>
<p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/a7d3c50372804fbeaa0c25fe637c714c.png"></p>
<p>与哈希分布不一样的是，<strong>范围分区需要记录所有的数据分布情况</strong>，可能会有大量元数据。范围分区还有一个问题是，对于特定的数据处理请求可能会造成<strong>热点访问</strong>，例如我们按时间进行范围分区，每天的数据保存在一个分区上，则对某一天的数据查询处理，只能在这一个分区上进行，无法利用多分区的并行处理能力，这时就要求应用开发人员定义分片特征时，仔细选择特征字段进行范围分区。</p>
<h3 id="一致性哈希分区-consistent-hashing"><a href="#一致性哈希分区-consistent-hashing" class="headerlink" title="一致性哈希分区(consistent hashing)"></a>一致性哈希分区(consistent hashing)</h3><p>一致性哈希要解决的问题是集群的动态扩容问题。如哈希分区， 当集群增加节点时，最多可能所有的节点都需要迁移，这么大量的数据迁移是很难在工程上被接受的。所以有了一致性哈希算法。</p>
<p>一致性Hash的基本思想就是分两步走：</p>
<ul>
<li>把object求hash（这一步和之前相同）；</li>
<li>把cache也求hash，然后把object和cache的hash值放入一个<strong>环形hash空间</strong>，通过一定的规则决定每个object落在哪一个cache中。</li>
</ul>
<p>一致性哈希算法的基本实现原理是将机器节点和key值都按照一样的hash算法映射到一个0~2^32的圆环上。当有一个写入缓存的请求到来时，计算Key值k对应的哈希值Hash(k)，如果该值正好对应之前某个机器节点的Hash值，则直接写入该机器节点，如果没有对应的机器节点，则顺时针查找下一个节点，进行写入，如果超过2^32还没找到对应节点，则从0开始查找(因为是环状结构)。</p>
<p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/70c69b2a3a7f484db5f67b0ff2e79336.jpg"></p>
<h4 id="机器伸缩"><a href="#机器伸缩" class="headerlink" title="机器伸缩"></a>机器伸缩</h4><p>经过一致性哈希算法散列之后，当有新的机器加入时，将只影响一台机器的存储情况，例如新加入的节点H的散列在B与C之间，则原先由C处理的一些数据可能将移至H处理，而其他所有节点的处理情况都将保持不变，因此表现出很好的单调性。而如果删除一台机器，例如删除C节点，此时原来由C处理的数据将移至D节点，而其它节点的处理情况仍然不变。而由于在机器节点散列和缓冲内容散列时都采用了同一种散列算法，因此也很好得降低了分散性和负载。而通过引入虚拟节点的方式，也大大提高了平衡性。</p>
<h4 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h4><p>另外具体机器映射时，还可以根据处理能力不同，<strong>将一个实体节点映射到多个虚拟节点， 实际上很像加权负载</strong>。</p>
<p>“虚拟节点”的hash计算可以采用对应节点的IP地址加数字后缀的方式。例如假设NODE1的IP地址为192.168.1.100。引入“虚拟节点”前，计算 cache A 的 hash 值：</p>
<blockquote>
<p>Hash(“192.168.1.100”);</p>
</blockquote>
<p>引入“虚拟节点”后，计算“虚拟节”点NODE1-1和NODE1-2的hash值：</p>
<blockquote>
<p>Hash(“192.168.1.100#1”); &#x2F;&#x2F; NODE1-1</p>
<p>Hash(“192.168.1.100#2”); &#x2F;&#x2F; NODE1-2</p>
</blockquote>
<h4 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h4><p><a target="_blank" rel="noopener" href="https://github.com/ivalue2333/java-framework">https://github.com/ivalue2333/java-framework</a></p>
<h3 id="其他策略"><a href="#其他策略" class="headerlink" title="其他策略"></a>其他策略</h3><ul>
<li>轮询：新增数据循环插入到不同的分区，每个分区数据均匀，但是对于数据请求路由，并不能根据请求的条件获取到所在的分区，查询或者更新时需要将请求发送给所有分区节点。</li>
<li>列表：指定数据分布方式，对于某个值指定所在的分区，例如，<code>(1, 2, 4) in P0</code>，<code>(3, 5) in P1</code>。</li>
<li>动态分区：单独的定位器服务跟踪节点之间的分区，动态分区对数据分布不均匀的数据更适用。</li>
</ul>
<h2 id="分区的问题"><a href="#分区的问题" class="headerlink" title="分区的问题"></a>分区的问题</h2><p>对于选择通过多个分区做扩展的分布式数据库而言，有几个通用的问题需要解决，首先就是<strong>跨分区的一致性保证</strong>，大部分常用系统是通过 2PC 来解决分布式事务一致性问题，但是 2PC 在一些故障场景下，可能需要人工干涉才能解决，有些数据库甚至不提供一致性保证。其次就是跨分区的连接、聚合等操作等，有些数据库则提供了对部分算子的优化，其它算子则通过较低性能的解决方案用于解决多分区的连接，在这种情况下，需要应用侧权衡是否适用于当前业务。</p>
<h2 id="数据路由"><a href="#数据路由" class="headerlink" title="数据路由"></a>数据路由</h2><p>上面我们介绍了将大数据集拆分到不同分区的策略，但是如何将用户的数据操作请求发送到对应分区呢？随着数据的重新分布，分区对应的节点也会随之发生变化。一般情况下，分区的路由信息需要由某个组件进行维护，根据不同维护路由信息组件不同，我们可以将常见的路由方式分成如下四种：</p>
<ol>
<li><strong>协调节点路由</strong>：协调组件维护路由信息，如果有多个协调组件，每个组件都需要保存相同的分区信息，保证客户端连接到任意协调组件时都可以正确进行请求的路由。对于 SQL 分区数据库，可能需要在执行 DDL 操作时，需要将DDL 操作信息发送到其它所有的协调节点，客户端连接到其它 CN 时也可以正确对数据进行路由。</li>
<li><strong>协调节点+源数据节点路由</strong>：元数据服务器保存路由信息，每次客户端从元数据服务器获取分区信息，或者订阅元数据信息，只要路由信息发生变化，则通知协调节点。<strong>例如 mongo</strong></li>
<li><strong>客户端路由</strong>：客户端直接访问分区数据，客户端保存了分区信息，客户端直接进行路由计算。<strong>例如 redis 的 cluster 集群</strong></li>
<li><strong>数据节点路由</strong>：分区节点直接提供路由支持，允许客户端连接任何分区。如果该节点恰巧拥有请求的分区，则它可以直接处理该请求；否则，它将请求转发到适当的节点，接收回复并传递给客户端。**例如 elasticsearch **</li>
</ol>
<p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/2ad8893a4d704f3b9f43f50900f9fe5c.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://iswade.github.io/articles/partition/">分区基础</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.huanghao.me/?p=14">一致性哈希</a></p>
<p><a target="_blank" rel="noopener" href="http://afghl.github.io/2016/11/19/implement-consistent-hashing.html">一致性哈希的 Java 实现</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/08/10/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/10/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" class="post-title-link" itemprop="url">分布式系统之负载均衡</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-10 20:23:12" itemprop="dateCreated datePublished" datetime="2020-08-10T20:23:12+08:00">2020-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="负载均衡-load-balance"><a href="#负载均衡-load-balance" class="headerlink" title="负载均衡 (load balance)"></a>负载均衡 (load balance)</h2><p>「负载均衡」是指，通过一定的算法使请求可以均匀的宠幸服务提供方，做到雨露均沾。市面上，软件硬件产品一大把，解决的最最核心的问题都是<strong>选谁</strong>。</p>
<p>按实现方式，可以分为硬件负载均衡（如 F5 、A10）、软件负载均衡（如 <strong>LVS、Nginx、HAProxy</strong>）、DNS 负载均衡。硬件负载均衡和 DNS 负载均衡我们不过多关注，重点看一下软件负载均衡。</p>
<p>软件负载均衡又分四层和七层负载均衡，四层负载均衡就是在网络层利用 IP 地址端口进行请求的转发，基本上就是起个转发分配作用。而七层负载均衡就是可以根据访问用户的 HTTP 请求头、URL 信息将请求转发到特定的主机。LVS 为四层负载均衡。Nginx、HAProxy 可四可七。</p>
<p>除了专用硬件和 Nginx 这种专业软件提供负载均衡外，在代码中直接实现也是种常见的方式。比如 Spring Cloud 体系中的 Ribbon 组件提供了轮询、随机、根据响应时间加权几种负载策略，比如使用 Memcached 集群时通常会在 client 中采用 hash 取模或者一致性哈希来使数据均匀分布。</p>
<h2 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h2><p>常见的有：随机，轮询，最小链接数，一致性哈希</p>
<h3 id="随机（Random）"><a href="#随机（Random）" class="headerlink" title="随机（Random）"></a>随机（Random）</h3><p>根据后端服务器列表的大小值来随机选择其中一台进行访问，代码如下：</p>
<p><strong>优点</strong>：实现简单，通过系统随机函数随机选择其中一台进行访问</p>
<p><strong>缺点</strong>：不适用后端机器承载能力不一致的情况</p>
<h3 id="权重随机（Weighted-Random）"><a href="#权重随机（Weighted-Random）" class="headerlink" title="权重随机（Weighted Random）"></a>权重随机（Weighted Random）</h3><p>各个节点带有不同的权重，虽然随机选择但是期望不同权重的节点被选择的几率不一样， 权重高的被选中的几率大，权重低的被选中的几率小。</p>
<p><strong>优点</strong>：实现简单，采用权重改变了被选中的概率；</p>
<p><strong>缺点</strong>：不适用后端机器承载能力不一致的情况。</p>
<h3 id="轮询（Round-Robin）"><a href="#轮询（Round-Robin）" class="headerlink" title="轮询（Round Robin）"></a>轮询（Round Robin）</h3><p>把所有待选择的机器看做是一个个的点，所有点串起来一个圆。想象一下，轮询就是对圆上的每一个点，顺时针遍历，在每个节点上停留一下。我们通过请求的次数 pos ，来实现顺时针选择。需要修改 pos 的线程，只有获取到锁才能对该值做修改，当该值大于等于服务器列表长度时，重新从 0 开始遍历，达到循环一周的目的。</p>
<p><strong>优点</strong>：相对来说请求可以做到绝对平衡；</p>
<p><strong>缺点</strong>：为了绝对平衡，需要保证 pos 修改时的互斥性，引入了同步锁会带来性能下降。</p>
<h3 id="权重轮训（Weighted-Round-Robin）"><a href="#权重轮训（Weighted-Round-Robin）" class="headerlink" title="权重轮训（Weighted Round Robin）"></a>权重轮训（Weighted Round Robin）</h3><p>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</p>
<h3 id="最小连接数（Least-Connections）"><a href="#最小连接数（Least-Connections）" class="headerlink" title="最小连接数（Least Connections）"></a>最小连接数（Least Connections）</h3><p>从已有的后端列表中，选择正在处理的连接数 &#x2F; 请求数最少的节点出来提供服务。既然要判断连接数 &#x2F; 请求数，<strong>那么每个节点都需要保存一个正在处理的连接数 &#x2F; 请求数的信息，然后选取节点的时候判断一下， 选择连接数最少的那个节点。</strong></p>
<p>首先找到服务提供者当前最小的活跃连接数，如果一个服务提供者的服务连接数比其他的都要小，则选择这个活跃连接数最小的服务提供者发起调用，如果存在多个服务提供者的活跃连接数，并且是最小的，则在这些服务提供者之间选择加权随机算法选择一个服务提供者。</p>
<p><strong>优点</strong>：根据服务器当前的请求处理情况，动态分配；</p>
<p><strong>缺点</strong>：算法实现相对复杂，需要监控服务器请求连接数。</p>
<h3 id="一致性哈希（Consistent-Hash）"><a href="#一致性哈希（Consistent-Hash）" class="headerlink" title="一致性哈希（Consistent Hash）"></a>一致性哈希（Consistent Hash）</h3><p>根据后端节点的某个固定属性计算 hash 值，然后把所有节点计算出来的 hash 值组成一个 hash 环。请求过来的时候根据请求的特征计算该特征的 hash 值（使用跟计算后端节点 hash 值相同的 hash 函数进行计算）， 然后顺时针查找 hash 环上的 hash 值，第一个比请求特征的 hash 值大的 hash 值所对应的节点即为被选中的节点。</p>
<p>某一部分节点发生故障时，或者新的节点动态的增加进来时都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</p>
<h4 id="虚拟哈希节点"><a href="#虚拟哈希节点" class="headerlink" title="虚拟哈希节点"></a>虚拟哈希节点</h4><p>上面的 hash 环有一个问题，就是节点的 hash 值不一定是均匀的分布在 hash 环上的，这样就会导致部分节点上承受太多的请求。解决办法是引入虚拟节点：每个节点重复 n 次，把这些虚拟节点的 hash 值（跟实际节点的 hash 值不一样，也就是说需要在节点属性中加点东西保证每个虚拟节点跟实际节点的 hash 值不一样，互相之间也要不一样）也加入到 hash 环中以此来保证分布更均匀。</p>
<p><strong>优点</strong>：具有较好的容错性和可扩展性，节点加入或者去除，只有少量数据需要迁移；</p>
<p><strong>缺点</strong>：没有解决热点问题，会出现部分节点需要处理大量请求。</p>
<h3 id="IP地址散列"><a href="#IP地址散列" class="headerlink" title="IP地址散列"></a>IP地址散列</h3><p>通过管理发送方IP和目的地IP地址的散列，将来自同一发送方的分组(或发送至同一目的地的分组)统一转发到相同服务器的算法。当客户端有一系列业务需要处理而必须和一个服务器反复通信时，该算法能够以流(会话)为单位，保证来自相同客户端的通信能够一直在同一服务器中进行处理。</p>
<p><strong>优点</strong>：xxx</p>
<p><strong>缺点</strong>：xxx</p>
<h3 id="URL散列"><a href="#URL散列" class="headerlink" title="URL散列"></a>URL散列</h3><p>过管理客户端请求URL信息的散列，将发送至相同URL的请求转发至同一服务器的算法。\</p>
<h2 id="Nginx-使用的负载均衡算法"><a href="#Nginx-使用的负载均衡算法" class="headerlink" title="Nginx 使用的负载均衡算法"></a>Nginx 使用的负载均衡算法</h2><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p> 默认就是</p>
<h3 id="加权轮询"><a href="#加权轮询" class="headerlink" title="加权轮询"></a>加权轮询</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> linuxidc&#123;       </span><br><span class="line">   <span class="attribute">server</span> <span class="number">10.0.0.77</span> weight=<span class="number">5</span>;       </span><br><span class="line">   <span class="attribute">server</span> <span class="number">10.0.0.88</span> weight=<span class="number">10</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> favresin&#123;      </span><br><span class="line">    ip_hash;      </span><br><span class="line">    <span class="attribute">server</span> <span class="number">10.0.0.10:8080</span>;       </span><br><span class="line">    <span class="attribute">server</span> <span class="number">10.0.0.11:8080</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fair（第三方）"><a href="#fair（第三方）" class="headerlink" title="fair（第三方）"></a>fair（第三方）</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照后端服务器的响应时间来分配请求，响应时间短的优先分配。 </span></span><br><span class="line"><span class="section">upstream</span> favresin&#123;            </span><br><span class="line">      <span class="attribute">server</span> <span class="number">10.0.0.10:8080</span>;       </span><br><span class="line">      <span class="attribute">server</span> <span class="number">10.0.0.11:8080</span>;       </span><br><span class="line">      fair; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="url-hash（第三方）"><a href="#url-hash（第三方）" class="headerlink" title="url_hash（第三方）"></a>url_hash（第三方）</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照访问url的hash结果来分配请求，每个固定的url访问同一个后端服务器。如果后端服务器是缓存时效率高。 </span></span><br><span class="line"><span class="section">upstream</span> resinserver&#123;       </span><br><span class="line">      <span class="attribute">server</span> <span class="number">10.0.0.10:7777</span>;       </span><br><span class="line">      <span class="attribute">server</span> <span class="number">10.0.0.11:8888</span>;       </span><br><span class="line">      <span class="attribute">hash</span> <span class="variable">$request_uri</span>;       </span><br><span class="line">      <span class="attribute">hash_method</span> crc32; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&mid=2651488837&idx=1&sn=40a59c9ed17dbe8dff945145190e5020&chksm=bd25ee3a8a52672c164956f296a781cbf0a3f5e0445d36fa640e9366de108ddda3320bd9e030&mpshare=1&scene=1&srcid=0810mYAgX9cUzEDIleni9TOl&sharer_sharetime=1597061897192&sharer_shareid=2728d3a0eb6a32c660939921ae4b72ce&key=1686459e41463dc8d209c25cf1a445095c4ce95c1fa42a17dc9f01210fc2755e0ce975901d943b0ff66d4c8185f2e8b102837e5e546e3b01ac8eadf142d2d75206ac7136adeeba117341c5e3f374cdfd&ascene=1&uin=MjQ3MzQ1MDUyNQ==&devicetype=Windows+10+x64&version=62090529&lang=zh_CN&exportkey=A+tT+vNTuN7Sdv8ljYPRPRU=&pass_ticket=Wk+npL0XlWEzSNt4gx2v4ustYJ3f8P1kgwjrld97j7/yLcJxWjwcdIys+Tt63ikm">微信文章</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903926731374599">掘金文章</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/08/09/redis/%E7%BC%93%E5%AD%98%E7%9A%84%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/09/redis/%E7%BC%93%E5%AD%98%E7%9A%84%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">缓存的常见概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-09 16:23:43" itemprop="dateCreated datePublished" datetime="2020-08-09T16:23:43+08:00">2020-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-21 18:53:07" itemprop="dateModified" datetime="2023-02-21T18:53:07+08:00">2023-02-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="简单归纳"><a href="#简单归纳" class="headerlink" title="简单归纳"></a>简单归纳</h2><ul>
<li>缓存雪崩： 同一时间大量 key 同时到期，导致 db 暴露于大量请求下</li>
<li>缓存穿透：在 db 中不存在的 key 总是不会被缓存， 导致 db 暴露于大量请求下</li>
<li>缓存击穿：热点 key 过期，导致 db 暴露于大量请求</li>
<li>热点缓存问题：热点key落到同一台机器上，导致机器负载，带宽不够用。</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="具体的问题及原因"><a href="#具体的问题及原因" class="headerlink" title="具体的问题及原因"></a>具体的问题及原因</h3><p>由于大量的 key 同时到期（<strong>在同一时刻出现大面积的缓存过期</strong>），导致所有的请求在短时间内直接请求到了数据库，这对于数据库来说是极其危险的。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><p>串行化就是在查询缓存未查到时，是有编程语言自带的锁，或者分布式锁，或者消息队列等，将这同一类的操作串行。但是这实际上在大并发的情况下是不适合的，因为这个会带来低吞吐，高延时的副作用</p>
<h4 id="设置随机的过期时间"><a href="#设置随机的过期时间" class="headerlink" title="设置随机的过期时间"></a>设置随机的过期时间</h4><p>这个很好理解，具体的操作可以是将 key 的过期时间设置为常数过期时间的一半再加上一个[0, 常数过期时间的]的随机数。</p>
<h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><p>简单点的二级缓存就是服务内存缓存加 redis 缓存，这主要是在极高并发情况下降低 redis 的查询频率， 内存缓存需要解决的难点就是 分布式部署下的内存缓存的更新问题（<strong>分布式节点间的通信问题， redis, mq 等的 pubsub 是一种解决思路</strong>）。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="具体的问题及原因-1"><a href="#具体的问题及原因-1" class="headerlink" title="具体的问题及原因"></a>具体的问题及原因</h3><p>缓存击穿的原因是一个高频 key（热点数据）， 在过期时间过期后， 导致这个 key 的请求全部请求到 db。</p>
<h3 id="解决法法"><a href="#解决法法" class="headerlink" title="解决法法"></a>解决法法</h3><h4 id="使用互斥锁-mutex-key"><a href="#使用互斥锁-mutex-key" class="headerlink" title="使用互斥锁(mutex key)"></a>使用互斥锁(mutex key)</h4><p>业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。</p>
<h4 id="数据不过期"><a href="#数据不过期" class="headerlink" title="数据不过期"></a>数据不过期</h4><p>设置热点数据永远不过期，有更新操作就更新缓存。</p>
<h4 id="缓存续约（借用分布式锁的概念）"><a href="#缓存续约（借用分布式锁的概念）" class="headerlink" title="缓存续约（借用分布式锁的概念）"></a>缓存续约（借用分布式锁的概念）</h4><p>使用一种机制，检查热点数据的过期时间，当距离过期时间较近时，更新缓存。</p>
<h4 id="限流（请求拒绝，-服务降级）"><a href="#限流（请求拒绝，-服务降级）" class="headerlink" title="限流（请求拒绝， 服务降级）"></a>限流（请求拒绝， 服务降级）</h4><p>当请求过高时，直接拒绝服务，保护服务被直接打死。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="具体的问题及原因-2"><a href="#具体的问题及原因-2" class="headerlink" title="具体的问题及原因"></a>具体的问题及原因</h3><p>缓存穿透是指用户查询数据，<strong>在数据库没有</strong>，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>布隆过滤器是一个具有极好的内存使用率的过滤器，它的作用是能判断一个 key 是否一定不存在。</p>
<h4 id="null-缓存值"><a href="#null-缓存值" class="headerlink" title="null 缓存值"></a>null 缓存值</h4><p>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓存中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴！</p>
<h2 id="热点缓存问题"><a href="#热点缓存问题" class="headerlink" title="热点缓存问题"></a>热点缓存问题</h2><h3 id="具体问题及原因"><a href="#具体问题及原因" class="headerlink" title="具体问题及原因"></a>具体问题及原因</h3><p>一个或多个热点key的超大请求量，而一个key只会被路由到一个缓存节点上，导致这个节点压力过大。会出现</p>
<ul>
<li>流量集中，达到物理网卡上限。</li>
<li>请求过多，缓存分片服务被打垮。</li>
<li>DB 击穿，引起业务雪崩。</li>
</ul>
<h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="服务加二级缓存（本地缓存）"><a href="#服务加二级缓存（本地缓存）" class="headerlink" title="服务加二级缓存（本地缓存）"></a>服务加二级缓存（本地缓存）</h4><p>服务自己做一份内存缓存。但是需要提前知道热点key， 以及本地的内存容量有限</p>
<h3 id="server-gt-proxy-gt-redis-server"><a href="#server-gt-proxy-gt-redis-server" class="headerlink" title="server -&gt; proxy -&gt; redis server"></a>server -&gt; proxy -&gt; redis server</h3><p>proxy 做本地缓存，本质是一样的，但是 proxy 可以做热点缓存感知的工作</p>
<h3 id="single-inflight-算法"><a href="#single-inflight-算法" class="headerlink" title="single inflight 算法"></a>single inflight 算法</h3><p>避免同一时间大量请求到 redis server</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&mid=2651489177&idx=1&sn=bc28ee6f41e9dfff39cd4df69ab45870&chksm=bd25efe68a5266f00ee5c06727a409d22c6bb840453e5f6b1803d3f2d62da25b95ebcbe1ad56&mpshare=1&scene=1&srcid=0809kqr4c2EBNaioV5BV0oAv&sharer_sharetime=1596963459797&sharer_shareid=2728d3a0eb6a32c660939921ae4b72ce&key=1686459e41463dc889405fde2e346ac0201860f5c1118c59e1ed8a51201ec13aa709eff591953255aa70f42231a4e02f23f1d73c96728cd2e994ae9cdb9a48f47863b20a0e02e350c23598dccf8918ce&ascene=1&uin=MjQ3MzQ1MDUyNQ==&devicetype=Windows+10+x64&version=62090529&lang=zh_CN&exportkey=A6rEZP1LIzY0oI/etBrsvGg=&pass_ticket=hSpfNxYsvdfPIvJIHeGGeHwSujQJJLNrH1i3JGaapMyFIeaQCb4LfxNVoA0TJW7W">微信文章</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/leeSmall/p/8594542.html">cnblogs</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/08/09/redis/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E4%B8%8E%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/09/redis/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E4%B8%8E%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/" class="post-title-link" itemprop="url">缓存策略与缓存一致性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-09 16:23:43" itemprop="dateCreated datePublished" datetime="2020-08-09T16:23:43+08:00">2020-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="更新缓存"><a href="#更新缓存" class="headerlink" title="更新缓存"></a>更新缓存</h2><p>更新缓存的的Design Pattern有四种：Cache aside, Read through, Write through, Write behind caching，我们下面一一来看一下这四种Pattern。</p>
<h3 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h3><ul>
<li>读<ul>
<li>命中：应用程序从cache中取数据，取到后返回。</li>
<li>失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li>
</ul>
</li>
<li>写<ul>
<li>更新：先把数据存到数据库中，成功后，再让缓存失效。</li>
</ul>
</li>
</ul>
<h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><p>一个是查询操作，一个是更新操作的并发，首先，没有了删除cache数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。</p>
<p>这是标准的design pattern，包括Facebook的论文《<a target="_blank" rel="noopener" href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf">Scaling Memcache at Facebook</a>》也使用了这个策略。<strong>为什么不是写完数据库后更新缓存</strong>？你可以看一下Quora上的这个问答《<a target="_blank" rel="noopener" href="https://www.quora.com/Why-does-Facebook-use-delete-to-remove-the-key-value-pair-in-Memcached-instead-of-updating-the-Memcached-during-write-request-to-the-backend">Why does Facebook use delete to remove the key-value pair in Memcached instead of updating the Memcached during write request to the backend?</a>》，主要是怕两个并发的写操作导致脏数据。</p>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>那么，是不是Cache Aside这个就不会有并发问题了？不是的，比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。</p>
<p>但，这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。</p>
<p><strong>所以，这也就是Quora上的那个答案里说的，要么通过2PC或是Paxos协议保证一致性，要么就是拼命的降低并发时脏数据的概率，而Facebook使用了这个降低概率的玩法，因为2PC太慢，而Paxos太复杂。当然，最好还是为缓存设置上过期时间。</strong></p>
<h3 id="Read-x2F-Write-Through-Pattern"><a href="#Read-x2F-Write-Through-Pattern" class="headerlink" title="Read&#x2F;Write Through Pattern"></a>Read&#x2F;Write Through Pattern</h3><p>我们可以看到，在上面的Cache Aside套路中，我们的应用代码需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）。所以，应用程序比较啰嗦。而Read&#x2F;Write Through套路是把更新数据库（Repository）的操作由缓存自己代理了，所以，对于应用层来说，就简单很多了。<strong>可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的Cache。</strong></p>
<ul>
<li>读（Read Through）<ul>
<li>命中：直接从缓存取数据</li>
<li>失效：Read Through 套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。</li>
</ul>
</li>
<li>写（Write Through）<ul>
<li>命中：如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）</li>
<li>失效：直接更新数据库，然后返回</li>
</ul>
</li>
</ul>
<h3 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h3><p>Write Behind 又叫 Write Back。<strong>一些了解Linux操作系统内核的同学对write back应该非常熟悉，这不就是Linux文件系统的Page Cache的算法吗？是的，你看基础这玩意全都是相通的。</strong>所以，基础很重要，我已经不是一次说过基础很重要这事了。</p>
<p>Write Back套路，一句说就是，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是让数据的I&#x2F;O操作飞快无比（因为直接操作内存嘛 ），因为异步，write backg还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。</p>
<p>但是，其带来的问题是，数据不是强一致性的，而且可能会丢失（我们知道Unix&#x2F;Linux非正常关机会导致数据丢失，就是因为这个事）。在软件设计上，我们基本上不可能做出一个没有缺陷的设计，就像算法设计中的时间换空间，空间换时间一个道理，有时候，强一致性和高性能，高可用和高性性是有冲突的。软件设计从来都是取舍Trade-Off。</p>
<p>另外，Write Back实现逻辑比较复杂，因为他需要track有哪数据是被更新了的，需要刷到持久层上。操作系统的write back会在仅当这个cache需要失效的时候，才会被真正持久起来，比如，内存不够了，或是进程退出了等情况，这又叫lazy write。</p>
<h3 id="考虑缓存更新失败的情况"><a href="#考虑缓存更新失败的情况" class="headerlink" title="考虑缓存更新失败的情况"></a>考虑缓存更新失败的情况</h3><p><strong>大多数情况，都不用担心缓存更新失败的情况，因为这将带来很大的成本，却只解决极少的问题。但是如果要考虑缓存更新失败的情况的话，可以有以下的方式</strong></p>
<h4 id="延迟双删"><a href="#延迟双删" class="headerlink" title="延迟双删"></a>延迟双删</h4><p>对于Cache Aside Pattern模式，在第一次使缓存失效后，sleep一段时间，再次删除缓存。以达到解决问题。</p>
<h4 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h4><p>先更新数据库，成功后往消息队列发消息，消费到消息后再删除缓存，借助消息队列的重试机制来实现，达到最终一致性的效果。</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>引入消息中间件之后，问题更复杂了，怎么保证消息不丢失更麻烦。</p>
<p>就算更新数据库和删除缓存都没有发生问题，消息的延迟也会带来短暂的不一致性，不过这个延迟相对来说还是可以接受的。</p>
<h5 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h5><p>为了解决缓存一致性的问题单独引入一个消息队列，太复杂了。</p>
<p>一般大公司本身都会有监听 binlog 消息的消息队列存在，主要是为了做一些核对的工作。</p>
<p>这样，我们可以借助监听 binlog 的消息队列来做删除缓存的操作。这样做的好处是，不用你自己引入，侵入到你的业务代码中，中间件帮你做了解耦，同时，中间件的这个东西本身就保证了高可用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/SO3S2UZaomYwVA43sYzJpw">面试官：缓存一致性问题怎么解决</a></p>
<p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17416.html">左耳朵耗子-缓存更新的套路</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/08/02/redis/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/02/redis/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" class="post-title-link" itemprop="url">缓存穿透与布隆过滤器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-02 20:56:19" itemprop="dateCreated datePublished" datetime="2020-08-02T20:56:19+08:00">2020-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-21 18:53:06" itemprop="dateModified" datetime="2023-02-21T18:53:06+08:00">2023-02-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="从缓存穿透聊到布隆过滤器"><a href="#从缓存穿透聊到布隆过滤器" class="headerlink" title="从缓存穿透聊到布隆过滤器"></a>从缓存穿透聊到布隆过滤器</h2><p><strong>缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中，但是出于容错的考虑，如果从存储层查不到数据则不写入缓存层。</strong></p>
<p>简单说，就查询一个不存在的key，因为没有缓存，就会去数据库查询，从而达到穿透缓存。增大数据库压力的险恶目的。一般来说，不是恶意操作，正常来说，不会遇到这样的问题，然而，怕的就是一些险恶用心的攻击者。那么，我们如何有效处理这种问题呢？</p>
<p>简单想一下，如果我们把有效的key集合起来，查询之前我们先判断一下查询的key是否在集合中，如果不在，直接打回去，让你调皮。这个问题不就解决了吗？但是，如果真的先把所有key组成集合，那这个存储占用的内存太大了，当有1亿个key，那存储空间也是相当可观的，有点太过浪费了。</p>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>布隆过滤器（Bloom Filter）是由Howard Bloom在1970年提出的一种比较巧妙的概率型数据结构，它可以告诉你某种东西<strong>一定不存在</strong>或者<strong>可能存在</strong>。当布隆过滤器说，某种东西存在时，这种东西可能不存在；当布隆过滤器说，某种东西不存在时，那么这种东西一定不存在。</p>
<p>我们可以通过三个哈希算法将w存储到二进制向量，当查询w是否存在时，我们可以再通过这三个算法，如果算法算出来所在的位置均为1，则表示w可能存在（注意是可能存在），否则一定不存在。（这个很好理解，我就不做说明了）</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>布隆过滤器的核心是一个<code>超大的位数组（实际可以二维位数组（二维位向量））</code>和<code>几个哈希函数</code>。假设位数组的长度为m,哈希函数的个数为k。<br>下图表示有三个hash函数，比如一个集合中有x，y，z三个元素，分别用三个hash函数映射到二进制序列的某些位上，假设我们判断w是否在集合中，同样用三个hash函数来映射，结果发现取得的结果不全为1，则表示w不在集合里面</p>
<p><img src="https://s1.ax1x.com/2020/08/05/ayS2md.png"></p>
<ul>
<li>添加一个元素：<ul>
<li>先把这个元素作为k个哈希函数的输入，拿到k个数组位置，然后把所有的这些位置置为1。</li>
</ul>
</li>
<li>查询一个元素（测试这个元素是否在集合里）：<ul>
<li>把这个元素作为k个哈希函数的输入，得到k个数组位置。这些位置中只要有任意一个是0，元素肯定不在这个集合里。如果元素在集合里，那么这些位置在插入这个元素时都被置为1了。如果这些位置都是1，那么要么元素在集合里，要么所有这些位置是在其他元素插入过程中被偶然置为1了，导致了一次“误报”。</li>
</ul>
</li>
</ul>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程:"></a>工作流程:</h4><ul>
<li>第一步：开辟空间：<br>开辟一个长度为m的位数组（或者称二进制向量），这个不同的语言有不同的实现方式，甚至你可以用文件来实现。</li>
<li>第二步：寻找hash函数<br>获取几个hash函数，前辈们已经发明了很多运行良好的hash函数，比如BKDRHash，JSHash，RSHash等等。这些hash函数我们直接获取就可以了。</li>
<li>第三步：写入数据<br>将所需要判断的内容经过这些hash函数计算，得到几个值，比如用3个hash函数，得到值分别是1000，2000，3000。之后设置m位数组的第1000，2000，3000位的值位二进制1。</li>
<li>第四步：判断<br>接下来就可以判断一个新的内容是不是在我们的集合中。判断的流程和写入的流程是一致的。</li>
</ul>
<h3 id="布隆过滤器应用场景"><a href="#布隆过滤器应用场景" class="headerlink" title="布隆过滤器应用场景"></a>布隆过滤器应用场景</h3><ul>
<li>垃圾邮件过滤</li>
<li>防止缓存击穿</li>
<li>比特币交易查询</li>
<li>爬虫的URL过滤</li>
<li>IP黑名单</li>
<li>查询加速【比如基于KV结构的数据】</li>
<li>集合元素重复的判断</li>
</ul>
<h2 id="布隆过滤器的优缺点"><a href="#布隆过滤器的优缺点" class="headerlink" title="布隆过滤器的优缺点"></a>布隆过滤器的优缺点</h2><p><strong>1、优点：</strong></p>
<ul>
<li>有很好的<code>空间和时间效率</code></li>
<li><code>存储空间和插入/查询时间都是常数</code>。</li>
<li>Hash函数相互之间没有关系，方便由硬件并行实现。</li>
<li>不需要存储元素本身，在某些对保密要求非常严格的场合有优势。</li>
<li>布隆过滤器可以表示<code>全集</code>，其它任何数据结构都不能。</li>
</ul>
<p><strong>2、缺点：</strong></p>
<ul>
<li><code>误判率会随元素的增加而增加</code></li>
<li><code>不能从布隆过滤器中删除元素</code></li>
</ul>
<h2 id="redis中的布隆过滤器"><a href="#redis中的布隆过滤器" class="headerlink" title="redis中的布隆过滤器"></a>redis中的布隆过滤器</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基于官方的 docker 镜像来的</span></span><br><span class="line"></span><br><span class="line">docker run -p 6379:6379 --name redis-redisbloom redislabs/rebloom:latest</span><br><span class="line"></span><br><span class="line">docker exec -it redis-redisbloom bash</span><br><span class="line"></span><br><span class="line">redis-cli</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bf.add newFilter abc</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.exists newFilter abc</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.add newFilter def</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.exists newFilter def</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.exists newFilter hij</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<h2 id="golang-实现"><a href="#golang-实现" class="headerlink" title="golang 实现"></a>golang 实现</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> impl</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/willf/bitset&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DEFAULT_SIZE = <span class="number">2</span> &lt;&lt; <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> seeds = []<span class="type">uint</span>&#123;<span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">61</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BloomFilter <span class="keyword">struct</span> &#123;</span><br><span class="line">    Set   *bitset.BitSet</span><br><span class="line">    Funcs [<span class="number">6</span>]SimpleHash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBloomFilter</span><span class="params">()</span></span> *BloomFilter &#123;</span><br><span class="line">    bf := <span class="built_in">new</span>(BloomFilter)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(bf.Funcs); i++ &#123;</span><br><span class="line">        bf.Funcs[i] = SimpleHash&#123;DEFAULT_SIZE, seeds[i]&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bf.Set = bitset.New(DEFAULT_SIZE)</span><br><span class="line">    <span class="keyword">return</span> bf</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bf BloomFilter)</span></span> Add(value <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> (bf.Funcs) &#123;</span><br><span class="line">        bf.Set.Set(f.hash(value))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bf BloomFilter)</span></span> Contains(value <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> value == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret := <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> (bf.Funcs) &#123;</span><br><span class="line">        ret = ret &amp;&amp; bf.Set.Test(f.hash(value))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SimpleHash <span class="keyword">struct</span> &#123;</span><br><span class="line">    Cap  <span class="type">uint</span></span><br><span class="line">    Seed <span class="type">uint</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s SimpleHash)</span></span> hash(value <span class="type">string</span>) <span class="type">uint</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result <span class="type">uint</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(value); i++ &#123;</span><br><span class="line">        result = result*s.Seed + <span class="type">uint</span>(value[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (s.Cap - <span class="number">1</span>) &amp; result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> impl</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class="line">    <span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNewBloomFilter</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    filter := NewBloomFilter()</span><br><span class="line">    fmt.Println(filter.Set,filter.Funcs)</span><br><span class="line">    str1 := <span class="string">&quot;hello,bloom filter!&quot;</span></span><br><span class="line">    filter.Add(str1)</span><br><span class="line">    str2 := <span class="string">&quot;A happy day&quot;</span></span><br><span class="line">    filter.Add(str2)</span><br><span class="line">    str3 := <span class="string">&quot;Greate wall&quot;</span></span><br><span class="line">    filter.Add(str3)</span><br><span class="line"></span><br><span class="line">    str4 := <span class="string">&quot;Greate wall abc&quot;</span></span><br><span class="line"></span><br><span class="line">    assert.Equal(t, <span class="type">uint</span>(<span class="number">18</span>), filter.Set.Count())</span><br><span class="line"></span><br><span class="line">    assert.True(t, filter.Contains(str1))</span><br><span class="line">    assert.True(t, filter.Contains(str2))</span><br><span class="line">    assert.True(t, filter.Contains(str3))</span><br><span class="line">    <span class="comment">// 这里实际上是不一定是 False， 因为布隆过滤器只能判断是否不存在，对于是否存在，它是概率性的正确的</span></span><br><span class="line">    assert.False(t, filter.Contains(str4))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Jack47/p/bloom_filter_intro.html">wiki</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bloom_filter">wiki</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bloom_filter">golang中的布隆过滤器</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huangxincheng/p/10292303.html">redis中的布隆过滤器</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/RedisBloom/RedisBloom">redis 布隆过滤器插件 github</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/05/http/http%E4%B9%8Bhttp2%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/05/http/http%E4%B9%8Bhttp2%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">【http】http2入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-05 23:11:00" itemprop="dateCreated datePublished" datetime="2020-07-05T23:11:00+08:00">2020-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-26 23:33:35" itemprop="dateModified" datetime="2023-02-26T23:33:35+08:00">2023-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index"><span itemprop="name">http</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="HTTP2的核心概念有哪些"><a href="#HTTP2的核心概念有哪些" class="headerlink" title="HTTP2的核心概念有哪些"></a>HTTP2的核心概念有哪些</h3><ul>
<li>二进制分帧层，在 http 与 tcp 层中间的一层，将传输的数据编码为二进制的帧格式</li>
<li>请求与响应复用，http2采用tcp永久连接，在这个连接上抽象出数据帧（被编码的传输数据），消息（一条完整的需要发送的消息），数据流（双向字节流，用于承载消息（实际上是消息被编码的帧））</li>
<li>服务器推送，一问多答（一次请求多次相应）</li>
<li>头部压缩，相同的头在同一连接上，在再次请求时，不用显式地传递（客户端和服务端维护一个头索引表）</li>
</ul>
<h3 id="如何查看当前使用的是http哪个协议"><a href="#如何查看当前使用的是http哪个协议" class="headerlink" title="如何查看当前使用的是http哪个协议"></a>如何查看当前使用的是http哪个协议</h3><p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/a68524865582468791bf12aaaee99763.png"></p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h3><p>HTTP&#x2F;2 所有性能增强的核心在于新的二进制分帧层，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输。</p>
<p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/e2895a9110224e0c9c378dddfd2d5cb8.png"></p>
<p>这里所谓的“层”，指的是位于套接字接口与应用可见的高级 HTTP API 之间一个<strong>经过优化的新编码机制</strong>：HTTP 的语义（包括各种动词、方法、标头）都不受影响，不同的是传输期间对它们的编码方式变了。<strong>HTTP&#x2F;1.x 协议以换行符作为纯文本的分隔符，而 HTTP&#x2F;2 将所有传输的信息分割为更小的消息和帧，并采用二进制格式对它们编码。</strong></p>
<h4 id="数据流，消息和帧"><a href="#数据流，消息和帧" class="headerlink" title="数据流，消息和帧"></a>数据流，消息和帧</h4><ul>
<li>连接： tcp 连接</li>
<li>数据流（stream）：已建立的连接内的双向字节流，可以承载一条或多条消息。</li>
<li><em>消息</em>（message）：与逻辑请求或响应消息对应的完整的一系列帧。</li>
<li>帧（frame）：HTTP&#x2F;2 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流。</li>
</ul>
<p>这些概念的关系总结如下：</p>
<ul>
<li><strong>所有通信都在一个 TCP 连接上完成，此连接可以承载任意数量的双向数据流。</strong></li>
<li>每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。</li>
<li>每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧。（<strong>程序一次可以发送一次消息，且不用等待返回，就继续发送新的消息，而这个消息会在同一个数据流中传递</strong>）</li>
<li>帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li>
</ul>
<p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/09bfb281d2d34e8cbad71f2e4b201030.png"></p>
<h3 id="请求与响应复用"><a href="#请求与响应复用" class="headerlink" title="请求与响应复用"></a>请求与响应复用</h3><p>我们知道，在HTTP 1.x中，我们是可以并行请求的。但是，浏览器对于同一个域名的并行请求是有上限的（FireFox, Chrome上限6个 ）。所以很多网站的静态资源站可能会有多个。虽然http1.x里有keep-alive可以避免TCP三次握手，但是keep-alive又是串行的。<strong>所以要么并行多握手，要么串行不握手，都不是最好的结果，我们希望的是并行也不握手。</strong></p>
<p>幸运的是HTTP&#x2F;2解决了这个问题。当客户端与服务端建立连接后，就会在双方建立一个双向流通道。这个流通道，可以同时包含多个消息（http请求），不同消息各自的数据帧在流里可以乱序并行的发送，不会互相影响与堵塞，从而实现了一个TCP链接，并发执行N个http请求。通过提高并发，减少TCP连接开销，HTTP&#x2F;2的速度得到了很大提升，尤其是在网络延迟比较高的情况下。这个是如何实现的呢，它的实现是因为 http2 有了<strong>二进制分帧</strong>层。</p>
<p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/40bdcc2e7f3f4c9e9233fb37ed3d87ec.png"></p>
<p>将 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装是 HTTP 2 最重要的一项增强。事实上，这个机制会在整个网络技术栈中引发一系列连锁反应，从而带来巨大的性能提升，让我们可以：</p>
<ul>
<li>并行交错地发送多个请求，请求之间互不影响。</li>
<li>并行交错地发送多个响应，响应之间互不干扰。</li>
<li>使用一个连接并行发送多个请求和响应。</li>
<li>不必再为绕过 HTTP&#x2F;1.x 限制而做很多工作（请参阅<a target="_blank" rel="noopener" href="https://hpbn.co/optimizing-application-delivery/#optimizing-for-http1x">针对 HTTP&#x2F;1.x 进行优化</a>，例如级联文件、image sprites 和域名分片。</li>
<li>消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时间。</li>
</ul>
<h3 id="数据优先级"><a href="#数据优先级" class="headerlink" title="数据优先级"></a>数据优先级</h3><p>HTTP&#x2F;2 标准允许每个数据流都有一个关联的权重和依赖关系，来保证高优先级的流优先被 client 和 server 的操作系统和处理程序处理。</p>
<h3 id="每个来源一个连接"><a href="#每个来源一个连接" class="headerlink" title="每个来源一个连接"></a>每个来源一个连接</h3><p>有了新的分帧机制后，HTTP&#x2F;2 不再依赖多个 TCP 连接去并行复用数据流；每个数据流都拆分成很多帧，而这些帧可以交错，还可以分别设定优先级。 <strong>因此，所有 HTTP&#x2F;2 连接都是永久的，而且仅需要每个来源一个连接，随之带来诸多性能优势。</strong></p>
<p><strong>大多数 HTTP 传输都是短暂且急促的，而 TCP 则针对长时间的批量数据传输进行了优化。 通过重用相同的连接，HTTP&#x2F;2 既可以更有效地利用每个 TCP 连接，也可以显著降低整体协议开销。</strong>不仅如此，使用更少的连接还可以减少占用的内存和处理空间，也可以缩短完整连接路径（即，客户端、可信中介和源服务器之间的路径） 这降低了整体运行成本并提高了网络利用率和容量。 因此，迁移到 HTTP&#x2F;2 不仅可以减少网络延迟，还有助于提高通量和降低运行成本。</p>
<h3 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h3><p>流控制是一种阻止发送方向接收方发送大量数据的机制，以免超出后者的需求或处理能力。</p>
<h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>HTTP&#x2F;2 新增的另一个强大的新功能是，服务器可以对一个客户端请求发送多个响应。 换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外资源，而无需客户端明确地请求。</p>
<h3 id="标头压缩"><a href="#标头压缩" class="headerlink" title="标头压缩"></a>标头压缩</h3><p>每个 HTTP 传输都承载一组标头，这些标头说明了传输的资源及其属性。 在 HTTP&#x2F;1.x 中，此元数据始终以纯文本形式，<strong>通常会给每个传输增加 500–800 字节的开销。如果使用 HTTP Cookie，增加的开销有时会达到上千字节</strong>。为了减少此开销和提升性能，HTTP&#x2F;2 使用 HPACK 压缩格式压缩请求和响应标头元数据，这种格式采用两种简单但是强大的技术：</p>
<ol>
<li>这种格式支持通过静态霍夫曼代码对传输的标头字段进行编码，从而减小了各个传输的大小。</li>
<li>这种格式要<strong>求客户端和服务器同时维护和更新一个包含之前见过的标头字段的索引列表</strong>（换句话说，它可以建立一个共享的压缩上下文），此列表随后会用作参考，对之前传输的值进行有效编码。</li>
</ol>
<p>利用霍夫曼编码，可以在传输时对各个值进行压缩，而利用之前传输值的索引列表，我们可以通过传输索引值的方式对重复值进行编码，索引值可用于有效查询和重构完整的标头键值对。</p>
<p>作为一种进一步优化方式，HPACK 压缩上下文包含一个静态表和一个动态表：静态表在规范中定义，并提供了一个包含所有连接都可能使用的常用 HTTP 标头字段（例如，有效标头名称）的列表；动态表最初为空，将根据在特定连接内交换的值进行更新。</p>
<h2 id="golang-实现-server-push"><a href="#golang-实现-server-push" class="headerlink" title="golang 实现 server push"></a>golang 实现 server push</h2><p>server push 简单说就是 client 请求一次，但是 server 返回几次。个人感觉这个东西还是比较鸡肋的，这是因为现在的文件资源很多都是放在cdn的，这样 server push 的意义就不是很大了。</p>
<p>server push 不仅可以用作拉取静态资源，我们的 cgi 请求即 ajax 请求同样可以使用 server push 来发送数据。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://github.com/tylerchr/examples%E3%80%82%E6%95%88%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">https://github.com/tylerchr/examples。效果如下：</a></p>
<p>启动服务访问 <a target="_blank" rel="noopener" href="https://127.0.0.1:4430/index.html%EF%BC%88%E6%88%91%E4%B8%AA%E4%BA%BA%E5%9C%A8%E9%A1%B5%E9%9D%A2%E5%8A%A0%E4%BA%86%E4%BA%9B%E9%A2%9D%E5%A4%96%E7%9A%84%E4%B8%9C%E8%A5%BF%EF%BC%89%EF%BC%9A">https://127.0.0.1:4430/index.html（我个人在页面加了些额外的东西）：</a></p>
<p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/89b01e68c0594163a6ccd8085c529589.png"></p>
<h2 id="golang-实现全双工通信"><a href="#golang-实现全双工通信" class="headerlink" title="golang 实现全双工通信"></a>golang 实现全双工通信</h2><p>HTTP2是支持全双工通信的。这里需要注意的是，一般来说 HTTP2 server push 指的是，client 的一个请求，server 可以回复多个资源。但是全双工通信指的是，在一个已经建立的 tcp 连接中，基于 http2 的长连接及二进制分帧等设计。实现全双工通信。</p>
<p>实现，目前已实现，但是一些技术还需要更深的理解。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><p><a target="_blank" rel="noopener" href="https://posener.github.io/http2/">golang 实例</a>。<a target="_blank" rel="noopener" href="https://github.com/posener/h2conn">github 仓库</a>。 <a target="_blank" rel="noopener" href="https://www.bangbangde.com/post/http2_adventure_in_the_go_world.html">翻译</a></p>
<p><a target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/performance/http2?hl=zh-cn#%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%8A%80%E6%9C%AF%E7%9B%AE%E6%A0%87">谷歌对http2的详细介绍：本文抄袭了极多</a></p>
<p><a target="_blank" rel="noopener" href="http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/#prettyPhoto">腾讯前端对http2的介绍，实际上和谷歌的介绍重合度很高</a></p>
<p><a target="_blank" rel="noopener" href="https://http2.github.io/faq/">https://http2.github.io/faq/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0c4ac947c34b">如何验证网站是否是 HTTP2.0</a></p>
<p><a target="_blank" rel="noopener" href="https://www.codenong.com/28582935/">关于http2：HTTP &#x2F; 2是否会使websocke</a></p>
<h3 id="非重点"><a href="#非重点" class="headerlink" title="非重点"></a>非重点</h3><p><a target="_blank" rel="noopener" href="https://ops.tips/blog/nginx-http2-server-push/">nginx + golang server push</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/tylerchr/examples">golang 的htt2 server push 的实现</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.golang.org/h2push">golang 官方 h2 server push </a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/30/http/websocket%E4%B9%8Bwebsocket%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/30/http/websocket%E4%B9%8Bwebsocket%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">websocket之websocket入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-30 15:39:21" itemprop="dateCreated datePublished" datetime="2020-06-30T15:39:21+08:00">2020-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>WebSocket是一种网络传输协议，可在单个TCP连接上进行全双工通信，位于OSI模型的应用层。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，<strong>并进行双向数据传输，（更重要的，与http相比，它支持server push）</strong>。</p>
<p>WebSocket是一种与HTTP不同的协议。两者都位于OSI模型的应用层，并且都依赖于传输层的TCP协议。 虽然它们不同，但是RFC 6455中规定：it is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries（WebSocket通过HTTP端口80和443进行工作，并支持HTTP代理和中介），从而使其与HTTP协议兼容。 <strong>为了实现兼容性，WebSocket握手使用HTTP Upgrade头从HTTP协议更改为WebSocket协议。</strong> 通信通过TCP端口80或443完成，这在防火墙阻止非Web网络连接的环境下是有益的。另外，Comet之类的技术以非标准化的方式实现了类似的双向通信。</p>
<p>WebSocket协议规范将ws（WebSocket）和wss（WebSocket Secure）定义为两个新的统一资源标识符（URI）方案，分别对应明文和加密连接。例如<code>ws://localhost:12345/ws</code>。</p>
<h3 id="websocket-消息帧格式"><a href="#websocket-消息帧格式" class="headerlink" title="websocket 消息帧格式"></a>websocket 消息帧格式</h3><p>WebSocket 客户端、服务端通信的最小单位是 帧（frame），由 1 个或多个帧组成一条完整的 消息（message）。</p>
<ul>
<li>发送端：将消息切割成多个帧，并发送给服务端；</li>
<li>接收端：接收消息帧，并将关联的帧重新组装成完整的消息；</li>
</ul>
<p>帧格式分析 TODO</p>
<h3 id="websocket-消息类型"><a href="#websocket-消息类型" class="headerlink" title="websocket 消息类型"></a>websocket 消息类型</h3><h4 id="文本消息"><a href="#文本消息" class="headerlink" title="文本消息"></a>文本消息</h4><h4 id="二进制消息"><a href="#二进制消息" class="headerlink" title="二进制消息"></a>二进制消息</h4><h4 id="ping-pong-消息与心跳保持"><a href="#ping-pong-消息与心跳保持" class="headerlink" title="ping pong 消息与心跳保持"></a>ping pong 消息与心跳保持</h4><p>WebSocket 为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的 TCP 通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。</p>
<p>但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。</p>
<ul>
<li>发送方 -&gt;接收方：ping</li>
<li>接收方 -&gt;发送方：pong</li>
</ul>
<p>ping、pong 的操作，对应的是 WebSocket 的两个控制帧，opcode分别是 0x9、0xA。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。<strong>相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</strong></li>
<li>更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。</li>
<li>保持连接状态。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</li>
<li>更好的二进制支持。Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。</li>
</ul>
<h2 id="浏览器下的websocket"><a href="#浏览器下的websocket" class="headerlink" title="浏览器下的websocket"></a>浏览器下的websocket</h2><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><ul>
<li>Connection必须设置Upgrade，表示客户端希望连接升级。Upgrade字段必须设置Websocket，表示希望升级到Websocket协议。</li>
<li>Sec-WebSocket-Key是随机的字符串，服务器端会用这些数据来构造出一个SHA-1的信息摘要。把“Sec-WebSocket-Key”加上一个特殊字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算SHA-1摘要，之后进行Base64编码，将结果做为“Sec-WebSocket-Accept”头的值，返回给客户端。如此操作，可以尽量避免普通HTTP请求被误认为Websocket协议。</li>
<li>Sec-WebSocket-Version 表示支持的Websocket版本。RFC6455要求使用的版本是13，之前草案的版本均应当弃用。</li>
</ul>
<p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/941ab655c25e4a9cac6b6ea73552a0d5.png"></p>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/ce0ef535e6eb422abe6228052450478d.png"></p>
<h2 id="服务器间的websocket"><a href="#服务器间的websocket" class="headerlink" title="服务器间的websocket"></a>服务器间的websocket</h2><p>参考<a target="_blank" rel="noopener" href="https://github.com/gorilla/websocket/tree/master/examples/echo">golang</a>的实现。</p>
<p>服务器的实现主要要考虑如何维护 10k 甚至 1M 的 websocket连接的问题。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WebSocket">wiki</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/gorilla/websocket">golang websocket协议的实现</a></p>
<p><a target="_blank" rel="noopener" href="https://colobu.com/2019/02/23/1m-go-tcp-connection/">百万websocket连接</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000012948613#item-2">websocket详解</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/14/http/tcp%E4%B9%8B%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/http/tcp%E4%B9%8B%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/" class="post-title-link" itemprop="url">tcp之三次握手</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-14 22:44:12" itemprop="dateCreated datePublished" datetime="2020-06-14T22:44:12+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下的分别使用 tcp 报文帧中的 标志位， 序列号位， 确认号位</span></span><br><span class="line"></span><br><span class="line">Client --&gt; 置SYN标志 序列号 = J，确认号 = 0 ----&gt; Server</span><br><span class="line"></span><br><span class="line">Client &lt;-- 置SYN标志 置ACK标志 序列号 = K, 确认号 = J + 1 &lt;-- Server</span><br><span class="line"></span><br><span class="line">Clinet --&gt; 置ACK标志 序列号 = J + 1，确认号 = K + 1 --&gt; Server</span><br></pre></td></tr></table></figure>

<p>链接建立后，接下来Client端发送的数据包将从J + 1开始，Server端发送的数据包将从K + 1开始，这里要说明的是：建立链接时，Client端宣称自己的初始序列号是J，Server端宣称自己的初始序列号是K，但是建立连接后的数据包却各自中初始序列号+1开始，这是因为SYN请求本身需要占用一个序列号 </p>
<h2 id="TCP-的定义"><a href="#TCP-的定义" class="headerlink" title="TCP 的定义"></a>TCP 的定义</h2><p>很多人尝试回答或者思考这个问题的时候其实关注点都放在了三次握手中的三次上面，这确实很重要，但是如果重新审视这个问题，我们对于『什么是连接』真的清楚？只有知道连接的定义，我们才能去尝试回答为什么 TCP 建立连接需要三次握手。</p>
<p><code>The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream. The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.</code></p>
<p>RFC 793 - Transmission Control Protocol 文档中非常清楚地定义了 TCP 中的连接是什么，我们简单总结一下：用于保证可靠性和流控制机制的信息，包括 <strong>Socket、序列号以及窗口大小叫做连接</strong>。</p>
<p>所以，建立 TCP 连接就是通信的双方需要对上述的三种信息达成共识，连接中的一对 Socket 是由互联网地址标志符和端口组成的，窗口大小主要用来做流控制，最后的序列号是用来追踪通信发起方发送的数据包序号，接收方可以通过序列号向发送方确认某个数据包的成功接收。</p>
<h2 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h2><p>这篇文章主要会从以下几个方面介绍为什么我们需要通过三次握手才可以初始化 Sockets、窗口大小、初始序列号并建立 TCP 连接：</p>
<ul>
<li><strong>通过三次握手才能阻止重复历史连接的初始化；</strong></li>
<li>通过三次握手才能对通信双方的初始序列号进行初始化；</li>
<li>讨论其他次数握手建立连接的可能性；</li>
</ul>
<h3 id="历史连接"><a href="#历史连接" class="headerlink" title="历史连接"></a>历史连接</h3><p>最大的问题是发起创建连接的一方A在发出syn之后没有收到ack（网络原因等），它就会再发出一个syn，那么接受方B其实收到了两个 syn并对两个syn 发出了确认，那么实际上其中一个syn已经是历史连接了。TCP 选择使用三次握手来建立连接并在连接引入了 RST 这一控制消息，接收方当收到请求时会将发送方发来的 SEQ+1 发送给对方，这时<strong>由发送方来判断当前连接是否是历史连接</strong>：</p>
<ul>
<li>如果当前连接是历史连接，即 SEQ 过期或者超时，那么发送方就会直接发送 RST 控制消息中止这一次连接；</li>
<li>如果当前连接不是历史连接，那么发送方就会发送 ACK 控制消息，通信双方就会成功建立连接；</li>
</ul>
<h3 id="初始化序列号"><a href="#初始化序列号" class="headerlink" title="初始化序列号"></a>初始化序列号</h3><p>另一个使用三次握手的重要的原因就是通信双方都需要获得一个用于发送信息的初始化序列号，作为一个可靠的传输层协议，<strong>TCP 需要在不稳定的网络环境中构建一个可靠的传输层</strong>，网络的不确定性可能会导致数据包的缺失和顺序颠倒等问题，常见的问题可能包括：</p>
<ul>
<li>数据包被发送方多次发送造成数据的重复；</li>
<li>数据包在传输的过程中被路由或者其他节点丢失；</li>
<li>数据包到达接收方可能无法按照发送顺序；</li>
</ul>
<p>为了解决上述这些可能存在的问题，TCP 协议要求发送方在数据包中加入『序列号』字段，有了数据包对应的序列号，我们就可以：</p>
<ul>
<li>接收方可以通过序列号对重复的数据包进行去重；</li>
<li>发送方会在对应数据包未被 ACK 时进行重复发送；</li>
<li>接收方可以根据数据包的序列号对它们进行重新排序；</li>
</ul>
<p>除此之外，网络作为一个分布式的系统，其中并不存在一个用于计数的全局时钟，而 TCP 可以通过不同的机制来初始化序列号，<strong>作为 TCP 连接的接收方我们无法判断对方传来的初始化序列号是否过期，所以我们需要交由对方来判断</strong>，TCP 连接的发起方可以通过保存发出的序列号判断连接是否过期，如果让接收方来保存并判断序列号却是不现实的，这也再一次强化了我们在上一节中提出的观点 —— 避免历史错连接的初始化。</p>
<h2 id="TCP-控制位"><a href="#TCP-控制位" class="headerlink" title="TCP 控制位"></a>TCP 控制位</h2><h3 id="控制位"><a href="#控制位" class="headerlink" title="控制位"></a>控制位</h3><p>ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。</p>
<p>PSH：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。</p>
<p>RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。</p>
<p>SYN：同步序号，用于建立连接过程，在连接请求中，SYN&#x3D;1和ACK&#x3D;0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN&#x3D;1和ACK&#x3D;1。</p>
<p>FIN：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。</p>
<h3 id="数据传输中的序列号及确认号"><a href="#数据传输中的序列号及确认号" class="headerlink" title="数据传输中的序列号及确认号"></a>数据传输中的序列号及确认号</h3><ul>
<li>序号（Sequence Number）<ul>
<li>也称为序列号，长度为32位，序号用来标识从TCP发送端向接入端发送的数据字节流进行编号，可以理解成对字节流的计数。例如一个报文段的序号为 55555，此报文段数据部分共有 11 字节，则下一个报文段的序号为 55566。</li>
</ul>
</li>
<li>确认号（ack Number）<ul>
<li>指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。比如 client 发送的确认号是 22222，那么 server回复的 序号就是 22222。</li>
<li>确认号还有一个更重要的功能就是对消息的确认，它等于请求的 序列号 + 数据包的长度（表示收到了这个序列号的这么多数据）</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 tcp 的数据传输过程中，一次数据请求，至少需要发送三个tcp报文，分别是 请求报文，响应报文，收到响应后的ack报文。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">TODO 这个还没有抓包确认</span></span><br><span class="line">Client --&gt; 置PSH标志，置ACK标志 序列号 = 55555, 确认号 = 22222，数据包长度 = 11 ---&gt; Server</span><br><span class="line"></span><br><span class="line">Client &lt;-- 置ACK标志，序列号 = 22222, 确认号 = 55566 (=55555 + 11)，数据包长度 = 22 &lt;--- Server</span><br><span class="line"></span><br><span class="line">Client --&gt; 置ACK标志，序列号 = 55566, 确认号 = 22244(=22222+22)，数据包长度 = 0 ---&gt; Server</span><br></pre></td></tr></table></figure>

<h2 id="让我们来抓包看看"><a href="#让我们来抓包看看" class="headerlink" title="让我们来抓包看看"></a>让我们来抓包看看</h2><p><strong>注意wireshark 入口不要选 wlan， 要选 loopback traffic capture</strong></p>
<h3 id="解决抓不到包的问题"><a href="#解决抓不到包的问题" class="headerlink" title="解决抓不到包的问题"></a>解决抓不到包的问题</h3><p>今天将自己的电脑既作为客户端又作为服务端进行一个程序的测试，想着用WireShark来抓包分析一下问题，但由于WireShark只能抓取经过电脑网卡的包，由于我是使用<code>localhost</code>或者<code>127.0.0.1</code>进行测试的，流量是不经过电脑网卡的，所以WireShark无法抓包，一番查找之下找到了解决方法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">route <span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 以管理员身份打开命令提示符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 输入 route add 本机ip mask 255.255.255.255 网关ip</span></span><br><span class="line">PS C:\WINDOWS\system32&gt; route add 10.23.101.135 mask 255.255.255.255 10.23.101.1</span><br><span class="line"> 操作完成!</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2.2  如果不知道本机ip和网关ip，可以在命令行输入ipconfig查看</span></span><br><span class="line">无线局域网适配器 WLAN:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::3d96:449b:3c6f:322%12</span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : 10.23.101.135</span><br><span class="line">   子网掩码  . . . . . . . . . . . . : 255.255.255.0</span><br><span class="line">   默认网关. . . . . . . . . . . . . : 10.23.101.1</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 3. 将我们程序里面的localhost或者127.0.0.1替换成本机ip</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 使用WireShark即可抓到本地包</span></span><br><span class="line"><span class="comment"># tcp and ip.addr==10.23.101.135 and tcp.port==6666</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 在测试完之后，使用route delete 本机ip mask 255.255.255.255 网关ip来删除我们上面的更改，不然我们本机的所有报文都会先经过网卡再回到本机，会比较消耗性能。</span></span><br><span class="line">route delete 10.23.101.135 mask 255.255.255.255 10.23.101.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">route add 10.248.0.0 mask 255.255.0.0 10.248.108.1</span><br><span class="line">route delete 10.248.0.0 mask 255.255.0.0 10.248.108.1</span><br></pre></td></tr></table></figure>

<h4 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h4><p><strong>注意wireshark入口不要选wifi，要选择 loopback:lo0</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本机ip</span></span><br><span class="line">percy@GauguindeMacBook-Pro go-mod % ifconfig | grep inet</span><br><span class="line">	inet 127.0.0.1 netmask 0xff000000</span><br><span class="line">	inet6 ::1 prefixlen 128</span><br><span class="line">	inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1</span><br><span class="line">	inet6 fe80::aede:48ff:fe00:1122%en3 prefixlen 64 scopeid 0x4</span><br><span class="line">	inet6 fe80::105d:dc8c:9235:2d45%en0 prefixlen 64 secured scopeid 0x6</span><br><span class="line">	inet 192.168.0.103 netmask 0xffffff00 broadcast 192.168.0.255</span><br><span class="line">	inet6 fe80::3001:5bff:fe8f:87d2%awdl0 prefixlen 64 scopeid 0xb</span><br><span class="line">	inet6 fe80::3001:5bff:fe8f:87d2%llw0 prefixlen 64 scopeid 0xc</span><br><span class="line">	inet6 fe80::246c:eb89:6f5d:7bdc%utun0 prefixlen 64 scopeid 0xd</span><br><span class="line">	inet6 fe80::3d0c:86ef:9ea0:acc9%utun1 prefixlen 64 scopeid 0xe</span><br><span class="line">	inet6 fe80::7d55:b5c7:301c:8a04%utun2 prefixlen 64 scopeid 0xf</span><br><span class="line">	inet6 fe80::a6cd:6877:6f19:b84d%utun3 prefixlen 64 scopeid 0x10</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 查看默认网关</span></span><br><span class="line">percy@GauguindeMacBook-Pro go-mod % route get default | grep gateway</span><br><span class="line">    gateway: 192.168.0.1</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加路由</span></span><br><span class="line"></span><br><span class="line">$ sudo route -v add ip gateway [-netmask net-mask-ip]</span><br><span class="line"><span class="comment"># -net 参数可以指定添加一个网段</span></span><br><span class="line">$ sudo route -v add -net 128.192 gateway</span><br><span class="line"><span class="comment"># -host 参数可以指定添加一个具体的地址</span></span><br><span class="line">$ sudo route -v add -host 128.192.214.29 gateway</span><br><span class="line"></span><br><span class="line">sudo route -v add -host 192.168.0.103 192.168.0.1</span><br><span class="line"><span class="comment"># 删除路由</span></span><br><span class="line">sudo route -v delete ip</span><br><span class="line">sudo route -v delete 192.168.0.103</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看路由信息</span></span><br><span class="line">percy@GauguindeMacBook-Pro go-mod % netstat -r</span><br><span class="line">Routing tables</span><br><span class="line"></span><br><span class="line">Internet:</span><br><span class="line">Destination        Gateway            Flags        Netif Expire</span><br><span class="line">default            192.168.0.1        UGSc           en0</span><br><span class="line">127                127.0.0.1          UCS            lo0</span><br><span class="line">127.0.0.1          127.0.0.1          UH             lo0</span><br><span class="line">169.254            <span class="built_in">link</span><span class="comment">#6             UCS            en0      !</span></span><br><span class="line">192.168.0          <span class="built_in">link</span><span class="comment">#6             UCS            en0      !</span></span><br><span class="line">192.168.0.1/32     <span class="built_in">link</span><span class="comment">#6             UCS            en0      !</span></span><br><span class="line">192.168.0.1        50:f:f5:88:95:70   UHLWIir        en0   1172</span><br><span class="line">192.168.0.103/32   <span class="built_in">link</span><span class="comment">#6             UCS            en0      !</span></span><br><span class="line">224.0.0/4          <span class="built_in">link</span><span class="comment">#6             UmCS           en0      !</span></span><br><span class="line">224.0.0.251        1:0:5e:0:0:fb      UHmLWI         en0</span><br><span class="line">239.255.255.250    1:0:5e:7f:ff:fa    UHmLWI         en0</span><br><span class="line">255.255.255.255/32 <span class="built_in">link</span><span class="comment">#6             UCS            en0      !</span></span><br></pre></td></tr></table></figure>

<h4 id="wireshark-简单使用"><a href="#wireshark-简单使用" class="headerlink" title="wireshark 简单使用"></a>wireshark 简单使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 过滤指定ip和端口， 这里的10.23.101.135 是我机器的端口</span></span><br><span class="line">tcp and ip.addr==10.23.101.135 and tcp.port==6666</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一些语法</span></span><br><span class="line"><span class="comment"># ip</span></span><br><span class="line">ip.src eq 192.168.1.107 or ip.dst eq 192.168.1.107</span><br><span class="line"><span class="comment"># port</span></span><br><span class="line">tcp.port == 80</span><br><span class="line">tcp.port eq 2722</span><br><span class="line">tcp.port eq 80 or udp.port eq 80</span><br><span class="line">tcp.dstport == 80 // 只显tcp协议的目标端口80</span><br><span class="line">tcp.srcport == 80 // 只显tcp协议的来源端口80</span><br><span class="line">udp.port eq 15000</span><br></pre></td></tr></table></figure>

<h3 id="tcp-包分析"><a href="#tcp-包分析" class="headerlink" title="tcp 包分析"></a>tcp 包分析</h3><h4 id="tcp-握手和挥手包分析"><a href="#tcp-握手和挥手包分析" class="headerlink" title="tcp 握手和挥手包分析"></a>tcp 握手和挥手包分析</h4><p>测试代码 go-mod&#x2F;netx&#x2F;tcp_demo&#x2F;client.go, testConn</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/BaAtlq"><img src="https://s1.ax1x.com/2020/10/31/BaAtlq.md.png" alt="BaAtlq.md.png"></a></p>
<h4 id="tcp-连接后立即发送一个请求包的分析"><a href="#tcp-连接后立即发送一个请求包的分析" class="headerlink" title="tcp 连接后立即发送一个请求包的分析"></a>tcp 连接后立即发送一个请求包的分析</h4><p>测试代码 go-mod&#x2F;netx&#x2F;tcp_demo&#x2F;client.go,  testSendOne</p>
<p>这里可以看到， 三次握手建立连接造成的后果就是，HTTP 请求最少必须在一个 RTT（从客户端到服务器一个往返的时间）后才能发送。最少的请求就是握手的最后一个 ack 包和请求包合并。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/BaAw0U"><img src="https://s1.ax1x.com/2020/10/31/BaAw0U.md.png" alt="BaAw0U.md.png"></a></p>
<h4 id="tcp-连接后睡眠一秒，然后两次请求的分析"><a href="#tcp-连接后睡眠一秒，然后两次请求的分析" class="headerlink" title="tcp 连接后睡眠一秒，然后两次请求的分析"></a>tcp 连接后睡眠一秒，然后两次请求的分析</h4><p>测试代码 go-mod&#x2F;netx&#x2F;tcp_demo&#x2F;client.go,  testSendTwo</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/BaA2X6"><img src="https://s1.ax1x.com/2020/10/31/BaA2X6.md.png" alt="BaA2X6.md.png"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>最重要的参考： <a target="_blank" rel="noopener" href="https://draveness.me/whys-the-design-tcp-three-way-handshake/">为什么 TCP建立连接需要三次握手</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenboo/archive/2011/12/19/2293327.html">TCP序列号和确认号详解</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cwg_1992/article/details/17427533">一次http完整的请求tcp报文分析</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bingjianIT/article/details/54847852">windows 下 WireShark如何抓取本地localhost的包</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1442007">wireshark filter</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/13/distribute/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8Bk8s%E5%B9%B3%E6%BB%91%E6%9B%B4%E6%96%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/13/distribute/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8Bk8s%E5%B9%B3%E6%BB%91%E6%9B%B4%E6%96%B0/" class="post-title-link" itemprop="url">虚拟化之K8S平滑更新(zero-downtime with Kubernetes)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-13 19:08:33" itemprop="dateCreated datePublished" datetime="2020-06-13T19:08:33+08:00">2020-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">虚拟化</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="服务如何优雅退出"><a href="#服务如何优雅退出" class="headerlink" title="服务如何优雅退出"></a>服务如何优雅退出</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	客户端会报如下错误</span></span><br><span class="line"><span class="comment">	 Get Get http://127.0.0.1:9991/ping: read tcp 127.0.0.1:61733-&gt;127.0.0.1:9991: wsarecv: An existing connection was forcibly closed by the remote host.</span></span><br><span class="line"><span class="comment">	这是因为一个正在使用的 tcp 连接被服务端强行关闭了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BadServer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	engine := gin.Default()</span><br><span class="line">	util.Router(engine)</span><br><span class="line">	srv := &amp;http.Server&#123;Handler: engine, Addr: <span class="string">&quot;:9991&quot;</span>&#125;</span><br><span class="line">	err := srv.ListenAndServe()</span><br><span class="line">	_ = srv.Shutdown(context.Background())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	客户端不会报错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GraceServer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	engine := gin.Default()</span><br><span class="line">	util.Router(engine)</span><br><span class="line">	srv := &amp;http.Server&#123;Handler: engine, Addr: <span class="string">&quot;:9991&quot;</span>&#125;</span><br><span class="line">	channelMark := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">		<span class="comment">// k8s 会发 TERM 信号</span></span><br><span class="line">		signal.Notify(ch, syscall.SIGTERM, syscall.SIGQUIT, syscall.SIGKILL, syscall.SIGINT)</span><br><span class="line">		tmp := &lt;-ch</span><br><span class="line">		channelMark &lt;- tmp</span><br><span class="line">		_ = srv.Shutdown(context.Background())</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	err := srv.ListenAndServe()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;ListenAndServe-&gt;&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	err = srv.Shutdown(context.Background())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Shutdown-&gt;&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	tmp := &lt;-channelMark</span><br><span class="line">	fmt.Println(<span class="string">&quot;Notify-&gt;&quot;</span>, tmp, fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, tmp))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="k8s-如何优雅更新"><a href="#k8s-如何优雅更新" class="headerlink" title="k8s 如何优雅更新"></a>k8s 如何优雅更新</h2><p>简单说就是加两个探针并设置 preStop， liveness 用于检测已注册的节点是否可用，readiness 用于检测新创建的节点是否可用。示例如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">grace-shut-example-deploy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">imagePullSecrets:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">all-aliyuncs</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">grace-shut-example</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">registry.cn-zhangjiakou.aliyuncs.com/xiaoduoai/ecrobot-grace_shut_example:v0.0.4</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;./grace_shut_example&quot;</span>, <span class="string">&quot;&gt;&gt;&quot;</span>, <span class="string">&quot;/var/log/xiaoduo/grace_shut_example.out&quot;</span>]</span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/log/xiaoduo</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">log-volume</span></span><br><span class="line">          <span class="attr">readinessProbe:</span></span><br><span class="line">            <span class="attr">tcpSocket:</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">9991</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">            <span class="attr">periodSeconds:</span> <span class="number">1</span></span><br><span class="line">            <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">            <span class="attr">failureThreshold:</span> <span class="number">2</span></span><br><span class="line">          <span class="attr">livenessProbe:</span></span><br><span class="line">            <span class="attr">tcpSocket:</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">9991</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">            <span class="attr">periodSeconds:</span> <span class="number">1</span></span><br><span class="line">            <span class="attr">failureThreshold:</span> <span class="number">2</span></span><br><span class="line">          <span class="attr">lifecycle:</span></span><br><span class="line">            <span class="attr">preStop:</span></span><br><span class="line">              <span class="attr">exec:</span></span><br><span class="line">                <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;sleep 10&quot;</span>]</span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">log-volume</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">log-volume-claim</span></span><br></pre></td></tr></table></figure>

<p>以上示例使用 tcp 探测的方式，并设置探测时间间隔为 1 秒。</p>
<h3 id="核心配置探针"><a href="#核心配置探针" class="headerlink" title="核心配置探针"></a>核心配置探针</h3><p>主要是设置存活探针和就绪探针。</p>
<h3 id="核心配置-preStop"><a href="#核心配置-preStop" class="headerlink" title="核心配置 preStop"></a>核心配置 preStop</h3><ul>
<li>为什么要配置 preStop<ul>
<li>因为 通知 load balance 将老节点摘除和 向老节点 发送 TERM 信号，是并发的（实际上是先通知load balance 摘掉老节点，然后再异步的发送 TERM 信号），没有保证先后顺序，这就意味着，可能 load balance 还没有将老借点摘除，但是老节点已经接受到了 TERM 信号并且关闭了TCP连接请求，这样部分请求就到了一个已关闭的节点上。</li>
<li>preStop 是在通知 load balance 摘掉老节点之后的一个操作，这是一个阻塞操作，他会执行指令，直到指令接受，所以，我们在preStop中调用 sleep 函数，给load balance 足够的时间来摘除老节点。然后再‘异步’地发送 TERM 信号。</li>
</ul>
</li>
</ul>
<p><code>Kubernetes 在容器结束前立即发送 preStop 事件。除非 Pod 宽限期限超时，Kubernetes 的容器管理逻辑 会一直阻塞等待 preStop 处理函数执行完毕。</code></p>
<p><code>This deployment configuration will perform version updates in the following way: It will create one pod with the new version at a time, wait for the pod to start-up and become ready, trigger the termination of one of the old pods, and continue with the next new pod until all replicas have been transitioned. In order to tell Kubernetes when our pods are running and ready to handle traffic we need to configure liveness and readiness probes.</code></p>
<p><code>此部署配置将以以下方式执行版本更新：它将一次创建一个具有新版本的Pod，等待Pod启动并准备就绪，触发其中一个旧Pod的终止，然后继续 下一个新的Pod，直到所有副本都已转换。 为了告诉Kubernetes我们的Pod何时运行并准备处理流量，我们需要配置活动和就绪探针。</code></p>
<p><code>If our client, that is the zero-downtime test, connects to the </code>coffee-shop<code> service directly from inside the cluster, it typically uses the service VIP resolved via Cluster DNS and ends up at a Pod instance. This is realized via the kube-proxy that runs on every Kubernetes node and updates iptables that route to the IP addresses of the pods.</code></p>
<p><code>如果我们的客户端（即零停机时间测试）直接从群集内部连接到服务，则它通常使用通过群集DNS解析的服务VIP，最终到达Pod实例。 这是通过在每个Kubernetes节点上运行并更新路由到Pod的IP地址的iptables的kube-proxy来实现的。</code></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>目前是在公司 gitlab 个人目录下实现了一个 k8s 优雅退出的 模板，经过测试。在 qps 为 1000（更高的qps还没有测试） 可以实现<strong>零报错</strong>的更新镜像。</p>
<p>gitlab地址：<a target="_blank" rel="noopener" href="https://gitlab.xiaoduoai.com/zhuyuanbing/grace_shut_example">https://gitlab.xiaoduoai.com/zhuyuanbing/grace_shut_example</a></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">项目：https://gitlab.xiaoduoai.com/devops/k8s-app-deploy</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">目录：/ks-prod/ecrobot/grace-shut-example/grace</span></span><br></pre></td></tr></table></figure>

<h4 id="模拟更新镜像"><a href="#模拟更新镜像" class="headerlink" title="模拟更新镜像"></a>模拟更新镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如在测试环境</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下两个指令模拟线上更新镜像</span></span><br><span class="line">kubectl set image deployment/grace-shut-example-deploy grace-shut-example=registry.cn-zhangjiakou.aliyuncs.com/xiaoduoai/ecrobot-grace_shut_example:v0.0.7 --namespace=test-ks</span><br><span class="line"></span><br><span class="line">kubectl set image deployment/grace-shut-example-deploy grace-shut-example=registry.cn-zhangjiakou.aliyuncs.com/xiaoduoai/ecrobot-grace_shut_example:v0.0.4 --namespace=test-ks</span><br></pre></td></tr></table></figure>

<h4 id="并发测试工具"><a href="#并发测试工具" class="headerlink" title="并发测试工具"></a>并发测试工具</h4><ul>
<li>ab</li>
<li>wrk</li>
<li>mock： <a target="_blank" rel="noopener" href="https://gitlab.xiaoduoai.com/zhuyuanbing/grace_shut_example/client/mock.go">https://gitlab.xiaoduoai.com/zhuyuanbing/grace_shut_example/client/mock.go</a></li>
</ul>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>将上线的 http 服务全部替换为平滑更新的方案。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>最佳实践文档：<a target="_blank" rel="noopener" href="https://blog.sebastian-daschner.com/entries/zero-downtime-updates-kubernetes">https://blog.sebastian-daschner.com/entries/zero-downtime-updates-kubernetes</a></p>
<p>k8s探针：<a target="_blank" rel="noopener" href="https://jimmysong.io/kubernetes-handbook/guide/configure-liveness-readiness-probes.html">https://jimmysong.io/kubernetes-handbook/guide/configure-liveness-readiness-probes.html</a></p>
<p>k8s preStop：<a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/">https://kubernetes.io/zh/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Percy"
      src="https://ivalue2333.github.io/percy/images/percy.jpg">
  <p class="site-author-name" itemprop="name">Percy</p>
  <div class="site-description" itemprop="description">IOT2014</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">156</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">194</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Percy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
