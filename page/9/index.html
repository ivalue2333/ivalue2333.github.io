<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="IOT2014">
<meta property="og:type" content="website">
<meta property="og:title" content="blog | percy">
<meta property="og:url" content="http://example.com/page/9/index.html">
<meta property="og:site_name" content="blog | percy">
<meta property="og:description" content="IOT2014">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Percy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>blog | percy</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blog | percy</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/08/21/golang/ast/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/21/golang/ast/" class="post-title-link" itemprop="url">ast</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-21 16:25:27" itemprop="dateCreated datePublished" datetime="2020-08-21T16:25:27+08:00">2020-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-09 18:26:42" itemprop="dateModified" datetime="2022-06-09T18:26:42+08:00">2022-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/">https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.betacat.io/post/2020/10/reverse-go-code-to-thrift-file/">https://blog.betacat.io/post/2020/10/reverse-go-code-to-thrift-file/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/08/21/golang/golang%20%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/21/golang/golang%20%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">golang 编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-21 16:25:27" itemprop="dateCreated datePublished" datetime="2020-08-21T16:25:27+08:00">2020-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-26 23:35:58" itemprop="dateModified" datetime="2023-02-26T23:35:58+08:00">2023-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h3><p>编译分为编译器的前端和后端，编译器的前端一般承担着词法分析、语法分析、类型检查和中间代码生成几部分工作，而编译器后端主要负责目标代码的生成和优化，也就是将中间代码翻译成目标机器能够运行的二进制机器码。</p>
<ul>
<li>lexical analysis - 词法分析</li>
<li>syntax analysis - 语法分析</li>
<li>semantic analysis - 语义分析</li>
<li>Intermediate Code generation - 中间代码生成</li>
<li>code optimization - 代码优化</li>
<li>machine code generation - 类型检查</li>
</ul>
<p>Go 的编译器在逻辑上可以被分成四个阶段：词法与语法分析、类型检查和 AST 转换、通用 SSA 生成和最后的机器代码生成。</p>
<h4 id="词法和语法分析-gt-AST"><a href="#词法和语法分析-gt-AST" class="headerlink" title="词法和语法分析 -&gt; AST"></a>词法和语法分析 -&gt; AST</h4><p>所有的编译过程其实都是从解析代码的源文件开始的，词法分析的作用就是解析源代码文件，它将文件中的字符串序列转换成 Token 序列，方便后面的处理和解析，我们一般会把执行词法分析的程序称为词法解析器（lexer）。</p>
<p>而语法分析的输入是词法分析器输出的 Token 序列，语法分析器会按照顺序解析 Token 序列，该过程会将词法分析生成的 Token 按照编程语言定义好的文法（Grammar）自下而上或者自上而下的规约，每一个 Go 的源代码文件最终会被归纳成一个 SourceFile 结构。语法分析会把 Token 序列转换成有意义的结构体，即语法树。<strong>Token 到上述抽象语法树（AST）的转换过程会用到语法解析器，每一个 AST 都对应着一个单独的 Go 语言文件，这个抽象语法树中包括当前文件属于的包名、定义的常量、结构体和函数等。</strong></p>
<h4 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h4><p>当拿到一组文件的抽象语法树之后，Go 语言的编译器会对语法树中定义和使用的类型进行检查，类型检查会按照以下的顺序分别验证和处理不同类型的节点：</p>
<ul>
<li>常量、类型和函数名及类型；</li>
<li>变量的赋值和初始化；</li>
<li>函数和闭包的主体；</li>
<li>哈希键值对的类型；</li>
<li>导入函数体；</li>
<li>外部的声明；</li>
</ul>
<p>类型检查阶段不止会对节点的类型进行验证，<strong>还会展开和改写一些内建的函数，例如 make 关键字在这个阶段会根据子树的结构被替换成 runtime.makeslice 或者 runtime.makechan 等函数。</strong></p>
<h4 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h4><p>在类型检查之后，编译器会通过 cmd&#x2F;compile&#x2F;internal&#x2F;gc.compileFunctions 编译整个 Go 语言项目中的全部函数，这些函数会在一个编译队列中等待几个 Goroutine 的消费，并发执行的 Goroutine 会将所有函数对应的抽象语法树转换成中间代码。</p>
<h4 id="机器码生成-gt-machine-code"><a href="#机器码生成-gt-machine-code" class="headerlink" title="机器码生成 -&gt; machine code"></a>机器码生成 -&gt; machine code</h4><p>Go 语言源代码的 src&#x2F;cmd&#x2F;compile&#x2F;internal 目录中包含了很多机器码生成相关的包，不同类型的 CPU 分别使用了不同的包生成机器码，其中包括 amd64、arm、arm64、mips、mips64、ppc64、s390x、x86 和 wasm，其中比较有趣的就是 WebAssembly（Wasm）7了。</p>
<p>作为一种在栈虚拟机上使用的二进制指令格式，它的设计的主要目标就是在 Web 浏览器上提供一种具有高可移植性的目标语言。Go 语言的编译器既然能够生成 Wasm 格式的指令，那么就能够运行在常见的主流浏览器中。</p>
<h2 id="golang-build"><a href="#golang-build" class="headerlink" title="golang build"></a>golang build</h2><h3 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h3><ul>
<li>编译：编译阶段逻辑上其实可以细分为<strong>预处理</strong>，<strong>编译</strong>，<strong>汇编</strong>三个阶段。整个编译阶段就是通过词法分析，语法分析和语义分析，把文本代码翻译成可重定位的目标文件(.o文件)的过程, 如上图。其中，编译优化也发生在这个阶段。<ul>
<li>预处理: 例如: 解析依赖库。</li>
<li>编译：将预处理后的代码，翻译成汇编代码(.s文件)。</li>
<li>汇编：将生成的汇编代码，翻译成可重定位的目标文件(.o文件，relocatable object file)。注意，目标文件纯粹就是字节块的集合。</li>
</ul>
</li>
<li>链接：链接阶段主要是通过<strong>符号解析</strong>和<strong>重定位</strong>把编译阶段生成的.o文件，链接生成可执行目标文件。<ul>
<li>符号解析：目标文件定义和引用符号。符号解析的目的是将每个符号引用和一个符号定义联系起来。</li>
<li>重定位：编译阶段生成的代码和数据节都是从地址零开始的，链接器通过把每个符号定义与一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指向这个存储器位置，从而重定向这些节(section)。进而生成可执行目标文件，如下图。</li>
</ul>
</li>
</ul>
<h3 id="golang编译链接的过程"><a href="#golang编译链接的过程" class="headerlink" title="golang编译链接的过程"></a>golang编译链接的过程</h3><p>通常情况下，在Linux系统中我们敲入 go build hello.go就会生成一个文件名为hello的ELF(可链接可执行)目标文件，通常这就是我们所期望的行为。</p>
<p>执行命令显示编译链接的过程： go build -v -x -work -o hello hello.go</p>
<ul>
<li>-v： 打印所编译的包的名字</li>
<li>-x： 打印编译期间所执行的命令</li>
<li>-work: 打印编译期间用于存放中间文件的临时目录，并且编译结束时不删除</li>
</ul>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="抽象语法树（AST）"><a href="#抽象语法树（AST）" class="headerlink" title="抽象语法树（AST）"></a>抽象语法树（AST）</h3><p>抽象语法树（Abstract Syntax Tree、AST），是源代码语法的结构的一种抽象表示，它用树状的方式表示编程语言的语法结构1。抽象语法树中的每一个节点都表示源代码中的一个元素，每一棵子树都表示一个语法元素.</p>
<h3 id="静态单赋值"><a href="#静态单赋值" class="headerlink" title="静态单赋值"></a>静态单赋值</h3><p>静态单赋值（Static Single Assignment、SSA）是中间代码的特性，如果中间代码具有静态单赋值的特性，那么每个变量就只会被赋值一次2。</p>
<h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><p>指令集是存储于CPU内部，用来引导CPU进行加减运算和控制计算机操作系统的一系列指令集合！</p>
<p>可以这样说指令集是软件与CPU之间的一个接口而CPU就是接口的实列化。</p>
<p>其实指令集就是一组汇编指令的集合，不同的CPU使用的指令集不同。</p>
<p>指令集就是电路，当电流流向不同的方向，根据路线到不同的电子元器件时，这就是指令集，指令集不存在任何一个器件里，cpu在设计时上面的线路构成了这些指令，所谓的指令其实就是电路路线。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/">draveness 大佬</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bjbz_cxy/article/details/76285837">指令集</a></p>
<p><a target="_blank" rel="noopener" href="https://chenwenke.cn/blog/2019/11/05/2019-11-05-go-build/">go build</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/08/21/golang/golang%20%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/21/golang/golang%20%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">golang 逃逸分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-21 16:25:27" itemprop="dateCreated datePublished" datetime="2020-08-21T16:25:27+08:00">2020-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-26 23:35:58" itemprop="dateModified" datetime="2023-02-26T23:35:58+08:00">2023-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p><strong>所谓逃逸分析（Escape analysis）是指由编译器决定内存分配的位置，不需要程序员指定。所谓逃逸，就是指对象逃到了堆内存上，而不是分配在 stack 上</strong></p>
<p>在函数中申请一个新的对象：</p>
<ul>
<li>如果分配在栈中，则函数执行结束可自动将内存回收；</li>
<li>如果分配在堆中，则函数执行结束可交给GC（垃圾回收）处理;</li>
</ul>
<h2 id="逃逸场景（什么情况才分配到堆中）"><a href="#逃逸场景（什么情况才分配到堆中）" class="headerlink" title="逃逸场景（什么情况才分配到堆中）"></a>逃逸场景（什么情况才分配到堆中）</h2><h3 id="指针逃逸"><a href="#指针逃逸" class="headerlink" title="指针逃逸"></a>指针逃逸</h3><p>Go可以返回局部变量指针，这其实是一个典型的变量逃逸案例，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StudentRegister</span><span class="params">(name <span class="type">string</span>, age <span class="type">int</span>)</span></span> *Student &#123;</span><br><span class="line">    s := <span class="built_in">new</span>(Student) <span class="comment">//局部变量s逃逸到堆</span></span><br><span class="line"></span><br><span class="line">    s.Name = name</span><br><span class="line">    s.Age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    StudentRegister(<span class="string">&quot;Jim&quot;</span>, <span class="number">18</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a>分析结果</h4><p>后面不再写分析结果, 感兴趣的读者可以自己执行逃逸分析编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go run -gcflags <span class="string">&quot;-m -l&quot;</span> demo.go</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">command-line-arguments</span></span><br><span class="line">.\demo.go:8:22: leaking param: name</span><br><span class="line">.\demo.go:9:10: new(Student) escapes to heap</span><br></pre></td></tr></table></figure>

<h3 id="栈空间不足逃逸（空间开辟过大）"><a href="#栈空间不足逃逸（空间开辟过大）" class="headerlink" title="栈空间不足逃逸（空间开辟过大）"></a>栈空间不足逃逸（空间开辟过大）</h3><p>实际上当栈空间不足以存放当前对象时或无法判断当前切片长度时会将对象分配到堆中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1000</span>)</span><br><span class="line">	data2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="comment">// 数据量太大， 逃逸到堆中</span></span><br><span class="line">	data3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000000</span>)</span><br><span class="line">	mapData := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	sliceMap(data1, data2, data3, mapData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceMap</span><span class="params">(data1 []<span class="type">int</span>, data2 []<span class="type">int</span>, data3 []<span class="type">int</span>, mapData <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	data1[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">	data2 = <span class="built_in">append</span>(data2, <span class="number">3</span>)</span><br><span class="line">	mapData[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> data1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态类型逃逸（不确定长度大小）"><a href="#动态类型逃逸（不确定长度大小）" class="headerlink" title="动态类型逃逸（不确定长度大小）"></a>动态类型逃逸（不确定长度大小）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;Escape&quot;</span></span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="闭包逃逸"><a href="#闭包逃逸" class="headerlink" title="闭包逃逸"></a>闭包逃逸</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		a, b = b, a+b</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := Fibonacci()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Fibonacci: %d\n&quot;</span>, f())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Fibonacci()函数中原本属于局部变量的a和b由于闭包的引用，不得不将二者放到堆上，以致产生逃逸。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go run -gcflags <span class="string">&quot;-m -l&quot;</span> demo.go</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">command-line-arguments</span></span><br><span class="line">.\demo.go:6:2: moved to heap: a</span><br><span class="line">.\demo.go:6:5: moved to heap: b</span><br><span class="line">.\demo.go:7:9: func literal escapes to heap</span><br><span class="line">.\demo.go:17:13: ... argument does not escape</span><br><span class="line">.\demo.go:17:34: f() escapes to heap</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>栈上分配内存比在堆中分配内存有更高的效率</li>
<li>栈上分配的内存不需要GC处理</li>
<li>堆上分配的内存使用完毕会交给GC处理</li>
<li>逃逸分析目的是决定内分配地址是栈还是堆</li>
<li>逃逸分析在编译阶段完成</li>
</ul>
<h3 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h3><p>提问：函数传递指针真的比传值效率高吗？</p>
<blockquote>
<p><em>我们知道传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加GC的负担，所以传递指针不一定是高效的。</em></p>
</blockquote>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>-gcflags “m” 参数，这个参数会打印逃逸分析的详细信息</p>
<p>-l 参数是防止函数identity被内联</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>sync.Pool</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://driverzhang.github.io/post/go%E7%9A%84sync.pool%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E6%B1%A0/">原文</a></p>
<p><a target="_blank" rel="noopener" href="https://studygolang.com/articles/30205#reply0">golang 逃逸分析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/08/21/golang/peg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/21/golang/peg/" class="post-title-link" itemprop="url">peg</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-21 16:25:27" itemprop="dateCreated datePublished" datetime="2020-08-21T16:25:27+08:00">2020-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-10 18:29:27" itemprop="dateModified" datetime="2022-06-10T18:29:27+08:00">2022-06-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/252343056">https://zhuanlan.zhihu.com/p/252343056</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/chinesehuazhou/guido_blog_translation/blob/master/%E8%A7%A3%E6%9E%90%E5%99%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%EF%BC%9APEG%20%E8%A7%A3%E6%9E%90%E5%99%A8.md">https://github.com/chinesehuazhou/guido_blog_translation/blob/master/%E8%A7%A3%E6%9E%90%E5%99%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%EF%BC%9APEG%20%E8%A7%A3%E6%9E%90%E5%99%A8.md</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/08/19/distribute/mysql%E9%9B%86%E7%BE%A4%E4%B9%8B%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/19/distribute/mysql%E9%9B%86%E7%BE%A4%E4%B9%8B%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">mysql集群之集群搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-19 20:45:09" itemprop="dateCreated datePublished" datetime="2020-08-19T20:45:09+08:00">2020-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h2><p>MySQL 5.6 开始主从复制有两种方式：基于日志（binlog）和 基于 GTID（全局事务标示符）。开启主库的执行日志功能，然后从库读取主库的日志信息，然后将主库执行过的SQL语句在从库上面执行一遍就做到主从分离，主从数据保持一致，起到备份数据的功能。</p>
<p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/a5d8d8481cd54d12a68741986ca10fbc.png"></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h4 id="1-负载均衡"><a href="#1-负载均衡" class="headerlink" title="1. 负载均衡"></a>1. 负载均衡</h4><p>通常情况下，会使用 <strong>主服务器</strong> 对数据进行 <strong>更新</strong>、<strong>删除</strong> 和 <strong>新建</strong> 等操作，而将 <strong>查询</strong> 工作落到 <strong>从库</strong> 头上。</p>
<h4 id="2-异地容灾备份"><a href="#2-异地容灾备份" class="headerlink" title="2. 异地容灾备份"></a>2. 异地容灾备份</h4><p>可以将主服务器上的数据同步到 <strong>异地从服务器</strong> 上，极大地提高了 <strong>数据安全性</strong>。</p>
<h4 id="3-高可用"><a href="#3-高可用" class="headerlink" title="3. 高可用"></a>3. 高可用</h4><p>数据库的复制功能实现了 <strong>主服务器</strong> 与 <strong>从服务器间</strong> 的数据同步，一旦主服务器出了 <strong>故障</strong>，从服务器立即担当起主服务器的角色，保障系统持续稳定运作。</p>
<h4 id="4-高扩展性"><a href="#4-高扩展性" class="headerlink" title="4. 高扩展性"></a>4. 高扩展性</h4><p><strong>主从复制</strong> 模式支持 <code>2</code> 种扩展方式:</p>
<ul>
<li><strong>scale-up</strong></li>
</ul>
<p>向上扩展或者 <strong>纵向扩展</strong>，主要是提供比现在服务器 <strong>性能更好</strong> 的服务器，比如 <strong>增加</strong> <code>CPU</code> 和 <strong>内存</strong> 以及 <strong>磁盘阵列</strong>等，因为有多台服务器，所以可扩展性比单台更大。</p>
<ul>
<li><strong>scale-out</strong></li>
</ul>
<p>向外扩展或者 <strong>横向扩展</strong>，是指增加 <strong>服务器数量</strong> 的扩展，这样主要能分散各个服务器的压力。</p>
<h3 id="主从模式的缺点"><a href="#主从模式的缺点" class="headerlink" title="主从模式的缺点"></a>主从模式的缺点</h3><h4 id="1-成本增加"><a href="#1-成本增加" class="headerlink" title="1. 成本增加"></a>1. 成本增加</h4><p>搭建主从肯定会增加成本，毕竟一台服务器和两台服务器的成本完全不同，另外由于主从必须要开启 <strong>二进制日志</strong>，所以也会造成额外的 <strong>性能消耗</strong>。</p>
<h4 id="2-数据延迟"><a href="#2-数据延迟" class="headerlink" title="2. 数据延迟"></a>2. 数据延迟</h4><p><strong>从库</strong> 从 <strong>主库</strong> 复制数据肯定是会有一定的 <strong>数据延迟</strong> 的。所以当刚插入就出现查询的情况，可能查询不出来。当然如果是插入者自己查询，那么可以直接从 <strong>主库</strong> 中查询出来，当然这个也是需要用代码来控制的。</p>
<h4 id="3-写入更慢"><a href="#3-写入更慢" class="headerlink" title="3. 写入更慢"></a>3. 写入更慢</h4><p><strong>主从复制</strong> 主要是针对 <strong>读远大于写</strong> 或者对 <strong>数据备份实时性</strong> 要求较高的系统中。因为 <strong>主服务器</strong> 在写中需要更多操作，而且 <strong>只有一台</strong> 可以写入的 <strong>主库</strong>，所以写入的压力并不能被分散。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/08/19/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B%E4%B9%8B%20elasticsearch%E9%9B%86%E7%BE%A4%E4%B9%8B%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/19/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B%E4%B9%8B%20elasticsearch%E9%9B%86%E7%BE%A4%E4%B9%8B%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">【分布式系统实例】elasticsearch集群之集群搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-19 20:45:09" itemprop="dateCreated datePublished" datetime="2020-08-19T20:45:09+08:00">2020-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 14:26:22" itemprop="dateModified" datetime="2022-09-22T14:26:22+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h3><ul>
<li><p><code>node.master</code><br>是否为主节点，选项为true或false，当为true时在集群启动时该节点为主节点，在宕机或任务挂掉之后会选举新的主节点，恢复后该节点依然为主节点</p>
</li>
<li><p><code>node.data</code><br>是否处理数据，选项为true或false。负责数据的相关操作</p>
</li>
<li><p><code>http.port</code><br><strong>对外访问的端口号</strong>，默认为<code>9200</code>，所以外界访问该节点一般为<code>http://ip:9200/</code></p>
</li>
<li><p><code>transport.tcp.port</code><br><strong>集群间通信的端口号</strong>，默认为<code>9300</code></p>
</li>
</ul>
<h2 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h2><p><strong>两类应用场景：</strong></p>
<p>A. 用于构建业务搜索功能模块，且多是垂直领域的搜索。数据量级几千万到数十亿级别。一般2-4台机器的规模。</p>
<p>B. 用于大规模数据的实时 OLAP（联机处理分析），经典的如ELK Stack，数据规模可能达到千亿或更多。几十到上百节点的规模。</p>
<h3 id="集群中的节点角色如何分配？"><a href="#集群中的节点角色如何分配？" class="headerlink" title="集群中的节点角色如何分配？"></a>集群中的节点角色如何分配？</h3><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><ul>
<li><strong>Master</strong> <ul>
<li>node.master: true 节点可以作为主节点</li>
</ul>
</li>
<li><strong>DataNode</strong><ul>
<li>node.data: true 默认是数据节点。</li>
</ul>
</li>
<li><strong>Coordinate node</strong> 协调节点<ul>
<li>​    如果仅担任协调节点，将上两个配置设为false。</li>
</ul>
</li>
</ul>
<h4 id="如何分配"><a href="#如何分配" class="headerlink" title="如何分配"></a>如何分配</h4><p>A. 小规模集群，不需严格区分。</p>
<p>B. 中大规模集群（十个以上节点），应考虑单独的角色充当。特别并发查询量大，查询的合并量大，可以增加独立的协调节点。角色分开的好处是分工分开，不互影响。如不会因协调角色负载过高而影响数据节点的能力。</p>
<h3 id="docker-搭建集群"><a href="#docker-搭建集群" class="headerlink" title="docker 搭建集群"></a>docker 搭建集群</h3><p>参看： go-mod&#x2F;k8s&#x2F;docker&#x2F;elsaitcsearch&#x2F;cluster</p>
<h4 id="验证集群"><a href="#验证集群" class="headerlink" title="验证集群"></a>验证集群</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">集群健康</span></span><br><span class="line">curl -X GET &quot;localhost:9200/_cat/health?v&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">集群配置</span></span><br><span class="line">curl -X GET &quot;localhost:9200/_cluster/settings?include_defaults&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">节点信息</span></span><br><span class="line">curl &quot;http://127.0.0.1:9200/_cat/nodes?v&quot;</span><br></pre></td></tr></table></figure>

<h3 id="如何避免脑裂问题"><a href="#如何避免脑裂问题" class="headerlink" title="如何避免脑裂问题"></a>如何避免脑裂问题</h3><p>一个集群中只有一个A主节点，A主节点因为需要处理的东西太多或者网络过于繁忙，从而导致其他从节点ping不通A主节点，这样其他从节点就会认为A主节点不可用了，就会重新选出一个新的主节点B。过了一会A主节点恢复正常了，这样就出现了两个主节点，导致一部分数据来源于A主节点，另外一部分数据来源于B主节点，出现数据不一致问题，这就是<strong>脑裂</strong>。</p>
<p><strong>一个基本的原则是这里需要设置成 N&#x2F;2+1, N是急群中节点的数量。 例如在一个三节点的集群中， minimum_master_nodes应该被设为 3&#x2F;2 + 1 &#x3D; 2(四舍五入)。</strong></p>
<h3 id="索引应该设置多少个分片"><a href="#索引应该设置多少个分片" class="headerlink" title="索引应该设置多少个分片"></a>索引应该设置多少个分片</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018606414">docker搭建elasticsearch</a></p>
<p><a target="_blank" rel="noopener" href="https://www.shuzhiduo.com/A/pRdBwAYDzn/">docker 搭建 elasticsearch7 </a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/08/19/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B%E4%B9%8B%20elasticsearch%E9%9B%86%E7%BE%A4%E4%B9%8B%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/19/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B%E4%B9%8B%20elasticsearch%E9%9B%86%E7%BE%A4%E4%B9%8B%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">分布式系统实例之 elasticsearch集群之概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-19 20:45:09" itemprop="dateCreated datePublished" datetime="2020-08-19T20:45:09+08:00">2020-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-20 10:31:33" itemprop="dateModified" datetime="2023-01-20T10:31:33+08:00">2023-01-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="elasticsearch是什么"><a href="#elasticsearch是什么" class="headerlink" title="elasticsearch是什么"></a>elasticsearch是什么</h3><p>官网：<code>Elasticsearch 是一个实时的分布式搜索分析引擎，它能让你以前所未有的速度和规模，去探索你的数据。 它被用作全文检索、结构化搜索、分析以及这三个功能的组合：</code></p>
<ul>
<li>使用 java 语言开发的一套开源的全文搜索引擎</li>
<li>用于搜索、日志管理、安全分析、指标分析、业务分析、应用性能监控等多个领域</li>
<li>底层基于 <a href="https://link.zhihu.com/?target=https://lucene.apache.org/">Lucene</a> 开源库开发，提供 restAPI，可以被任何语言调用</li>
<li>支持分布式部署，可水平扩展</li>
</ul>
<h3 id="集群（cluster）和节点（node）"><a href="#集群（cluster）和节点（node）" class="headerlink" title="集群（cluster）和节点（node）"></a>集群（cluster）和节点（node）</h3><p><strong>集群（Cluster）</strong></p>
<ul>
<li>Elasticsearch 集群部署使其可以随时可用和并按需扩容，并保证数据的安全性</li>
<li>通过启动参数 cluster.name 修改集群名称，默认名称为 elasticsearch</li>
</ul>
<p><strong>节点(Node)</strong></p>
<ul>
<li>一个节点是一个 Java 进程实例，一台机器可以运行多个实例，一般情况下一台机器只允许一个节点</li>
<li>一个集群有一个或者多个节点</li>
<li>通过启动参数 node.name 定义节点名称</li>
<li>每个节点都保存了集群的状态信息，只有 Master 节点可以<strong>修改集群的状态信息</strong></li>
<li>集群状态信息包括：<strong>所有节点信息、索引、Mapping、Settings、分片路由等信息</strong></li>
</ul>
<h4 id="三种类型的节点"><a href="#三种类型的节点" class="headerlink" title="三种类型的节点"></a>三种类型的节点</h4><h5 id="Master-eligible-节点："><a href="#Master-eligible-节点：" class="headerlink" title="Master-eligible 节点："></a>Master-eligible 节点：</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 每个节点启动，默认自己是一个 Master-eligible 节点</span><br><span class="line">- 可以通过启动参数 node.master: false 禁止当前启动节点是 Master-eligible 节点</span><br><span class="line">- 所有 Master-eligible 都可以参与选主流程，成为 Master 节点</span><br></pre></td></tr></table></figure>

<h5 id="Data-节点："><a href="#Data-节点：" class="headerlink" title="Data 节点："></a>Data 节点：</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 保存分片数据的节点</span><br><span class="line">- 在数据扩展上起了很大的作用</span><br><span class="line">- 通过启动参数 node.data 设置</span><br></pre></td></tr></table></figure>

<h5 id="Coordinating-节点"><a href="#Coordinating-节点" class="headerlink" title="Coordinating 节点"></a>Coordinating 节点</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 接收客户端请求，将请求分发到合适的节点，最终再对结果进行汇集</span><br><span class="line">- 每个节点默认都是 Coordinating 节点</span><br></pre></td></tr></table></figure>

<h4 id="如何启动节点"><a href="#如何启动节点" class="headerlink" title="如何启动节点"></a>如何启动节点</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/elasticsearch -E node.name=node1 -E cluster.name=myEs -d</span><br><span class="line">bin/elasticsearch -E node.name=node2 -E cluster.name=myEs -d</span><br><span class="line">bin/elasticsearch -E node.name=node3 -E cluster.name=myEs -d</span><br></pre></td></tr></table></figure>

<h3 id="索引（Index）-gt-table"><a href="#索引（Index）-gt-table" class="headerlink" title="索引（Index）-&gt; table"></a>索引（Index）-&gt; table</h3><ul>
<li>一个集群下面可以新建多个索引，索引体现了逻辑空间概念</li>
<li>索引是一类相似文档的集合，是文档的容器，<strong>类比关系型数据库中的一张表的 Schema 的概念</strong></li>
<li>每个索引有自己的 Mapping 用于定义文档的字段名和字段类型</li>
<li>每个索引有自己的 Settings 用于定义不同的数据分布，也就是索引使用分片的情况</li>
</ul>
<h3 id="类型（type）"><a href="#类型（type）" class="headerlink" title="类型（type）"></a>类型（type）</h3><p>Elasticsearch 7.x 版本已废弃 type 的概念，默认所有 index 只具备 _doc 一个类型，因此该概念可以不用深究。</p>
<h4 id="为什么现在要移除type？"><a href="#为什么现在要移除type？" class="headerlink" title="为什么现在要移除type？"></a>为什么现在要移除type？</h4><ul>
<li>在关系型数据库中table是独立的（独立存储），但es中同一个index中不同type是存储在同一个索引中的（lucene的索引文件），因此不同type中相同名字的字段的定义（mapping）必须一致。</li>
<li>不同类型的“记录”存储在同一个index中，会影响lucene的压缩性能。</li>
</ul>
<h3 id="分片（Shard）"><a href="#分片（Shard）" class="headerlink" title="分片（Shard）"></a>分片（Shard）</h3><ul>
<li>分片是物理空间概念，索引中的数据都分布在分片上</li>
<li>一个分片就是运行的一个 Lucene 的实例</li>
<li>为了支持更大量的数据，索引一般会按某个维度分成多个部分，每个部分就是一个分片，分片被节点(Node)管理。一个节点(Node)一般会管理多个分片，这些分片可能是属于同一份索引</li>
</ul>
<p>分片有两种，主分片和副本分片。</p>
<h4 id="副本分片（分片副本）"><a href="#副本分片（分片副本）" class="headerlink" title="副本分片（分片副本）"></a>副本分片（分片副本）</h4><p>副本(Replica)：同一个分片(Shard)的备份数据，一个分片可能会有0个或多个副本，这些副本中的数据保证强一致或最终一致。</p>
<h4 id="设置分片"><a href="#设置分片" class="headerlink" title="设置分片"></a>设置分片</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">curl -X DELETE &#x27;localhost:9200/accounts&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">number_of_shards 分片数，不可修改， number_of_replicas 副本数，可以修改</span></span><br><span class="line">curl -X PUT -H &quot;Content-Type:application/json&quot; &#x27;localhost:9200/accounts&#x27; --data &#x27;&#123;</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;number_of_shards&quot; :   2,</span><br><span class="line">        &quot;number_of_replicas&quot; : 0 </span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#x27; </span><br><span class="line"></span><br><span class="line">curl &quot;localhost:9200/accounts?pretty&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改副本数</span></span><br><span class="line">curl -X PUT -H &quot;Content-Type:application/json&quot; &#x27;localhost:9200/accounts/_settings&#x27; --data &#x27;&#123;</span><br><span class="line">    &quot;number_of_replicas&quot; : 1 </span><br><span class="line">&#125;&#x27; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再查一次可以看到有两个分片，一个副本</span></span><br><span class="line">curl &quot;localhost:9200/accounts?pretty&quot;</span><br><span class="line"></span><br><span class="line">curl &quot;localhost:9200/accounts/_cat/shards?pretty&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">现在的状况</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拥有两个主分片，加上每个主分片的一个副本，总共给予我们四个分片</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">尝试修改分片，会失败</span></span><br><span class="line">curl -X PUT -H &quot;Content-Type:application/json&quot; &#x27;localhost:9200/accounts/_settings&#x27; --data &#x27;&#123;</span><br><span class="line">    &quot;number_of_shards&quot; : 3</span><br><span class="line">&#125;&#x27; </span><br></pre></td></tr></table></figure>

<h3 id="文档（Document）"><a href="#文档（Document）" class="headerlink" title="文档（Document）"></a>文档（Document）</h3><ul>
<li>文档是所有可搜索数据的最小单位，类似关系数据库中某张表中的一行记录</li>
<li>文档会被序列化成 JSON 格式，JSON 对象由字段组成</li>
<li>每个字段都有对应的字段类型，类型可以自己指定，也可以使用 ElasticSearch 自动推算</li>
<li>JSON 文档支持数组和嵌套</li>
<li>每个文档都有一个唯一性 ID，可以自己指定，也可以系统自动生成</li>
</ul>
<h4 id="一个文档主要的元信息"><a href="#一个文档主要的元信息" class="headerlink" title="一个文档主要的元信息"></a>一个文档主要的元信息</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. _index: 文档所属的索引名</span><br><span class="line">2. _type: 文档所属的类型名</span><br><span class="line">3. _id: 文档的唯一ID</span><br><span class="line">4. _source: 文档存储的 Json 数据</span><br><span class="line">5. _version：文档的版本信息</span><br><span class="line">6. _score: 相关性打分</span><br></pre></td></tr></table></figure>

<h3 id="Mapping-（索引映射）"><a href="#Mapping-（索引映射）" class="headerlink" title="Mapping （索引映射）"></a>Mapping （索引映射）</h3><p>见 elasticesearch 索引mapping</p>
<h3 id="Index-Template-（索引模板）"><a href="#Index-Template-（索引模板）" class="headerlink" title="Index Template （索引模板）"></a>Index Template （索引模板）</h3><p>见 elasticesearch 索引模板</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.huaweicloud.com/elasticsearch/7.7.0/elasticsearch-7.7.0-windows-x86_64.zip</span><br><span class="line">unzip elasticsearch-5.5.1.zip</span><br><span class="line">cd elasticsearch-5.5.1/ </span><br><span class="line">elasticsearch</span><br></pre></td></tr></table></figure>

<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="集群信息查询"><a href="#集群信息查询" class="headerlink" title="集群信息查询"></a>集群信息查询</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &#x27;http://localhost:9200/_cat/indices?v&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="新建和删除-Index"><a href="#新建和删除-Index" class="headerlink" title="新建和删除 Index"></a>新建和删除 Index</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建</span></span><br><span class="line">curl -X PUT &#x27;localhost:9200/weather&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除</span></span><br><span class="line">curl -X DELETE &#x27;localhost:9200/weather&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="index-操作"><a href="#index-操作" class="headerlink" title="index 操作"></a>index 操作</h3><p>按理说默认是 type， 但是这里使用 type &#x3D; person</p>
<h4 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h4><p>向指定的 &#x2F;Index&#x2F;Type 发送 PUT 请求，就可以在 Index 里面新增一条记录。新增记录的时候，也可以不指定 Id，这时要改成 POST 请求。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT -H &quot;Content-Type:application/json&quot; &#x27;localhost:9200/accounts/person/1&#x27; --data &#x27;&#123;</span><br><span class="line">  &quot;user&quot;: &quot;zhangsan&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;engineer&quot;,</span><br><span class="line">  &quot;desc&quot;: &quot;task DBA&quot;,</span><br><span class="line">  &quot;num&quot;: 4</span><br><span class="line">&#125;&#x27; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">id</span> 随机</span></span><br><span class="line">curl -X POST -H &quot;Content-Type:application/json&quot; &#x27;localhost:9200/accounts/person&#x27; --data &#x27;&#123;</span><br><span class="line">  &quot;user&quot;: &quot;li 4&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;engineer&quot;,</span><br><span class="line">  &quot;desc&quot;: &quot;task HK&quot;,</span><br><span class="line">  &quot;num&quot;: 6</span><br><span class="line">&#125;&#x27; </span><br><span class="line"></span><br><span class="line">curl -X POST -H &quot;Content-Type:application/json&quot; &#x27;localhost:9200/articles/_doc&#x27; --data &#x27;&#123;</span><br><span class="line">  &quot;title&quot;: &quot;how to make millions&quot;,</span><br><span class="line">  &quot;tag&quot;: &quot;starred&quot;,</span><br><span class="line">  &quot;date&quot;: &quot;2014-01-01&quot;</span><br><span class="line">&#125;&#x27; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量写数据</span></span><br><span class="line">for i in `seq 0 10`; do \</span><br><span class="line">curl -X POST -H &quot;Content-Type:application/json&quot; &#x27;localhost:9200/accounts/person&#x27; --data &#x27;&#123;</span><br><span class="line">  &quot;user&quot;: &quot;li 4&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;engineer&quot;,</span><br><span class="line">  &quot;desc&quot;: &quot;task HK&quot;,</span><br><span class="line">  &quot;num&quot;: 6</span><br><span class="line">&#125;&#x27;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>返回</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span><span class="string">&quot;accounts&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;person&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span> <span class="comment">// 由于传入了id， 所以这里id按我们传入的给</span></span><br><span class="line">    <span class="attr">&quot;_version&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span><span class="string">&quot;created&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_shards&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;successful&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;failed&quot;</span><span class="punctuation">:</span><span class="number">0</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_seq_no&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_primary_term&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询， 向/Index/Type/Id发出 GET 请求，就可以查看这条记录。</span></span><br><span class="line">curl &#x27;localhost:9200/accounts/person/1&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以通过自定义唯一<span class="built_in">id</span>(dy_order_id)来查询</span></span><br><span class="line">curl &#x27;localhost:9200/accounts/person/dy_order_id&#x27;</span><br></pre></td></tr></table></figure>

<p>返回</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span><span class="string">&quot;accounts&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;person&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_version&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_seq_no&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_primary_term&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;found&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span><span class="string">&quot;zhangsan&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;engineer&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span><span class="string">&quot;task DBA&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除记录就是发出 DELETE 请求。</span></span><br><span class="line">curl -X DELETE &#x27;localhost:9200/accounts/person/1&#x27;</span><br></pre></td></tr></table></figure>

<p>返回</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span><span class="string">&quot;accounts&quot;</span><span class="punctuation">,</span><span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;person&quot;</span><span class="punctuation">,</span><span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span><span class="attr">&quot;_version&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span><span class="attr">&quot;result&quot;</span><span class="punctuation">:</span><span class="string">&quot;deleted&quot;</span><span class="punctuation">,</span><span class="attr">&quot;_shards&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;total&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span><span class="attr">&quot;successful&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;failed&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;_seq_no&quot;</span><span class="punctuation">:</span><span class="number">3</span><span class="punctuation">,</span><span class="attr">&quot;_primary_term&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT -H <span class="string">&quot;Content-Type:application/json&quot;</span> &#x27;localhost<span class="punctuation">:</span><span class="number">9200</span>/accounts/person/<span class="number">1</span>&#x27; -d &#x27;</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;user&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;zhang 3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;engineer&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;desc&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;DBA&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;num&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span>&#x27; </span><br></pre></td></tr></table></figure>

<p>返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;accounts&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>,<span class="string">&quot;_id&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="string">&quot;_version&quot;</span>:<span class="number">1</span>,<span class="string">&quot;result&quot;</span>:<span class="string">&quot;created&quot;</span>,<span class="string">&quot;_shards&quot;</span>:&#123;<span class="string">&quot;total&quot;</span>:<span class="number">2</span>,<span class="string">&quot;successful&quot;</span>:<span class="number">1</span>,<span class="string">&quot;failed&quot;</span>:<span class="number">0</span>&#125;,<span class="string">&quot;_seq_no&quot;</span>:<span class="number">4</span>,<span class="string">&quot;_primary_term&quot;</span>:<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本高级查询"><a href="#基本高级查询" class="headerlink" title="基本高级查询"></a>基本高级查询</h2><h3 id="返回所有记录"><a href="#返回所有记录" class="headerlink" title="返回所有记录"></a>返回所有记录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl &#x27;localhost:9200/accounts/person/_search&#x27;</span><br><span class="line"></span><br><span class="line">curl &#x27;localhost:9200/share_2022_5_53/_doc/_search&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="查询和过滤的区别"><a href="#查询和过滤的区别" class="headerlink" title="查询和过滤的区别"></a>查询和过滤的区别</h3><p>当使用于 过滤情况 时，查询被设置成一个“不评分”或者“过滤”查询。即，这个查询只是简单的问一个问题：“这篇文档是否匹配？”。回答也是非常的简单，yes 或者 no ，二者必居其一。当使用于 <em>查询情况</em> 时，查询就变成了一个“评分”的查询。和不评分的查询类似，也要去判断这个文档是否匹配，同时它还需要判断这个文档匹配的有 <em>多好</em>（匹配程度如何）。 </p>
<p>过滤查询（Filtering queries）只是简单的检查包含或者排除，这就使得计算起来非常快。考虑到至少有一个过滤查询（filtering query）的结果是 “稀少的”（很少匹配的文档），并且经常使用不评分查询（non-scoring queries），结果会被缓存到内存中以便快速读取，所以有各种各样的手段来优化查询结果。</p>
<p>相反，评分查询（scoring queries）不仅仅要找出匹配的文档，还要计算每个匹配文档的相关性，计算相关性使得它们比不评分查询费力的多。同时，查询结果并不缓存。</p>
<p>多亏倒排索引（inverted index），一个简单的评分查询在匹配少量文档时可能与一个涵盖百万文档的filter表现的一样好，甚至会更好。但是在一般情况下，一个filter 会比一个评分的query性能更优异，并且每次都表现的很稳定。</p>
<h4 id="如何选择查询与过滤"><a href="#如何选择查询与过滤" class="headerlink" title="如何选择查询与过滤"></a>如何选择查询与过滤</h4><p>通常的规则是，使用查询（query）语句来进行 全文 搜索或者其它任何需要影响 相关性得分 的搜索。除此以外的情况都使用过滤（filters)。</p>
<h4 id="bool-查询和过滤的区别"><a href="#bool-查询和过滤的区别" class="headerlink" title="bool 查询和过滤的区别"></a>bool 查询和过滤的区别</h4><p>bool 过滤的子句使用 term, range 等过滤语法。 bool 查询使用 match， multi_match等子句</p>
<h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><h4 id="term-过滤"><a href="#term-过滤" class="headerlink" title="term 过滤"></a>term 过滤</h4><p>term主要用于精确匹配哪些值，比如数字，日期，布尔值或 not_analyzed 的字符串(未经切词的文本数据类型)： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Content-Type:application/json&quot; &#x27;localhost:9200/accounts/person/_search&#x27; --data &#x27;&#123;&quot;query&quot;: &#123;&quot;term&quot;: &#123;&quot;num&quot;: 4&#125;&#125;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">curl -H &quot;Content-Type:application/json&quot; &quot;http://10.23.111.70:9200/personal_orders/_doc/_search&quot; --data &#x27;&#123;&quot;query&quot;: &#123;&quot;term&quot;: &#123;&quot;SellerID&quot;: 1901625824&#125;&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="terms-过滤"><a href="#terms-过滤" class="headerlink" title="terms 过滤"></a>terms 过滤</h4><p>terms 跟 term 有点类似，但 terms 允许指定多个匹配条件。 如果某个字段指定了多个值，那么文档</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Content-Type:application/json&quot; &#x27;localhost:9200/accounts/person/_search&#x27; --data &#x27;&#123;&quot;query&quot;: &#123;&quot;terms&quot;: &#123;&quot;num&quot;: [3, 4]&#125;&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="range-过滤"><a href="#range-过滤" class="headerlink" title="range 过滤"></a>range 过滤</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Content-Type:application/json&quot; &#x27;localhost:9200/accounts/person/_search&#x27; --data &#x27;&#123;&quot;query&quot;: &#123;&quot;range&quot;: &#123;&quot;num&quot;: &#123;&quot;gte&quot;: 4&#125;&#125;&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="exists-和-missing-过滤"><a href="#exists-和-missing-过滤" class="headerlink" title="exists 和 missing 过滤"></a>exists 和 missing 过滤</h4><p>exists 和 missing 过滤可以用于查找文档中是否包含指定字段或没有某个字段，类似于SQL语句中的IS_NULL条件. </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Content-Type:application/json&quot; &#x27;localhost:9200/accounts/person/_search&#x27; --data &#x27;&#123;&quot;exists&quot;: &#123;&quot;field&quot;: &quot;title&quot;&#125;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">curl -H &quot;Content-Type:application/json&quot; &#x27;localhost:9200/accounts/person/_search&#x27; --data &#x27;&#123;&quot;exists&quot;: &#123;&quot;field&quot;: &quot;title1&quot;&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="bool-过滤（should-must-must-not）"><a href="#bool-过滤（should-must-must-not）" class="headerlink" title="bool 过滤（should, must, must_not）"></a>bool 过滤（should, must, must_not）</h4><p>bool 过滤器将多个小查询组合成一个大查询，查询语法有如下特点：</p>
<ol>
<li>子查询可以任意顺序出现</li>
<li>可以嵌套多个查询，包括bool 查询也可以</li>
<li>如果bool查询中没有must条件，should中必须至少满足一条才会返回结果。</li>
</ol>
<p>bool 过滤器包括四个操作符，<code>must</code>、<code>must_not</code>、<code>should</code>和<code>filter</code>，这四个都是数组，数组里面是对应的判断条件</p>
<ul>
<li>must： 过滤子句，必须匹配。贡献算分，相当于 and。</li>
<li>must_not：过滤子句，必须不能匹配，但不贡献算分，相当于 not。</li>
<li>should： 选择性匹配，至少满足一条。贡献算分，相当于 or。</li>
<li>filter： 过滤子句，必须匹配，但不贡献算分。 相当于 and， 和 must 非常像，但是不计算得分</li>
</ul>
<p>官方例子</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">POST _search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot; : &#123;</span><br><span class="line">      &quot;must&quot; : [</span><br><span class="line">        &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot; &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;filter&quot;: [</span><br><span class="line">        &quot;term&quot; : &#123; &quot;tag&quot; : &quot;tech&quot; &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;must_not&quot; : [</span><br><span class="line">        &quot;range&quot; : &#123;</span><br><span class="line">          &quot;age&quot; : &#123; &quot;gte&quot; : 10, &quot;lte&quot; : 20 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;should&quot; : [</span><br><span class="line">        &#123; &quot;term&quot; : &#123; &quot;tag&quot; : &quot;wow&quot; &#125; &#125;,</span><br><span class="line">        &#123; &quot;term&quot; : &#123; &quot;tag&quot; : &quot;elasticsearch&quot; &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;minimum_should_match&quot; : 1,</span><br><span class="line">      &quot;boost&quot; : 1.0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：学就完事了</span><br><span class="line">链接：https://juejin.cn/post/6871109774566653965</span><br><span class="line">来源：稀土掘金</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><h4 id="match-查询"><a href="#match-查询" class="headerlink" title="match 查询"></a>match 查询</h4><p>match查询是一个标准查询，不管你需要全文本查询还是精确查询基本上都要用到它。</p>
<p>如果你使用 match 查询一个全文本字段，它会在真正查询之前用分析器先分析match一下查询字符：</p>
<p>如果用match下指定了一个确切值，在遇到数字，日期，布尔值或者not_analyzed 的字符串时，它将为你搜索你给定的值：</p>
<p>做精确匹配搜索时，你最好用过滤语句，因为过滤语句可以缓存数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Content-Type:application/json&quot; &#x27;localhost:9200/accounts/person/_s</span><br><span class="line">earch&#x27; --data &#x27;&#123;&quot;query&quot;: &#123;&quot;match&quot;: &#123;&quot;title&quot;: &quot;engineer&quot;&#125;&#125;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">curl -H &quot;Content-Type:application/json&quot; &#x27;localhost:9200/accounts/person/_search&#x27; --data &#x27;&#123;&quot;query&quot;: &#123;&quot;match&quot;: &#123;&quot;desc&quot;: &quot;HK&quot;&#125;&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="multi-match-查询"><a href="#multi-match-查询" class="headerlink" title="multi_match 查询"></a>multi_match 查询</h4><p>multi_match查询允许你做match查询的基础上同时搜索多个字段，在多个字段中同时查一个：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Content-Type:application/json&quot; &#x27;localhost:9200/accounts/person/_search&#x27; --data &#x27;&#123;</span><br><span class="line">&quot;query&quot;: &#123;&quot;multi_match&quot;: &#123;&quot;query&quot;: &quot;engineer&quot;,&quot;fields&quot;: [&quot;title&quot;, &quot;desc&quot;]&#125;&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套查询（内部对象和嵌套对象）"><a href="#嵌套查询（内部对象和嵌套对象）" class="headerlink" title="嵌套查询（内部对象和嵌套对象）"></a>嵌套查询（内部对象和嵌套对象）</h3><h4 id="nested-查询"><a href="#nested-查询" class="headerlink" title="nested 查询"></a>nested 查询</h4><h5 id="object新增-object-索引"><a href="#object新增-object-索引" class="headerlink" title="object新增(object 索引)"></a>object新增(object 索引)</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">curl -X DELETE &#x27;localhost:9200/my_index&#x27;</span><br><span class="line">curl -H &quot;Content-Type:application/json&quot; &quot;localhost:9200/my_index/blogpost/1&quot; --data &#x27;&#123;</span><br><span class="line">  &quot;title&quot;: &quot;Nest eggs&quot;,</span><br><span class="line">  &quot;body&quot;:  &quot;Making your money work...&quot;,</span><br><span class="line">  &quot;tags&quot;:  [ &quot;cash&quot;, &quot;shares&quot; ],</span><br><span class="line">  &quot;comments&quot;: [ </span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;:    &quot;John Smith&quot;,</span><br><span class="line">      &quot;comment&quot;: &quot;Great article&quot;,</span><br><span class="line">      &quot;age&quot;:     28,</span><br><span class="line">      &quot;stars&quot;:   4,</span><br><span class="line">      &quot;date&quot;:    &quot;2014-09-01&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;:    &quot;Alice White&quot;,</span><br><span class="line">      &quot;comment&quot;: &quot;More like this please&quot;,</span><br><span class="line">      &quot;age&quot;:     31,</span><br><span class="line">      &quot;stars&quot;:   5,</span><br><span class="line">      &quot;date&quot;:    &quot;2014-10-22&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br><span class="line">curl &quot;localhost:9200/my_index/_mapping?pretty&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果我们依赖字段自动映射,那么 comments 字段会自动映射为 object 类型。</span></span><br></pre></td></tr></table></figure>

<h5 id="object查询失败"><a href="#object查询失败" class="headerlink" title="object查询失败"></a>object查询失败</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">没有查到，符合预期，需要使用 nested， 正如我们在 对象数组 中讨论的一样,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">出现上面这种问题的原因是 JSON 格式的文档被处理成如下的扁平式键值对的结构。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  <span class="string">&quot;comments.comment&quot;</span>: [ article, great, like, more, please, this ],</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="string">&quot;comments.age&quot;</span>:     [ 28, 31 ],</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="string">&quot;comments.stars&quot;</span>:   [ 4, 5 ],</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="string">&quot;comments.date&quot;</span>:    [ 2014-09-01, 2014-10-22 ]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意这里并不是说查到了一个name 为 alice 并且 age 为 28的 documnet，</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">而是commnets 中只要有任意两个 name 和 age 匹配就可以。</span></span><br><span class="line">curl -H &quot;Content-Type:application/json&quot; &quot;localhost:9200/my_index/_search?pretty&quot; --data  &#x27;&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;comments.name&quot;: &quot;Alice&quot; &#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;comments.age&quot;:  28      &#125;&#125; </span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在内部对象下，尝试nested 查询, nested object under path [comments] is not of nested <span class="built_in">type</span>, 不对哦</span></span><br><span class="line">curl -H &quot;Content-Type:application/json&quot; &quot;localhost:9200/my_index/_search?pretty&quot; --data &#x27;&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;title&quot;: &quot;eggs&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;nested&quot;: &#123;</span><br><span class="line">            &quot;query&quot;: &#123;</span><br><span class="line">              &quot;bool&quot;: &#123;</span><br><span class="line">                &quot;must&quot;: [</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;match&quot;: &#123;</span><br><span class="line">                      &quot;comments.name&quot;: &quot;john&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;match&quot;: &#123;</span><br><span class="line">                      &quot;comments.age&quot;: 28</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;path&quot;: &quot;comments&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>虽然 object 类型 (参见 内部对象) 在存储 单一对象 时非常有用,但对于对象数组的搜索而言,毫无用处。**嵌套对象 ** 就是来解决这个问题的。将 comments 字段类型设置为 nested 而不是 object 后,每一个嵌套对象都会被索引为一个 隐藏的独立文档 ,举例如下:</p>
<h5 id="nested-查询成功"><a href="#nested-查询成功" class="headerlink" title="nested 查询成功"></a>nested 查询成功</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">curl -X DELETE &#x27;localhost:9200/my_index&#x27;</span><br><span class="line">curl -X PUT &#x27;localhost:9200/my_index&#x27;</span><br><span class="line">curl -XPUT -H &quot;Content-Type:application/json&quot; &quot;localhost:9200/my_index/_mapping?pretty&quot; --data &#x27;&#123;&quot;properties&quot;: &#123;&quot;comments&quot;: &#123;&quot;type&quot;: &quot;nested&quot;, &quot;properties&quot;: &#123;&quot;date&quot;: &#123;&quot;type&quot;: &quot;date&quot;&#125;, &quot;comment&quot;: &#123;&quot;type&quot;: &quot;text&quot;&#125;, &quot;stars&quot;: &#123;&quot;type&quot;: &quot;short&quot;&#125;, &quot;age&quot;: &#123;&quot;type&quot;: &quot;short&quot;&#125;, &quot;name&quot;: &#123;&quot;type&quot;: &quot;text&quot;&#125;&#125;&#125;&#125;&#125;&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">curl &quot;localhost:9200/my_index/_mapping?pretty&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&quot;type&quot;</span> : <span class="string">&quot;nested&quot;</span>, 这样 tpye 为 nested</span></span><br><span class="line"></span><br><span class="line">curl -H &quot;Content-Type:application/json&quot; &quot;localhost:9200/my_index/_doc/1&quot; --data &#x27;&#123;</span><br><span class="line">  &quot;title&quot;: &quot;Nest eggs&quot;,</span><br><span class="line">  &quot;body&quot;:  &quot;Making your money work...&quot;,</span><br><span class="line">  &quot;tags&quot;:  [ &quot;cash&quot;, &quot;shares&quot; ],</span><br><span class="line">  &quot;comments&quot;: [ </span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;:    &quot;John Smith&quot;,</span><br><span class="line">      &quot;comment&quot;: &quot;Great article&quot;,</span><br><span class="line">      &quot;age&quot;:     28,</span><br><span class="line">      &quot;stars&quot;:   4,</span><br><span class="line">      &quot;date&quot;:    &quot;2014-09-01&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;:    &quot;Alice White&quot;,</span><br><span class="line">      &quot;comment&quot;: &quot;More like this please&quot;,</span><br><span class="line">      &quot;age&quot;:     31,</span><br><span class="line">      &quot;stars&quot;:   5,</span><br><span class="line">      &quot;date&quot;:    &quot;2014-10-22&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nested 查询</span></span><br><span class="line">curl -H &quot;Content-Type:application/json&quot; &quot;localhost:9200/my_index/_search?pretty&quot; --data &#x27;&#123;&quot;query&quot;: &#123;&quot;bool&quot;: &#123;&quot;must&quot;: [&#123;&quot;match&quot;: &#123;&quot;title&quot;: &quot;eggs&quot;&#125;&#125;, &#123;&quot;nested&quot;: &#123;&quot;query&quot;: &#123;&quot;bool&quot;: &#123;&quot;must&quot;: [&#123;&quot;match&quot;: &#123;&quot;comments.name&quot;: &quot;john&quot;&#125;&#125;, &#123;&quot;match&quot;: &#123;&quot;comments.age&quot;: 28&#125;&#125;]&#125;&#125;, &quot;path&quot;: &quot;comments&quot;&#125;&#125;]&#125;&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.9/nested.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.9/nested.html</a></p>
<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>在 Elasticsearch 中，搜索一般包括两个阶段，query 和 fetch 阶段，可以简单的理解，query 阶段确定要取哪些doc（doc_id），fetch 阶段取出具体的 doc。</p>
<p><strong>具体查询见下方 kibana 查询。</strong></p>
<h4 id="Query-阶段"><a href="#Query-阶段" class="headerlink" title="Query 阶段"></a>Query 阶段</h4><ol>
<li>Client 发送一次搜索请求，node1 接收到请求，然后，node1 创建一个大小为 from + size 的优先级队列用来存结果，我们管 node1 叫 coordinating node。</li>
<li>coordinating node将请求广播到涉及到的 shards，每个 shard 在内部执行搜索请求，然后，将结果存到内部的大小同样为 from + size 的优先级队列里，可以把优先级队列理解为一个包含 top N 结果的列表。</li>
<li>每个 shard 把暂存在自身优先级队列里的数据返回给 coordinating node，coordinating node 拿到各个 shards 返回的结果后对结果进行一次合并，产生一个全局的优先级队列，存到自身的优先级队列里。</li>
</ol>
<p>在上面的例子中，coordinating node 拿到 (from + size) * 6 条数据，然后合并并排序后选择前面的 from + size 条数据存到优先级队列，以便 fetch 阶段使用。另外，各个分片返回给 coordinating node 的数据用于选出前 from + size 条数据，所以，只需要返回唯一标记 doc 的 _id 以及用于排序的 _score 即可，这样也可以保证返回的数据量足够小。</p>
<p>coordinating node 计算好自己的优先级队列后，query 阶段结束，进入 fetch 阶段。</p>
<p>为什么是 from + size 大小的数据量，而不是单纯 size 大小的数据量，这是因为在一个分片里得分很低的文档，在和另一个分片中得分较高的文档比，甚至可能得分更高， 所以需要每个分片都将前 from + size 多的 doc_id 取出来。这实际上也就导致深翻页的问题。</p>
<h4 id="Fetch-阶段"><a href="#Fetch-阶段" class="headerlink" title="Fetch 阶段"></a>Fetch 阶段</h4><ol>
<li>coordinating node 发送 GET 请求到相关shards。</li>
<li>shard 根据 doc 的 _id 取到数据详情，然后返回给 coordinating node。</li>
<li>coordinating node 返回数据给 Client。</li>
</ol>
<p>coordinating node 的优先级队列里有 from + size 个 _doc _id，但是，在 fetch 阶段，并不需要取回所有数据，在上面的例子中，前100条数据是不需要取的，<strong>只需要取优先级队列里的第101到110条数据即可</strong>。</p>
<p>需要取的数据可能在不同分片，也可能在同一分片，coordinating node 使用 multi-get 来避免多次去同一分片取数据，从而提高性能。</p>
<h4 id="深度分页的问题"><a href="#深度分页的问题" class="headerlink" title="深度分页的问题"></a>深度分页的问题</h4><p>Elasticsearch 的这种方式提供了分页的功能，同时，也有相应的限制。举个例子，一个索引，有10亿数据，分10个 shards，然后，一个搜索请求，from&#x3D;1,000,000，size&#x3D;100，这时候，会带来严重的性能问题：</p>
<p>CPU、内存和IO消耗容易理解，网络带宽问题稍难理解一点。在 query 阶段，每个shards需要返回 1,000,100 条数据给 coordinating node，而 coordinating node 需要接收 10 * 1,000,100 条数据，即使每条数据只有 _doc _id 和 _score，这数据量也很大了，而且，这才一个查询请求，那如果再乘以100呢？</p>
<p>在另一方面，我们意识到，这种深度分页的请求并不合理，因为我们是很少人为的看很后面的请求的，<strong>在很多的业务场景中，都直接限制分页，比如只能看前100页</strong>。</p>
<p>这种深度分页确实存在，比如，业务上有遍历数据的需要，比如，有1千万粉丝的微信大V，要给所有粉丝群发消息，或者给某省粉丝群发，这时候就需要取得所有符合条件的粉丝，而最容易想到的就是利用 from + size 来实现，不过，这个是不现实的，这时，可以采用 Elasticsearch 提供的 scroll 方式来实现遍历。</p>
<h3 id="深翻页的解决之道（游标查询scroll）"><a href="#深翻页的解决之道（游标查询scroll）" class="headerlink" title="深翻页的解决之道（游标查询scroll）"></a>深翻页的解决之道（游标查询scroll）</h3><p>可以把 scroll 理解为关系型数据库里的 cursor，因此，scroll 并不适合用来做实时搜索，而更适用于后台批处理任务，比如群发。</p>
<p>可以把 scroll 分为初始化和遍历两步，初始化时将所有符合搜索条件的搜索结果缓存起来，<strong>可以想象成快照，在遍历时，从这个快照里取数据，也就是说，在初始化后对索引插入、删除、更新数据都不能影响遍历结果</strong>。</p>
<p>为了使用 scroll，初始搜索请求应该在查询中指定 scroll 参数，这可以告诉 Elasticsearch 需要保持搜索的上下文环境多久</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保持游标查询窗口一分钟。</span></span><br><span class="line">curl -X GET -H &quot;Content-Type:application/json&quot; &quot;http://10.23.111.70:9200/trade_orders/_doc/_search?scroll=1m&quot; --data &#x27;&#123;&quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125;&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>初始化时需要像普通 search 一样，指明 index 和 type (当然，search 是可以不指明 index 和 type 的)，然后，加上参数 scroll，表示暂存搜索结果的时间，其它就像一个普通的search请求一样。</p>
<p>初始化返回一个 _scroll_id，_scroll_id 用来下次取数据用。</p>
<h5 id="scroll-x3D-1m"><a href="#scroll-x3D-1m" class="headerlink" title="scroll&#x3D;1m"></a>scroll&#x3D;1m</h5><p>启用游标查询可以通过在查询的时候设置参数 scroll 的值为我们期望的游标查询的过期时间。 游标查询的过期时间会在每次做查询的时候刷新，所以这个时间只需要足够处理当前批的结果就可以了，而不是处理查询结果的所有文档的所需时间。 这个过期时间的参数很重要，因为保持这个游标查询窗口需要消耗资源，所以我们期望如果不再需要维护这种资源就该早点儿释放掉。 设置这个超时能够让 Elasticsearch 在稍后空闲的时候自动释放这部分资源。</p>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>注意遍历时的 url ，不需要 index 和 type 并且是 _search&#x2F;scroll</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET -H &quot;Content-Type:application/json&quot; &quot;http://10.23.111.70:9200/_search/scroll?scroll=1m&quot; --data &#x27;&#123;&quot;scroll_id&quot;:&quot;DnF1ZXJ5VGhlbkZldGNoAwAAAAAAADvxFnhpZlhVQllnVG42dklaUThoNWFXSmcAAAAAAANLwhZaUHo0aGJROVNscTJhc2JtdEo0dkpnAAAAAAADlx0WWEFrS3VVSFhTeG1mWEMtUVFfeENwUQ==&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="Scroll-Scan"><a href="#Scroll-Scan" class="headerlink" title="Scroll-Scan"></a>Scroll-Scan</h4><p>Elasticsearch 提供了 Scroll-Scan 方式进一步提高遍历性能。还是上面的例子，微信大V要给粉丝群发这种后台任务，是不需要关注顺序的，只要能遍历所有数据即可，这时候，就可以用Scroll-Scan。</p>
<p>Scroll-Scan 的遍历与普通 Scroll 一样，初始化存在一点差别。</p>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/2.1/breaking_21_search_changes.html">search_type&#x3D;scan已经被废弃了</a>， 可以使用下面的方式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET -H &quot;Content-Type:application/json&quot; &quot;http://10.23.111.70:9200/trade_orders/_doc/_search?scroll=1m&quot; --data &#x27;&#123;&quot;sort&quot;: [&quot;_doc&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="Kibana-查询"><a href="#Kibana-查询" class="headerlink" title="Kibana 查询"></a>Kibana 查询</h2><p>每一个GET都可以直接查询</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">GET _search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">from size 分页查询</span></span><br><span class="line">GET trade_orders/_doc/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125;&#125;,</span><br><span class="line">    &quot;from&quot;: 11,</span><br><span class="line">    &quot;size&quot;:  5</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化 游标查询 scroll， 过期时间1分钟，关键字 _doc 是最有效的排序顺序。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">尽管我们指定字段 size 的值为 2，我们有可能取到超过这个值数量的文档。 当查询的时候， 字段 size</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">作用于单个分片，所以每个批次实际返回的文档数量最大为 size * number_of_primary_shards 。</span></span><br><span class="line">GET trade_orders/_doc/_search?scroll=1m</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125;&#125;,</span><br><span class="line">    &quot;sort&quot; : [&quot;_doc&quot;], </span><br><span class="line">    &quot;size&quot;:  2</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">personal_orders 下 personal_orders_jd_720328_xinbz891015 这个<span class="built_in">id</span> 的查询</span></span><br><span class="line">GET personal_orders/_doc/personal_orders_jd_720328_xinbz891015</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">trade_orders 下 jd_120823795963 这个<span class="built_in">id</span> 的查询</span></span><br><span class="line">GET trade_orders/_doc/jd_120823795963</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 的详情</span></span><br><span class="line">GET _cat/indices?v</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">index 的结构</span></span><br><span class="line">GET trade_orders</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 _search 查询</span></span><br><span class="line">GET trade_orders/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;ItemIDs&quot;: &quot;14084259599&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查询原理"><a href="#查询原理" class="headerlink" title="查询原理"></a>查询原理</h2><h3 id="分片及副本"><a href="#分片及副本" class="headerlink" title="分片及副本"></a>分片及副本</h3><p>Index 1：蓝色部分，有3个shard，分别是P1，P2，P3，位于3个不同的Node中，这里没有Replica。</p>
<p>Index 2：绿色部分，有2个shard，分别是P1，P2，位于2个不同的Node中。并且每个shard有一个replica，分别是R1和R2。基于系统可用性的考虑，同一个shard的primary和replica不能位于同一个Node中。这里Shard1的P1和R1分别位于Node3和Node2中，如果某一刻Node2发生宕机，服务基本不会受影响，因为还有一个P1和R2都还是可用的。因为是主备架构，当主分片发生故障时，需要切换，这时候需要选举一个副本作为新主，这里除了会耗费一点点时间外，也会有丢失数据的风险。</p>
<p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/eaa66da6fe7e41c191dede268873192a.jpg"></p>
<h3 id="创建Index流程"><a href="#创建Index流程" class="headerlink" title="创建Index流程"></a>创建Index流程</h3><p>建索引(Index， 就是创建数据表，es 中的 index 就是表)的时候，一个Doc先是经过路由规则定位到主Shard （主分片可能有多个），发送这个doc到主Shard上建索引，成功后再发送这个Doc到这个Shard的副本上建索引，等副本上建索引成功后才返回成功。</p>
<p>在这种架构中，索引数据全部位于Shard中，主Shard和副本Shard各存储一份。当某个副本Shard或者主Shard丢失(比如机器宕机，网络中断等)时，需要将丢失的Shard在其他Node中恢复回来，这时候就需要从其他副本(Replica)全量拷贝这个Shard的所有数据到新Node上构造新Shard。这个拷贝过程需要一段时间，这段时间内只能由剩余主副本来承载流量，在恢复完成之前，整个系统会处于一个比较危险的状态，直到failover结束。</p>
<p>这里就体现了副本(Replica)存在的一个理由，避免数据丢失，提高数据可靠性。副本(Replica)存在的另一个理由是读请求量很大的时候，一个Node无法承载所有流量，这个时候就需要一个副本来分流查询压力，<strong>目的就是扩展查询能力（支持读写分离）</strong>。</p>
<h3 id="部署层架构"><a href="#部署层架构" class="headerlink" title="部署层架构"></a>部署层架构</h3><p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/ac61d59cc952484a9609f685bd48cd38.jpg"></p>
<p>Elasticsearch支持上述两种方式：可以参考之前的文章《分布式系统之数据分区》，请求路由的4中方式，这里实际上是其中两种。</p>
<h4 id="混合部署-左图-Data-Node和Transport-Node-结合"><a href="#混合部署-左图-Data-Node和Transport-Node-结合" class="headerlink" title="混合部署(左图) Data Node和Transport Node 结合"></a>混合部署(左图) Data Node和Transport Node 结合</h4><p>不考虑MasterNode的情况下，还有两种Node，Data Node和Transport Node，这种部署模式下，这两种不同类型Node角色都位于同一个Node中，相当于一个Node具备两种功能：Data和Transport。</p>
<p>当有index或者query请求的时候，请求随机(自定义)发送给任何一个Node，这台Node中会持有一个全局的路由表，通过路由表选择合适的Node，将请求发送给这些Node，然后等所有请求都返回后，合并结果，然后返回给用户。一个Node分饰两种角色。</p>
<h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><p>好处就是使用极其简单，易上手，对推广系统有很大价值。最简单的场景下只需要启动一个Node，就能完成所有的功能。</p>
<h5 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h5><p>缺点就是多种类型的请求会相互影响，在大集群如果某一个Data Node出现热点，那么就会影响途经这个Data Node的所有其他跨Node请求。如果发生故障，故障影响面会变大很多。</p>
<p>Elasticsearch中每个Node都需要和其余的每一个Node都保持连接。这种情况下，每个Node都需要和其他所有Node保持连接，而一个系统的连接数是有上限的，这样连接数就会限制集群规模。</p>
<h4 id="分层部署-右图"><a href="#分层部署-右图" class="headerlink" title="分层部署(右图)"></a>分层部署(右图)</h4><p>设置部分Node为Transport Node，专门用来做请求转发和结果合并。</p>
<p>其他Node可以设置为DataNode，专门用来处理数据。</p>
<h5 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h5><p>好处就是角色相互独立，不会相互影响，一般Transport Node的流量是平均分配的，很少出现单台机器的CPU或流量被打满的情况，而DataNode由于处理数据，很容易出现单机资源被占满，比如CPU，网络，磁盘等。独立开后，DataNode如果出了故障只是影响单节点的数据处理，不会影响其他节点的请求，影响限制在最小的范围内。</p>
<p>角色独立后，只需要Transport Node连接所有的DataNode，而DataNode则不需要和其他DataNode有连接。一个集群中DataNode的数量远大于Transport Node，这样集群的规模可以更大。另外，还可以通过分组，使Transport Node只连接固定分组的DataNode，这样Elasticsearch的连接数问题就彻底解决了。</p>
<p>可以支持热更新：先一台一台的升级DataNode，升级完成后再升级Transport Node，整个过程中，可以做到让用户无感知。</p>
<h5 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h5><p>缺点是上手复杂，需要提前设置好Transport的数量，且数量和Data Node、流量等相关，否则要么资源闲置，要么机器被打爆。</p>
<h3 id="数据层架构"><a href="#数据层架构" class="headerlink" title="数据层架构"></a>数据层架构</h3><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><p>Elasticsearch的Index和meta，目前支持存储在本地文件系统中，同时支持niofs，mmap，simplefs，smb等不同加载方式，性能最好的是直接将索引LOCK进内存的MMap方式。默认，Elasticsearch会自动选择加载方式，另外可以自己在配置文件中配置。这里有几个细节，具体可以看官方文档。</p>
<p>索引和meta数据都存在本地，会带来一个问题：当某一台机器宕机或者磁盘损坏的时候，数据就丢失了。为了解决这个问题，可以使用Replica(副本)功能。</p>
<h4 id="副本-Replica"><a href="#副本-Replica" class="headerlink" title="副本(Replica)"></a>副本(Replica)</h4><p>可以为每一个Index设置一个配置项：副本(Replicda)数，如果设置副本数为2，那么就会有3个Shard，其中一个是PrimaryShard，其余两个是ReplicaShard，这三个Shard会被Master尽量调度到不同机器，甚至机架上，这三个Shard中的数据一样，提供同样的服务能力。</p>
<h5 id="副本-Replica-的目的有三个："><a href="#副本-Replica-的目的有三个：" class="headerlink" title="副本(Replica)的目的有三个："></a>副本(Replica)的目的有三个：</h5><p>保证服务可用性：当设置了多个Replica的时候，如果某一个Replica不可用的时候，那么请求流量可以继续发往其他Replica，服务可以很快恢复开始服务。</p>
<p>保证数据可靠性：如果只有一个Primary，没有Replica，那么当Primary的机器磁盘损坏的时候，那么这个Node中所有Shard的数据会丢失，只能reindex了。</p>
<p>提供更大的查询能力：当Shard提供的查询能力无法满足业务需求的时候， 可以继续加N个Replica，这样查询能力就能提高N倍，轻松增加系统的并发度。</p>
<h5 id="Replica-的问题"><a href="#Replica-的问题" class="headerlink" title="Replica 的问题"></a>Replica 的问题</h5><p>Replica带来成本浪费。为了保证数据可靠性，必须使用Replica，但是当一个Shard就能满足处理能力的时候，另一个Shard的计算能力就会浪费。</p>
<p>Replica带来写性能和吞吐的下降。每次Index或者update的时候，需要先更新Primary Shard，更新成功后再并行去更新Replica，再加上长尾，写入性能会有不少的下降。</p>
<h2 id="分布式数据系统架构"><a href="#分布式数据系统架构" class="headerlink" title="分布式数据系统架构"></a>分布式数据系统架构</h2><h3 id="基于本地文件系统的分布式系统"><a href="#基于本地文件系统的分布式系统" class="headerlink" title="基于本地文件系统的分布式系统"></a>基于本地文件系统的分布式系统</h3><p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/04c02a0d8fab47fca87ccbe4a8980797.jpg"></p>
<p>上图中是一个基于本地磁盘存储数据的分布式系统。Index一共有3个Shard，每个Shard除了Primary Shard外，还有一个Replica Shard。当Node 3机器宕机或磁盘损坏的时候，首先确认P3已经不可用，重新选举R3位Primary Shard，此Shard发生主备切换。然后重新找一台机器Node 7，在Node7 上重新启动P3的新Replica。由于数据都会存在本地磁盘，此时需要将Shard 3的数据从Node 6上拷贝到Node7上。如果有200G数据，千兆网络，拷贝完需要1600秒。如果没有replica，则这1600秒内这些Shard就不能服务。</p>
<p>为了保证可靠性，就需要冗余Shard，会导致更多的物理资源消耗。</p>
<p>这种思想的另外一种表现形式是使用双集群，集群级别做备份。</p>
<h3 id="基于分布式文件系统的分布式系统-共享存储-存储和计算分离"><a href="#基于分布式文件系统的分布式系统-共享存储-存储和计算分离" class="headerlink" title="基于分布式文件系统的分布式系统(共享存储)-存储和计算分离"></a>基于分布式文件系统的分布式系统(共享存储)-存储和计算分离</h3><p>针对第一种架构中的问题，另一种思路是：存储和计算分离。</p>
<p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/b674a4895ca54eb7a1dd1c53ca68fc2b.jpg"></p>
<p>第一种思路的问题根源是数据量大，拷贝数据耗时多，那么有没有办法可以不拷贝数据?为了实现这个目的，一种思路是底层存储层使用共享存储，每个Shard只需要连接到一个分布式文件系统中的一个目录&#x2F;文件即可，Shard中不含有数据，只含有计算部分。相当于每个Node中只负责计算部分，存储部分放在底层的另一个分布式文件系统中，比如HDFS。<br>上图中，Node 1 连接到第一个文件;Node 2连接到第二个文件;Node3连接到第三个文件。当Node 3机器宕机后，只需要在Node 4机器上新建一个空的Shard，然后构造一个新连接，连接到底层分布式文件系统的第三个文件即可，创建连接的速度是很快的，总耗时会非常短。</p>
<h4 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h4><p>在这种架构下，资源可以更加弹性，当存储不够的时候只需要扩容存储系统的容量;当计算不够的时候，只需要扩容计算部分容量。</p>
<p>存储和计算是独立管理的，资源管理粒度更小，管理更加精细化，浪费更少，结果就是总体成本可以更低。</p>
<p>负载更加突出，抗热点能力更强。一般热点问题基本都出现在计算部分，对于存储和计算分离系统，计算部分由于没有绑定数据，可以实时的扩容、缩容和迁移，当出现热点的时候，可以第一时间将计算调度到新节点上。</p>
<h4 id="劣势-2"><a href="#劣势-2" class="headerlink" title="劣势"></a>劣势</h4><p>访问分布式文件系统的性能可能不及访问本地文件系统。在上一代分布式文件系统中，这是一个比较明显的问题，但是目前使用了各种用户态协议栈后，这个差距已经越来越小了。</p>
<p>HBase使用的就是这种架构方式。</p>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.elastic.co/cn/">es 官网</a></p>
<p><a target="_blank" rel="noopener" href="https://elasticsearch.cn/">es中文社区</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/104215274">eslaticsearch 基础概念</a></p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html">阮一峰的es文章翻译</a></p>
<p><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/653029">ElasticSearch常用的基本查询语句详解</a></p>
<p><a target="_blank" rel="noopener" href="http://tech.it168.com/a2018/0626/3211/000003211367.shtml">从Elasticsearch来看分布式系统架构设计</a></p>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/scroll.html">es官网游标查询</a></p>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/replica-shards.html">关于副本分片</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/08/14/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B%E4%B9%8Bmongo%E9%9B%86%E7%BE%A4%E4%B9%8B%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/14/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B%E4%B9%8Bmongo%E9%9B%86%E7%BE%A4%E4%B9%8B%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">分布式系统实例之mongo 集群之概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-14 19:59:02" itemprop="dateCreated datePublished" datetime="2020-08-14T19:59:02+08:00">2020-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-19 23:35:53" itemprop="dateModified" datetime="2022-10-19T23:35:53+08:00">2022-10-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>Mongodb一共有三种集群搭建的方式：</p>
<ul>
<li>Replica Set（副本集）</li>
<li>Sharding（切片）</li>
<li>Master-Slaver（主从，<strong>目前已不推荐使用了</strong>）</li>
</ul>
<p>其中，Sharding集群也是三种集群中最复杂的。副本集比起主从可以实现<strong>故障转移， 经常使用。</strong></p>
<p>MongoDB 目前已不推荐使用主从模式，取而代之的是副本集模式。副本集其实一种互为主从的关系，可理解为主主。副本集指将数据复制，多份保存，不同服务器保存同一份数据，在出现故障时自动切换。对应的是数据冗余、备份、镜像、读写分离、高可用性等关键词。</p>
<p>而分片则指为处理大量数据，将数据分开存储，不同服务器保存不同的数据，它们的数据总和即为整个数据集。追求的是高性能。在生产环境中，通常是这两种技术结合使用，分片+副本集。</p>
<h2 id="主从集群"><a href="#主从集群" class="headerlink" title="主从集群"></a>主从集群</h2><p>主从复制是MongoDB最常用的复制方式,也是一个简单的数据库同步备份的集群技术,这种方式很灵活.可用于备份,故障恢复,读扩展等. 最基本的设置方式就是建立一个主节点和一个或多个从节点,每个从节点要知道主节点的地址。采用双机备份后主节点挂掉了后从节点可以接替主机继续服务。所以这种模式比单节点的高可用性要好很多。</p>
<h3 id="配置主从复制的注意点"><a href="#配置主从复制的注意点" class="headerlink" title="配置主从复制的注意点"></a>配置主从复制的注意点</h3><ul>
<li>在数据库集群中要明确的知道谁是主服务器,主服务器只有一台.</li>
<li>从服务器要知道自己的数据源也就是对应的主服务是谁.</li>
<li>–master用来确定主服务器, –slave 和 –source 来控制从服务器</li>
</ul>
<h3 id="主从配置"><a href="#主从配置" class="headerlink" title="主从配置"></a>主从配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.............master－node节点配置.............</span><br><span class="line">[root@master-node ~]# vim /usr/local/mongodb/mongodb.conf</span><br><span class="line">port=27017</span><br><span class="line">bind_ip = 182.48.115.238</span><br><span class="line">dbpath=/usr/local/mongodb/data</span><br><span class="line">logpath=/usr/local/mongodb/log/mongo.log</span><br><span class="line">logappend=true</span><br><span class="line">journal = true</span><br><span class="line">fork = true</span><br><span class="line">master = true        //确定自己是主服务器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.............slave－node节点配置.............</span><br><span class="line">[root@slave-node ~]# vim /usr/local/mongodb/mongodb.conf </span><br><span class="line">port=27017</span><br><span class="line">dbpath=/usr/local/mongodb/data</span><br><span class="line">logpath=/usr/local/mongodb/log/mongo.log</span><br><span class="line">logappend=true</span><br><span class="line">journal = true</span><br><span class="line">fork = true</span><br><span class="line">bind_ip = 182.48.115.236            //确定主数据库端口</span><br><span class="line">source = 182.48.115.238:27017      //确定主数据库端口</span><br><span class="line">slave = true               //确定自己是从服务器</span><br></pre></td></tr></table></figure>

<p>如上配置后，在主节点写入的数据就会同步到从节点</p>
<h4 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h4><p>在主从结构中，主节点的操作记录成为oplog（operation log）。oplog存储在一个系统数据库local的集合oplog.$main 中，这个集合的每个文档都代表<strong>主节点上执行的一个操作</strong>。 从服务器会定期从主服务器中获取oplog记录，然后在本机上执行。对于存储oplog的集合，MongoDB采用的是固定集合，也就是说随着操作过多，新的操作会覆盖旧的操作。</p>
<p>在上面slave-node从节点的local数据库中，存在一个集合sources。这个集合就保存了这个服务器的主服务器是谁</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use local</span><br><span class="line">db.sources.find()</span><br></pre></td></tr></table></figure>

<h2 id="副本集集群（Replica-Sets）"><a href="#副本集集群（Replica-Sets）" class="headerlink" title="副本集集群（Replica Sets）"></a>副本集集群（Replica Sets）</h2><p>mongodb 不推荐主从复制，推荐建立副本集(Replica Set)来保证1个服务挂了,可以有其他服务顶上,程序正常运行,几个服务的数据都是一样的，后台自动同步。主从复制其实就是一个单副本的应用，没有很好的扩展性和容错性。然而副本集具有多个副本保证了容错性，就算一个副本挂掉了还有很多个副本存在，并且解决了”主节点挂掉后，整个集群内会自动切换”的问题。副本集比传统的Master-Slave主从复制有改进的地方就是它可以进行故障的自动转移，如果我们停掉复制集中的一个成员，那么剩余成员会再自动选举一个成员，作为主库。</p>
<p>在一些场景，可以使用副本集来扩展读性能，客户端有能力发送读写操作给不同的服务器。也可以在不同的数据中心获取不同的副本来扩展分布式应用的能力。mongodb副本集是一组拥有相同数据的mongodb实例，主mongodb接受所有的写操作，所有的其他实例可以接受主实例的操作以保持数据同步。<strong>主实例接受客户的写操作，副本集只能有一个主实例，因为为了维持数据一致性，只有一个实例可写，主实例的日志保存在oplog</strong>。</p>
<h3 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h3><p>副本节点同步主节点的操作是异步的，这会导致副本集无法返回最新的数据给客户端程序。其实这是典型CAP问题，一致性(Consistency)，可用性(Availability)，分区容忍性(Partition tolerance)三者只能取其二，mongoDB的主从复制模式，实际上是取了A和P而放弃了C，<strong>仅仅保证最终一致性</strong>。其实无论负载如何， 数据不一致的延迟的是一定存在的，不过是时间长短而已。</p>
<h4 id="解決异步复制的一致性问题"><a href="#解決异步复制的一致性问题" class="headerlink" title="解決异步复制的一致性问题"></a>解決异步复制的一致性问题</h4><p>mongoDB实际上有处理该问题的API，{w: “majority”}，即写的时候阻塞到写到大多数结点写完才算完成。有了这点还是不够的，因为你要读的从结点并不能保证一定在“大多数”之内。为了保证读结点在“大多数”之内{readConcern: “majority”}——多数结点有的才算有。但是这样的话一个请求要压在大多数节点上，违背了读写分离，分散数据库压力的初衷，而且也将写操作趋近于同步，影响性能。 于是单独搞了一个可以保证数据一致性的connection，以便需要数据一致性的时候使用，而其他操作则不使用该操作。</p>
<h3 id="副本集的结构及原理"><a href="#副本集的结构及原理" class="headerlink" title="副本集的结构及原理"></a>副本集的结构及原理</h3><p>MongoDB 的副本集不同于以往的主从模式。在集群Master故障的时候,副本集可以自动投票,选举出新的Master,并引导其余的Slave服务器连接新的Master,而这个过程对于应用是透明的。可以说MongoDB的副本集是自带故障转移功能的主从复制。一旦 Master 节点故障,则会在其余节点中选举出一个新的 Master 节点。 并引导剩余节点连接到新的 Master 节点。<strong>这个过程对于应用是透明的。</strong></p>
<h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><p>整个集群需要保持一定的通信才能知道哪些节点活着哪些节点挂掉。mongodb节点会向副本集中的其他节点每两秒就会发送一次pings包，如果其他节点在10秒钟之内没有返回就标示为不能访问。每个节点内部都会维护一个状态映射表，表明当前每个节点是什么角色、日志时间戳等关键信息。如果是主节点，除了维护映射表外还需要检查自己能否和集群中内大部分节点通讯，如果不能则把自己降级为secondary只读节点。</p>
<h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p>副本集同步分为初始化同步和keep复制。初始化同步指全量从主节点同步数据，如果主节点数据量比较大同步时间会比较长。而keep复制指初始化同步过后，节点之间的实时同步，一般是增量同步。初始化同步不只是在第一次才会被处罚，有以下两种情况会触发：<br>1）secondary第一次加入，这个是肯定的。<br>2）secondary落后的数据量超过了oplog的大小，这样也会被全量复制。</p>
<h4 id="数据同步-副本集数据过程"><a href="#数据同步-副本集数据过程" class="headerlink" title="数据同步-副本集数据过程"></a>数据同步-副本集数据过程</h4><p>当Primary节点完成数据操作后，Secondary会做出一系列的动作保证数据的同步：<br>1）检查自己local库的oplog.rs集合找出最近的时间戳。<br>2）检查Primary节点local库oplog.rs集合，找出大于此时间戳的记录。<br>3）将找到的记录插入到自己的oplog.rs集合中，并执行这些操作。</p>
<h4 id="MongoDB-同步延迟问题"><a href="#MongoDB-同步延迟问题" class="headerlink" title="MongoDB 同步延迟问题"></a>MongoDB 同步延迟问题</h4><p>什么是同步延迟?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">什么是同步延迟?</span><br><span class="line">首先,要出现同步延迟,必然是在有数据同步的场合,在 MongoDB 中,有两种数据冗余方式,一种是Master-Slave 模式,一种是Replica Sets模式。这两个模式本质上都是</span><br><span class="line">在一个节点上执行写操作, 另外的节点将主节点上的写操作同步到自己这边再进行执行。在MongoDB中,所有写操作都会产生 oplog,oplog 是每修改一条数据都会生成一条,如果你采用一个批量 update 命令更新了 N 多条数据, 那么抱歉,oplog 会有很多条,而不是一条。所以同步延迟就是写操作在主节点上执行完后,从节点还没有把 oplog 拿过来再执行一次。而这个写操作的量越大,主节点与从节点的差别也就越大,同步延迟也就越大了。</span><br></pre></td></tr></table></figure>

<p> 同步延迟带来的问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同步延迟带来的问题</span><br><span class="line">首先,同步操作通常有两个效果,一是读写分离,将读操作放到从节点上来执行,从而减少主节点的 压力。对于大多数场景来说,读多写少是基本特性,所以这一点是很有用的。</span><br><span class="line">另一个作用是数据备份, 同一个写操作除了在主节点执行之外,在从节点上也同样执行,这样我们就有多份同样的数据,一旦 主节点的数据因为各种天灾人祸无法恢复的时候,我们至少还有从节点可以依赖。但是主从延迟问题 可能会对上面两个效果都产生不好的影响。</span><br></pre></td></tr></table></figure>

<p> 主节点故障</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果主从延迟过大,主节点上会有很多数据更改没有同步到从节点上。这时候如果主节点故障,就有两种情况:</span><br><span class="line">1）主节点故障并且无法恢复,如果应用上又无法忍受这部分数据的丢失,我们就得想各种办法将这部 数据更改找回来,再写入到从节点中去。可以想象,即使是有可能,那这也绝对是一件非常恶心的活。</span><br><span class="line">2）主节点能够恢复,但是需要花的时间比较长,这种情况如果应用能忍受,我们可以直接让从节点提 供服务,只是对用户来说,有一段时间的数据丢失了,而如果应用不能接受数据的不一致,那么就只能下线整个业务,等主节点恢复后再提供服务了。</span><br></pre></td></tr></table></figure>

<p> 数据丢失</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果你只有一个从节点,当主从延迟过大时,由于主节点只保存最近的一部分 oplog,可能会导致从节点青黄不接,不得不进行 resync 操作,全量从主节点同步数据。</span><br><span class="line">带来的问题是：当从节点全量同步的时候,实际只有主节点保存了完整的数据,这时候如果主节点故障,很可能全部数据都丢掉了。</span><br></pre></td></tr></table></figure>

<h3 id="三种节点"><a href="#三种节点" class="headerlink" title="三种节点"></a>三种节点</h3><p>副本集包括三种节点:主节点、从节点、仲裁节点。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）主节点负责处理客户端请求,读、写数据, 记录在其上所有操作的 oplog;</span><br><span class="line">2）从节点定期轮询主节点获取这些操作,然后对自己的数据副本执行这些操作,从而保证从节点的数据与主节点一致。默认情况下,从节点不支持外部读取,但可以设置;</span><br><span class="line">   副本集的机制在于主节点出现故障的时候,余下的节点会选举出一个新的主节点,从而保证系统可以正常运行。</span><br><span class="line">3）仲裁节点不复制数据,仅参与投票。由于它没有访问的压力,比较空闲,因此不容易出故障。由于副本集出现故障的时候,存活的节点必须大于副本集节点总数的一半,</span><br><span class="line">   否则无法选举主节点,或者主节点会自动降级为从节点,整个副本集变为只读。因此,增加一个不容易出故障的仲裁节点,可以增加有效选票,降低整个副本集不可用的</span><br><span class="line">   风险。仲裁节点可多于一个。也就是说只参与投票，不接收复制的数据，也不能成为活跃节点。</span><br></pre></td></tr></table></figure>

<h3 id="Mongodb副本集环境部署记录"><a href="#Mongodb副本集环境部署记录" class="headerlink" title="Mongodb副本集环境部署记录"></a>Mongodb副本集环境部署记录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@master-node ~]# cat /usr/local/mongodb/mongodb.conf</span><br><span class="line">port=27017</span><br><span class="line">bind_ip = 182.48.115.236                 //这个最好配置成本机的ip地址。否则后面进行副本集初始化的时候可能会失败！           </span><br><span class="line">dbpath=/usr/local/mongodb/data</span><br><span class="line">logpath=/usr/local/mongodb/log/mongo.log</span><br><span class="line">pidfilepath=/usr/local/mongodb/mongo.pid</span><br><span class="line">fork=true</span><br><span class="line">logappend=true</span><br><span class="line">shardsvr=true</span><br><span class="line">directoryperdb=true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">auth=<span class="literal">true</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">keyFile =/usr/local/mongodb/keyfile</span></span><br><span class="line">replSet =hqmongodb</span><br></pre></td></tr></table></figure>

<h3 id="客户端连接副本集"><a href="#客户端连接副本集" class="headerlink" title="客户端连接副本集"></a>客户端连接副本集</h3><p>要正确连接复制集，需要先了解下MongoDB的<a target="_blank" rel="noopener" href="http://docs.mongodb.org/manual/reference/connection-string">Connection String URI</a>，<a target="_blank" rel="noopener" href="https://docs.mongodb.org/manual/applications/drivers/">所有官方的driver</a>都支持以Connection String的方式来连接MongoDB。</p>
<ul>
<li>mongodb:&#x2F;&#x2F; 前缀，代表这是一个Connection String</li>
<li>username:password@ 如果启用了鉴权，需要指定用户密码</li>
<li>hostX:portX 复制集成员的ip:port信息，多个成员以逗号分割</li>
<li>&#x2F;database 鉴权时，用户帐号所属的数据库</li>
<li>?options 指定额外的连接选项</li>
</ul>
<p>通过正确的Connection String来连接MongoDB复制集时，客户端会自动检测复制集的主备关系，<strong>当主备关系发生变化时，自动将写切换到新的主上，（这里猜测是轮训去获取当前的主从信息）</strong>，以保证服务的高可用。</p>
<h4 id="如何实现读写分离？"><a href="#如何实现读写分离？" class="headerlink" title="如何实现读写分离？"></a>如何实现读写分离？</h4><p>在options里添加<code>readPreference=secondaryPreferred</code>即可实现，读请求优先到Secondary节点，从而实现读写分离的功能，更多<code>读选项</code>参考<a target="_blank" rel="noopener" href="https://docs.mongodb.org/manual/core/read-preference/">Read preferences</a></p>
<h4 id="如何限制连接数"><a href="#如何限制连接数" class="headerlink" title="如何限制连接数?"></a>如何限制连接数?</h4><p>在options里添加maxPoolSize&#x3D;xx即可将客户端连接池限制在xx以内。</p>
<h4 id="如何保证数据写入到大多数节点后才返回"><a href="#如何保证数据写入到大多数节点后才返回" class="headerlink" title="如何保证数据写入到大多数节点后才返回?"></a>如何保证数据写入到大多数节点后才返回?</h4><p>在options里添加<code>w= majority</code>即可保证写请求成功写入大多数节点才向客户端确认，更多<code>写选项</code>参考<a target="_blank" rel="noopener" href="https://docs.mongodb.org/manual/reference/write-concern/#write-concern">Write Concern</a></p>
<h2 id="Mongodb分片集群（Sharding）"><a href="#Mongodb分片集群（Sharding）" class="headerlink" title="Mongodb分片集群（Sharding）"></a>Mongodb分片集群（Sharding）</h2><p>Sharding cluster是一种可以水平扩展的模式,在数据量很大时特给力,实际大规模应用一般会采用这种架构去构建。sharding分片很好的解决了单台服务器磁盘空间、内存、cpu等硬件资源的限制问题，把数据水平拆分出去，降低单节点的访问压力。每个分片都是一个独立的数据库，所有的分片组合起来构成一个逻辑上的完整的数据库。因此，分片机制降低了每个分片的数据操作量及需要存储的数据量，达到多台服务器来应对不断增加的负载和数据的效果。</p>
<p>分片的基本思想就是：</p>
<ul>
<li><p>将集合切成小块,这些块分散到若干片里,每个片只负责总数据的一部分。通过一个名为 mongos 的路由进程进行操作,mongos 知道数据和片的对应关系(通过配置服务器)。 大部分使用场景都是解决磁盘空间的问题,对于写入有可能会变差，查询则尽量避免跨分片查询。</p>
</li>
<li><p>分片是指将数据拆分,将其分散存在不同机器上的过程.有时也叫分区.将数据分散在不同的机器上MongoDB支持自动分片,可以摆脱手动分片的管理.集群自动切分数据,做负载均衡</p>
</li>
</ul>
<h3 id="三种角色"><a href="#三种角色" class="headerlink" title="三种角色"></a>三种角色</h3><p>要构建一个MongoDB Sharding Cluster（分片集群）,需要三种角色</p>
<h4 id="分片服务器（Shard-Server）"><a href="#分片服务器（Shard-Server）" class="headerlink" title="分片服务器（Shard Server）"></a>分片服务器（Shard Server）</h4><p>mongod 实例,用于存储实际的数据块,实际生产环境中一个 shard server 角色可由几台机器组个一个 relica set 承担,防止主机单点故障。</p>
<p>高可用性的分片架构还需要对于每一个分片构建 replica set 副本集保 证分片的可靠性。生产环境通常是 2 个副本 + 1 个仲裁。</p>
<h4 id="配置服务器（Config-Server）"><a href="#配置服务器（Config-Server）" class="headerlink" title="配置服务器（Config Server）"></a>配置服务器（Config Server）</h4><p>这是一个独立的mongod进程,保存集群和分片的元数据,即各分片包含了哪些数据的信息。最先开始建立,启用日志功能。像启动普通的 mongod 一样启动， 并指定 configsvr 选项。</p>
<p>由于mongos 本身没有物理存储分片服务器和数据路由信息,只是缓存在内存里,配置服务器则实际存储这些数据。mongos 第一次启动或者关掉重启就会从 config server 加载配置信息,以后如果配置服务器信息变化会通知到所有的 mongos 更新自己的状态,这样mongos 就能继续准确路由。在生产环境通常有多个 config server 配置服务器,因为它存储了分片路由的元数据,这个可不能丢失!就算挂掉其中一台,只要还有存货,mongodb 集群就不会挂掉。</p>
<h4 id="路由服务器（Route-Server）"><a href="#路由服务器（Route-Server）" class="headerlink" title="路由服务器（Route Server）"></a>路由服务器（Route Server）</h4><p><strong>mongos 实例</strong>,前端路由,客户端由此接入,且让整个集群看上去像单一数据库,前端应用起到一个路由的功能,供程序连接。本身不保存数据,在启动时从配置服务器加载集群信息,开启 mongos 进程需要知道配置服务器的地址,指定configdb选项。</p>
<p>mongos 是数据库集群请求的入口,所有的请求都通过 mongos 进行协调,不需要在应用程序添加一个路由选择器,mongos 自己就是一个请求分发中心,它负责把对应的数据请求转发到对应的 shard 服务器上。在生产环境通常有多个 mongos 作为请求的入口,防止其中一个挂掉所有的 mongodb 请求都没有办法操作。</p>
<h3 id="分片集群分析"><a href="#分片集群分析" class="headerlink" title="分片集群分析"></a>分片集群分析</h3><p><img src="https://images2015.cnblogs.com/blog/907596/201706/907596-20170604035229055-909393426.png" alt="分片集群"></p>
<h3 id="golang-连接分片集群"><a href="#golang-连接分片集群" class="headerlink" title="golang 连接分片集群"></a>golang 连接分片集群</h3><ul>
<li>用户访问 mongos 跟访问单个 mongod 类似</li>
<li>所有 mongos 是对等关系，用户访问分片集群可通过任意一个或多个mongos</li>
<li>mongos 本身是无状态的，可任意扩展，集群的服务能力为『Shard服务能力之和』与『mongos服务能力之和』的最小值。</li>
<li>访问分片集群时，最好将应用负载均匀的分散到多个 mongos 上</li>
</ul>
<p>代码：</p>
<h3 id="如何选择shard-key？"><a href="#如何选择shard-key？" class="headerlink" title="如何选择shard key？"></a>如何选择shard key？</h3><p>shard key 片键决定了集群中一个集合的 documents 在不同 shards 中的分布.片键字段必须被索引,且在集合中的每条记录都不能为空,可以是单个字段或复合字段.</p>
<p>MongoDB使用片键的范围把数据分布在分片中,每个范围,又称为数据块,定义了一个不重叠的片键范围,MongoDB把数据块与他们存储的文档分布到集群中的不同分片中.</p>
<p>shard key 在分片中的主要特点：</p>
<ul>
<li>数据索引：作为 shard key 首先作用就是作为数据索引，因为建立 shard key 之前的必要条件就是必须是数据索引</li>
<li>不可更改：shard key 是固定的，一旦确定后（写入数据库），将不可进行更改</li>
<li>随机性：shard key 一定要具有一定的随机性。如果没有选择好 shard key，造成顺序性，则数据会落在某个特定的节点中，造成某节点数据过多，而其他节点却没有数据的情况。</li>
</ul>
<p>一个好的 shard key 应该具备的特点：</p>
<ul>
<li><p>key 分布足够离散 （sufficient cardinality）</p>
<p>足够分散才能带来性能上的增加</p>
</li>
<li><p>写请求均匀分布 （evenly distributed write）</p>
<p>数据应该均匀分布在所有的数据节点上</p>
</li>
<li><p>尽量避免 scatter-gather 查询 （targeted read）</p>
<p>避免大范围的扫描查询</p>
</li>
</ul>
<h4 id="现有-Shard-Key-类型"><a href="#现有-Shard-Key-类型" class="headerlink" title="现有 Shard Key 类型"></a>现有 Shard Key 类型</h4><ul>
<li>范围分片：通常能很好的支持基于 shard key 的范围查询</li>
<li>Hash 分片：通常能将写入均衡分布到各个 shard，不过对范围查询支持不好</li>
</ul>
<h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><p>以公司 IOT 项目为例，在对采集数据进行 sharding 选择片键时，我们很容易想到：</p>
<ul>
<li><p>以 <code>用户编号</code> 范围分片 为片键</p>
<p>这个方案我在最开始的时候也是第一个想到的。但是经过思考后，否决掉了。该方案虽然可以解决在查询某个用户数据时不用扫描所有数据节点，但是用因为户数达不到极大的量级，所以这样会使采集的数据在落盘的时候集中在某一个节点的某个数据块中。</p>
<p>所以，该方案<strong>不合适</strong>。</p>
</li>
<li><p>以 <code>用户编号</code> 哈希分片 为片键</p>
<p>这个方案虽然可以解决范围分片带来的集中问题，但是，仍然不能满足应用的需求，因为应用在使用过程中，需要查询某个用户某一个时间段范围内的所有采集到的数据，如果使用这种方案，那么进行数据查询的时候需要对所有节点进行查询扫描。</p>
<p>所以，该方案<strong>不合适</strong>。</p>
</li>
<li><p>以 <code>created_at</code> 创建时间 范围分片 为片键</p>
<p>虽然该方案可以解决连续读取一个时间段内的数据问题，但是新的写入都是连续的时间戳，同样都会请求到同一个 shard，造成写分布不均。</p>
<p>所以，该方案<strong>不合适</strong>。</p>
</li>
<li><p>以 <code>created_at</code> 创建时间 哈希分片 为片键</p>
<p>该方案的利弊刚好和上一个方案相反。</p>
<p>所以，该方案<strong>不合适</strong>。</p>
</li>
<li><p>以 <code>用户编号</code> 哈希分片 +<code>created_at</code> 范围分片 为组合片键</p>
<p>这个方案其实不用分析就知道为什么不合适了，理由同第2个方案。因为当选择 用户编号哈希方案为首的组合片键时，<strong>用户编号哈希分片已经可以分片出数据了，MongoDB就不用再考虑后者了，所以造成的影响和第2个方案类似。</strong></p>
<p>所以，该方案<strong>不合适</strong>。</p>
</li>
<li><p>以 <code>用户编号</code>+<code>created_at</code> 范围分片 为组合片键</p>
<p>同一个 用户编号 的数据能根据时间戳进一步分散到多个数据块中，同时根据 created_at 查询时间范围的数据，能直接利用（<code>用户编号</code>+<code>created_at</code>）复合索引来完成。</p>
<p>所以，该方案<strong>合适</strong>。</p>
</li>
</ul>
<p>指令<code>sh.shardCollection(your_db.your_collection, &#123;&quot;user_identify&quot;: 1, &quot;created_at&quot;: 1&#125;)</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kevingrace/p/5685486.html">最重要的参考</a></p>
<p><a target="_blank" rel="noopener" href="https://yansongda.cn/2018/03/15/mongodb-sharding-clustering-share-about-chosing-sharding-key/#%E7%8E%B0%E6%9C%89-shard-key-%E7%B1%BB%E5%9E%8B">sharding key 的选择</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e17ea426386c">异步主从复制导致的一致性问题</a></p>
<p><a target="_blank" rel="noopener" href="https://mongoing.com/archives/2642">客户端连接mongo</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.mongodb.com/drivers/go/">官方客户端 golang版本</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/aliyun-mongodb/aeb985c1acc40650.md">mongo 最佳实践</a></p>
<p><a target="_blank" rel="noopener" href="https://www.mongodb.com/presentations/webinar-everything-you-need-know-about-sharding?jmp=docs&_ga=1.113926660.2005306875.1453858874">官方视频讲分片</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/08/14/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B%E4%B9%8Bmongo%E9%9B%86%E7%BE%A4%E4%B9%8B%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/14/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B%E4%B9%8Bmongo%E9%9B%86%E7%BE%A4%E4%B9%8B%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">分布式系统实例之mongo集群之集群搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-14 19:59:02" itemprop="dateCreated datePublished" datetime="2020-08-14T19:59:02+08:00">2020-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-27 11:38:08" itemprop="dateModified" datetime="2022-09-27T11:38:08+08:00">2022-09-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="副本集（replica）"><a href="#副本集（replica）" class="headerlink" title="副本集（replica）"></a>副本集（replica）</h2><p>mongodb副本集是一组拥有相同数据的mongodb实例，主mongodb接受所有的写操作，所有的其他实例可以接受主实例的操作以保持数据同步。</p>
<h3 id="docker-搭建"><a href="#docker-搭建" class="headerlink" title="docker 搭建"></a>docker 搭建</h3><p>参看： go-mod&#x2F;k8s&#x2F;docker&#x2F;mongo&#x2F;replication</p>
<h3 id="验证主从同步"><a href="#验证主从同步" class="headerlink" title="验证主从同步"></a>验证主从同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入mymongo1: docker exec -it mymongo1 mongo</span></span><br><span class="line">use <span class="built_in">test</span></span><br><span class="line">db.people.insert(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;percy1&quot;</span>, <span class="string">&quot;age&quot;</span>: 18&#125;)</span><br><span class="line">db.people.insert(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;percy2&quot;</span>, <span class="string">&quot;age&quot;</span>: 19&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入mymongo2: docker exec -it mymongo1 mongo</span></span><br><span class="line">db.getMongo().setSlaveOk()</span><br><span class="line">use <span class="built_in">test</span></span><br><span class="line">mongoreplset:SECONDARY&gt; db.people.<span class="function"><span class="title">find</span></span>()</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5f3b810824e755927a408da7&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;percy1&quot;</span>, <span class="string">&quot;age&quot;</span> : 18 &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5f3b810924e755927a408da8&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;percy2&quot;</span>, <span class="string">&quot;age&quot;</span> : 19 &#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证故障转移"><a href="#验证故障转移" class="headerlink" title="验证故障转移"></a>验证故障转移</h3><p>副本集模式下，如果Primary不可用，整个集群将会选举出新的Primary来继续对外提供读写服务，一起来验证一下 mymongo1 不可用的时候的状况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止 master</span></span><br><span class="line">docker stop mymongo1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 mymongo2, 发现 mymongo2 已切换为 master</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mymongo2 mongo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新启动 mymongo1</span></span><br><span class="line">docker start mymongo1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 mymongo1 的状态</span></span><br><span class="line">rs.status()</span><br><span class="line"><span class="comment"># 可以看到 mymonogo1 重新连入了副本集，但是是作为secondry，primary仍然是 mymongo2</span></span><br><span class="line"><span class="comment"># 查看 members 可以看到有三个节点，且能看到各个节点的信息</span></span><br></pre></td></tr></table></figure>

<h2 id="分片集群-（sharding）"><a href="#分片集群-（sharding）" class="headerlink" title="分片集群 （sharding）"></a>分片集群 （sharding）</h2><h3 id="docker-搭建-1"><a href="#docker-搭建-1" class="headerlink" title="docker 搭建"></a>docker 搭建</h3><p>参看： go-mod&#x2F;k8s&#x2F;docker&#x2F;mongo&#x2F;sharding</p>
<h3 id="验证数据分片"><a href="#验证数据分片" class="headerlink" title="验证数据分片"></a>验证数据分片</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入 mongos</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mymongo_mongos1 mongo --port 27017</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先在mongos配置一个database并启动分片</span></span><br><span class="line">sh.enableSharding(<span class="string">&quot;mapp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对order集合设置分片规则</span></span><br><span class="line">sh.shardCollection(<span class="string">&quot;mapp.order&quot;</span>, &#123;<span class="string">&quot;_id&quot;</span>: <span class="string">&quot;hashed&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mock 数据</span></span><br><span class="line">use mapp</span><br><span class="line"><span class="keyword">for</span> (i = 1; i &lt;= 1000; i=i+1)&#123;</span><br><span class="line">    db.order.insert(&#123;<span class="string">&#x27;price&#x27;</span>: 1&#125;)</span><br><span class="line">&#125;</span><br><span class="line">db.order.find().count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在两个分片集群中查看</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mymongo_shard1 mongo --port 27018</span><br><span class="line">use mapp</span><br><span class="line">db.order.find().count()</span><br><span class="line">454</span><br></pre></td></tr></table></figure>

<h3 id="explain-分析查询"><a href="#explain-分析查询" class="headerlink" title="explain 分析查询"></a>explain 分析查询</h3><p>参看： go-mod&#x2F;k8s&#x2F;docker&#x2F;mongo&#x2F;sharding</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="http://longofo.cc/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAmongodb%E5%89%AF%E6%9C%AC%E9%9B%86.html">docker 搭建副本集集群</a></p>
<p><a target="_blank" rel="noopener" href="https://leel0330.github.io/post/docker%E6%90%AD%E5%BB%BAmongodb%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4/">docker 搭建分片集群</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.ibm.com/zh/articles/os-mongodb-sharded-cluster/">mongodb 分片使用</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/08/14/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B%E4%B9%8Bredis%E9%9B%86%E7%BE%A4%E4%B9%8B%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/14/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B%E4%B9%8Bredis%E9%9B%86%E7%BE%A4%E4%B9%8B%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">分布式系统实例之redis 集群之概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-14 19:59:01" itemprop="dateCreated datePublished" datetime="2020-08-14T19:59:01+08:00">2020-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>cluster&gt;node(ip:port)&gt;slot(ip:port:slot)&gt;key</p>
<h2 id="如何搭建redis集群"><a href="#如何搭建redis集群" class="headerlink" title="如何搭建redis集群"></a>如何搭建redis集群</h2><p>省略</p>
<h2 id="redis集群slot"><a href="#redis集群slot" class="headerlink" title="redis集群slot"></a>redis集群slot</h2><p>Redis 集群使用数据分片（sharding）而非一致性哈希（consistency hashing）来实现： 一个 Redis 集群包含 16384 个哈希槽（hash slot）， 数据库中的每个键都属于这 16384 个哈希槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p>
<p><strong>如下可以看到，当执行指令 <code>set name percy</code>时，6381服务器返回了 MOVED 错误，并返回正确的机器地址</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@redis-cluster-0:/data# redis-cli -p 6381</span><br><span class="line">127.0.0.1:6381&gt; set name percy</span><br><span class="line">(error) MOVED 5798 10.244.14.157:6380</span><br><span class="line">127.0.0.1:6381&gt; get name percy</span><br><span class="line">(error) ERR wrong number of arguments for &#x27;get&#x27; command</span><br><span class="line">127.0.0.1:6381&gt; get name</span><br><span class="line">(error) MOVED 5798 10.244.14.157:6380</span><br><span class="line">127.0.0.1:6381&gt; exit</span><br><span class="line">root@redis-cluster-0:/data# redis-cli -p 6380</span><br><span class="line">127.0.0.1:6380&gt; get name</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6380&gt; exit</span><br><span class="line">root@redis-cluster-0:/data# redis-cli -p 6380</span><br><span class="line">127.0.0.1:6380&gt; set name percy</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>Redis 集群对节点使用了主从复制功能： 集群中的每个节点都有 1 个至 N 个复制品（replica）， 其中一个复制品为主节点（master）， 而其余的 N-1 个复制品为从节点（slave）。</p>
<h2 id="Redis一致性保证"><a href="#Redis一致性保证" class="headerlink" title="Redis一致性保证"></a>Redis一致性保证</h2><p>Redis 并不能保证数据的强一致性. 这意味这在实际中集群在特定的条件下可能会丢失写操作：一个原因是因为集群是用了异步复制. 写操作过程:</p>
<ol>
<li>客户端向主节点B写入一条命令.</li>
<li>主节点B向客户端回复命令状态.</li>
<li>主节点将写操作复制给他得从节点 B1, B2 和 B3</li>
</ol>
<p>可以看到是异步的主从同步。</p>
<h2 id="集群加入新节点"><a href="#集群加入新节点" class="headerlink" title="集群加入新节点"></a>集群加入新节点</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">集群中加节点， 节点被加入集群后不会自动分配 slot， 需要手动执行指令</span></span><br><span class="line">bin/redis-trib add-node 127.0.0.1:7006 127.0.0.1:7000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分配slot</span></span><br><span class="line">/bin/redis-trib reshard 127.0.0.1:7000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分配 slot 时，可以选择该节点分配多少slot, 从哪里分配(all 表示全部)</span></span><br></pre></td></tr></table></figure>

<h3 id="MIGRATE"><a href="#MIGRATE" class="headerlink" title="MIGRATE"></a>MIGRATE</h3><p>因为 Redis 集群目前在进行重分片的时候， 会使用 <a target="_blank" rel="noopener" href="http://redisdoc.com/internal/migrate.html">MIGRATE</a> 命令， 将被迁移的槽包含的每个键从原节点移动到新节点， 就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for key in all_keys_in_target_slot:</span><br><span class="line">    使用 MIGRATE 将键 key 从当前节点（原节点）移动到新节点</span><br></pre></td></tr></table></figure>

<p>并且在每个 <code>MIGRATE</code> 命令执行的过程中， 原节点和新节点都会被阻塞（因为原子操作）， 直到命令执行完毕为止。 因此如果你直接对生产环境中的集群执行重分片操作， 而涉及该操作的两个节点正好又是被频繁访问的节点的话， 那么访问这两个节点的其他客户端就很可能会出现大量的超时错误。</p>
<h2 id="客户端路由"><a href="#客户端路由" class="headerlink" title="客户端路由"></a>客户端路由</h2><p>所以，综合上述情况，客户端命令执行流程如下所示：</p>
<p>客户端根据本地 slot 缓存发送命令到源节点，如果存在键对应则直接执行并返回结果给客户端。<br>如果节点返回 MOVED 错误，更新本地的 slot 到 Redis 节点的映射关系，然后重新发起请求。<br>如果数据正在迁移中，节点会回复 ASK 重定向异常。格式如下: ( error ) ASK { slot } { targetIP } : { targetPort }</p>
<p>客户端从 ASK 重定向异常提取出目标节点信息，发送 asking 命令到目标节点打开客户端连接标识，再执行键命令。<br>ASK 和 MOVED 虽然都是对客户端的重定向控制，但是有着本质区别。ASK 重定向说明集群正在进行 slot 数据迁移，客户端无法知道什么时候迁移完成，因此只能是临时性的重定向，客户端不会更新 slot 到 Redis 节点的映射缓存。但是 MOVED 重定向说明键对应的槽已经明确指定到新的节点，因此需要更新 slot 到 Redis 节点的映射缓存。</p>
<h3 id="P2P路由"><a href="#P2P路由" class="headerlink" title="P2P路由"></a>P2P路由</h3><p>现在我们考虑如何实现去中心化的访问，也就是说无论访问集群中的哪个节点，你都能够拿到想要的数据。其实这有点类似于路由器的路由表，具体说来就是：</p>
<ul>
<li><p>每个节点都保存有完整的HashSlot - 节点映射表，也就是说，每个节点都知道自己拥有哪些Slot，以及某个确定的Slot究竟对应着哪个节点。</p>
</li>
<li><p>无论向哪个节点发出寻找Key的请求，该节点都会通过CRC(Key) % 16384计算该Key究竟存在于哪个Slot，并将请求转发至该Slot所在的节点（实际上不是转发，是返回error Moved）。</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>最佳的， redis命令参考：<a target="_blank" rel="noopener" href="http://redisdoc.com/index.html">http://redisdoc.com/index.html</a></p>
<p>整体还是可以的：<a target="_blank" rel="noopener" href="https://juejin.im/entry/596343056fb9a06bc340ac15">https://juejin.im/entry/596343056fb9a06bc340ac15</a></p>
<p>为什么是16384：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/rjzheng/p/11430592.html">https://www.cnblogs.com/rjzheng/p/11430592.html</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/antirez/redis/issues/2576">https://github.com/antirez/redis/issues/2576</a></p>
<p>挺好的：<a target="_blank" rel="noopener" href="https://juejin.im/post/5cf7c811f265da1b7a4b6368#heading-4">https://juejin.im/post/5cf7c811f265da1b7a4b6368#heading-4</a></p>
<p>重分片对 Redis 集群的性能影响分析：很不错的一篇文章：<a target="_blank" rel="noopener" href="https://blog.huangz.me/2017/redis-reshard-performance-issue.html">https://blog.huangz.me/2017/redis-reshard-performance-issue.html</a></p>
<p>单节点数据扩容：<a target="_blank" rel="noopener" href="https://my.oschina.net/u/4399312/blog/4127334">https://my.oschina.net/u/4399312/blog/4127334</a></p>
<p>高级开发不得不懂的Redis Cluster数据分片机制：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lowmanisbusy/p/10993748.html">https://www.cnblogs.com/lowmanisbusy/p/10993748.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Percy"
      src="https://ivalue2333.github.io/percy/images/percy.jpg">
  <p class="site-author-name" itemprop="name">Percy</p>
  <div class="site-description" itemprop="description">IOT2014</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">156</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">194</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Percy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
