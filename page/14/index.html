<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="IOT2014">
<meta property="og:type" content="website">
<meta property="og:title" content="blog | percy">
<meta property="og:url" content="http://example.com/page/14/index.html">
<meta property="og:site_name" content="blog | percy">
<meta property="og:description" content="IOT2014">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Percy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>blog | percy</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blog | percy</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/10/28/learn/htpasswd%E5%9C%A8nginx%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/28/learn/htpasswd%E5%9C%A8nginx%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">htpasswd在nginx中的使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-28 16:53:13" itemprop="dateCreated datePublished" datetime="2019-10-28T16:53:13+08:00">2019-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="htpasswd"><a href="#htpasswd" class="headerlink" title="htpasswd"></a>htpasswd</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ubuntu</span></span><br><span class="line">sudo apt-get install apache2-utils</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">centos</span></span><br><span class="line">yum -y install httpd</span><br></pre></td></tr></table></figure>

<h3 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-c 创建passwdfile.如果passwdfile 已经存在,那么它会重新写入并删去原有内容.</span><br><span class="line">-n 不更新passwordfile，只将加密后的用户名密码显示在屏幕上；</span><br><span class="line">-b 命令行中一并输入用户名和密码而不是根据提示输入密码，可以看见明文，不需要交互</span><br><span class="line">-i 从标准输入中读取密码并且不做验证</span><br><span class="line">-m 强制使用MD5加密密码(默认)</span><br><span class="line">-d 采用CRYPT算法对密码进行加密</span><br><span class="line">-p 不对密码进行进行加密，即使用普通文本格式的密码</span><br><span class="line">-s 采用SHA算法对密码进行加密</span><br><span class="line">-D 删除指定的用户</span><br></pre></td></tr></table></figure>

<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><h4 id="生成密码"><a href="#生成密码" class="headerlink" title="生成密码"></a>生成密码</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@upupup:~# htpasswd -c /tmp/aa admin</span><br><span class="line">New password: </span><br><span class="line">Re-type new password: </span><br><span class="line">Adding password for user admin</span><br><span class="line">root@upupup:~# vim /tmp/aa </span><br></pre></td></tr></table></figure>

<h4 id="nginx中使用"><a href="#nginx中使用" class="headerlink" title="nginx中使用"></a>nginx中使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /auth &#123;</span><br><span class="line">     auth_basic &quot;Restricted&quot;;</span><br><span class="line">     # 这里是刚才文件的地址</span><br><span class="line">     auth_basic_user_file //tmp/aa;</span><br><span class="line">     vhost_traffic_status_display;</span><br><span class="line">     vhost_traffic_status_display_format html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<p><img src="https://s2.ax1x.com/2019/10/28/Kc8yD0.jpg"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zyw_java/article/details/80561316">https://blog.csdn.net/zyw_java/article/details/80561316</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/10/14/golang/golang%20%E4%B8%AD%E7%9A%84%20pprof/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/14/golang/golang%20%E4%B8%AD%E7%9A%84%20pprof/" class="post-title-link" itemprop="url">golang 中的 pprof</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-14 19:08:33" itemprop="dateCreated datePublished" datetime="2019-10-14T19:08:33+08:00">2019-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-26 23:35:58" itemprop="dateModified" datetime="2023-02-26T23:35:58+08:00">2023-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="pprof-是什么"><a href="#pprof-是什么" class="headerlink" title="pprof 是什么"></a>pprof 是什么</h2><p>[TOC]</p>
<p>pprof 是用于可视化和分析性能分析数据的工具</p>
<h3 id="可以做什么"><a href="#可以做什么" class="headerlink" title="可以做什么"></a>可以做什么</h3><ul>
<li>CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置</li>
<li>Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏</li>
<li>Block Profiling：阻塞分析，记录 goroutine 阻塞等待同步（包括定时器通道）的位置</li>
<li>Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况</li>
</ul>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="一个简单的demo"><a href="#一个简单的demo" class="headerlink" title="一个简单的demo"></a>一个简单的demo</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	_ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; <span class="literal">true</span>; i ++&#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;sleep i%d start\n&quot;</span>, i)</span><br><span class="line">			time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">			fmt.Printf(<span class="string">&quot;sleep i%d end\n&quot;</span>, i)</span><br><span class="line">		&#125;(i)</span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 开启pprof，监听请求</span></span><br><span class="line">	ip := <span class="string">&quot;0.0.0.0:6060&quot;</span></span><br><span class="line">	<span class="keyword">go</span> test()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 两种都可以</span></span><br><span class="line">	fmt.Println( http.ListenAndServe(ip, <span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">//if err := http.ListenAndServe(ip, nil); err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	fmt.Printf(&quot;start pprof failed on %s\n&quot;, ip)</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行这个文件，你的 HTTP 服务会多出 /debug/pprof 的 endpoint 可用于观察应用程序的情况</span></span><br></pre></td></tr></table></figure>

<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="web-页分析"><a href="#web-页分析" class="headerlink" title="web 页分析"></a>web 页分析</h5><p>访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:6060/debug/pprof/">http://127.0.0.1:6060/debug/pprof/</a></p>
<p>各个选项的作用</p>
<ul>
<li>profile：CPU profile，$HOST&#x2F;debug&#x2F;pprof&#x2F;profile，默认进行 30s 的 CPU Profiling，得到一个分析用的 profile 文件，使用 <code>go tool pprof command </code> 来分析数据</li>
<li>allocs：所有过去内存分配的采样</li>
<li>block（Block Profiling）：<code>$HOST/debug/pprof/block</code>，查看导致阻塞同步的堆栈跟踪</li>
<li>goroutine：<code>$HOST/debug/pprof/goroutine</code>，查看当前所有运行的 goroutines 堆栈跟踪</li>
<li>heap（Memory Profiling）: <code>$HOST/debug/pprof/heap</code>，查看活动对象的内存分配情况</li>
<li>threadcreate：<code>$HOST/debug/pprof/threadcreate</code>，查看创建新OS线程的堆栈跟踪</li>
</ul>
<h5 id="终端分析"><a href="#终端分析" class="headerlink" title="终端分析"></a>终端分析</h5><p>获取cpu</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof http://localhost:6060/debug/pprof/profile?seconds=60</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">完成后执行</span></span><br><span class="line">top10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果退出后，可直接使用文件</span></span><br><span class="line">go tool pprof pprof.qc-misc.samples.cpu.001.pb.gz </span><br><span class="line"></span><br><span class="line">go tool pprof http://localhost:18089/debug/pprof/profile?seconds=60</span><br><span class="line"></span><br><span class="line">go tool pprof http://localhost:18089/debug/pprof/heap</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">堆内存分析的默认“类型”是“在用内存”。还有一种“类型”，表示程序在整个生命周期分配的内存总量，可以使用 -alloc_space 标识切换到这种模式：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以根据自己的需要，选择 -inuse_space 或者 -alloc_space 标签。例如，在考察垃圾回收的性能时，你需要的就是 -alloc_space。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要考察生成对象的数量，可以用 -inuse_objects 和 -alloc_objects 标签。</span></span><br><span class="line">go tool pprof -alloc_space http://localhost:18089/debug/pprof/heap</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用 runtime.gcDrain 扫描工作缓冲区 runtime.gcWork。在调用 runtime.gcDrain 函数时，运行时会传入处理器上的 runtime.gcWork，这个结构体是垃圾收集器中工作池的抽象，它实现了一个生产者和消费者的模型，我们可以以该结构体为起点从整体理解标记工作。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行时会使用 runtime.gcDrain 函数扫描工作缓冲区中的灰色对象，它会根据传入 gcDrainFlags 的不同选择不同的策略：</span></span><br></pre></td></tr></table></figure>

<p>名称释义</p>
<ul>
<li>flat：给定函数上运行耗时</li>
<li>flat%：给定函数上运行耗时总比例</li>
<li>sum%：给定函数累积使用 CPU 总比例</li>
<li>cum：当前函数加上它之上的调用运行总耗时</li>
<li>cum%：当前函数加上它之上的调用运行总耗时比例，假如main函数调用了函数f，函数f占用的内存量，也会记进来。</li>
</ul>
<h5 id="测试-火焰图"><a href="#测试-火焰图" class="headerlink" title="测试-火焰图"></a>测试-火焰图</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&quot;https://github.com/EDDYCJY&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> datas []<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(str <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	data := []<span class="type">byte</span>(str)</span><br><span class="line">	sData := <span class="type">string</span>(data)</span><br><span class="line">	datas = <span class="built_in">append</span>(datas, sData)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	s := Add(url)</span><br><span class="line">	<span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;Test.Add error!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAdd</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		Add(url)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动 PProf 可视化界面</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过go 安装这个功能，go get -u github.com/google/pprof</span></span><br><span class="line">pprof -http=:8080 cpu.prof</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用顺序由上到下（A -&gt; B -&gt; C -&gt; D），每一块代表一个函数，越大代表占用 CPU 的时间更长。同时它也支持点击块深入进行分析！</span></span><br></pre></td></tr></table></figure>

<h5 id="web-ui"><a href="#web-ui" class="headerlink" title="web ui"></a>web ui</h5><p>重点！！！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对使用 go tool pprof http://localhost:6060/debug/pprof/profile?seconds=60 采样到的数据，做web 展示</span></span><br><span class="line">pprof -http=:8080 pprof.samples.cpu.002.pb.gz</span><br></pre></td></tr></table></figure>

<h3 id="goroutine泄露"><a href="#goroutine泄露" class="headerlink" title="goroutine泄露"></a>goroutine泄露</h3><p>如果你启动了1个goroutine，但并没有符合预期的退出，直到程序结束，此goroutine才退出，这种情况就是goroutine泄露。</p>
<p>每个goroutine占用2KB内存，泄露1百万goroutine至少泄露2KB * 1000000 &#x3D; 2GB内存，为什么说至少呢？因为goroutine执行过程中还存在一些变量，如果这些变量指向堆内存中的内存，GC会认为这些内存仍在使用，不会对其进行回收，这些内存谁都无法使用，造成了内存泄露。</p>
<p>所以goroutine泄露有2种方式造成内存泄露：</p>
<ol>
<li>goroutine本身的栈所占用的空间造成内存泄露。</li>
<li>goroutine中的变量所占用的堆内存导致堆内存泄露，这一部分是能通过heap profile体现出来的。</li>
</ol>
<h4 id="goroutine泄露的demo"><a href="#goroutine泄露的demo" class="headerlink" title="goroutine泄露的demo"></a>goroutine泄露的demo</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// goroutine泄露导致内存泄露</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	_ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 开启pprof</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ip := <span class="string">&quot;0.0.0.0:6060&quot;</span></span><br><span class="line">		<span class="keyword">if</span> err := http.ListenAndServe(ip, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;start pprof failed on %s\n&quot;</span>, ip)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	outCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="comment">// 死代码，永不读取</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">			&lt;-outCh</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每s起100个goroutine，goroutine会阻塞，不释放内存</span></span><br><span class="line">	tick := time.Tick(time.Second / <span class="number">100</span>)</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> tick &#123;</span><br><span class="line">		i++</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">		alloc1(outCh)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alloc1</span><span class="params">(outCh <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> alloc2(outCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alloc2</span><span class="params">(outCh <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;alloc-fm exit&quot;</span>)</span><br><span class="line">		<span class="comment">// 分配内存，假用一下</span></span><br><span class="line">		buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>)</span><br><span class="line">		_ = <span class="built_in">len</span>(buf)</span><br><span class="line">		fmt.Println(<span class="string">&quot;alloc done&quot;</span>)</span><br><span class="line"></span><br><span class="line">		outCh &lt;- <span class="number">0</span> <span class="comment">// 53行</span></span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行goroutine采样</span></span><br><span class="line">go tool pprof http://localhost:6060/debug/pprof/goroutine</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">kill</span>掉，并再次执行</span></span><br><span class="line">go tool pprof http://localhost:6060/debug/pprof/goroutine</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行对比</span></span><br><span class="line"></span><br><span class="line">go tool pprof -base pprof.goroutine.001.pb.gz pprof.goroutine.002.pb.gz</span><br><span class="line"></span><br><span class="line">Showing nodes accounting for 646, 100% of 646 total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">       646   100%   100%        646   100%  runtime.gopark</span><br><span class="line">         0     0%   100%        646   100%  main.alloc2</span><br><span class="line">         0     0%   100%        646   100%  main.alloc2.func1</span><br><span class="line">         0     0%   100%        646   100%  runtime.chansend</span><br><span class="line">         0     0%   100%        646   100%  runtime.chansend1</span><br><span class="line">         0     0%   100%        646   100%  runtime.goparkunlock</span><br><span class="line">         </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以看到goroutine 增加了646个，再单看002</span></span><br><span class="line"></span><br><span class="line">go tool pprof pprof.goroutine.002.pb.gz</span><br><span class="line"></span><br><span class="line">Showing nodes accounting for 895, 99.89% of 896 total</span><br><span class="line">Dropped 33 nodes (cum &lt;= 4)</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">       895 99.89% 99.89%        895 99.89%  runtime.gopark</span><br><span class="line">         0     0% 99.89%        891 99.44%  main.alloc2</span><br><span class="line">         0     0% 99.89%        891 99.44%  main.alloc2.func1</span><br><span class="line">         0     0% 99.89%        891 99.44%  runtime.chansend</span><br><span class="line">         0     0% 99.89%        891 99.44%  runtime.chansend1</span><br><span class="line">         0     0% 99.89%        892 99.55%  runtime.goparkunlock</span><br><span class="line">         </span><br><span class="line">显示有895个goroutine被挂起，这不是goroutine泄露这是啥？已经能确定八九成goroutine泄露了。</span><br></pre></td></tr></table></figure>

<h4 id="Web可视化查看goroutine泄露"><a href="#Web可视化查看goroutine泄露" class="headerlink" title="Web可视化查看goroutine泄露"></a>Web可视化查看goroutine泄露</h4><p>访问 <a target="_blank" rel="noopener" href="http://localhost:6060/debug/pprof/goroutine?debug=1">http://localhost:6060/debug/pprof/goroutine?debug=1</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">goroutine profile: total 7876 （总的goroutine）</span><br><span class="line">7871 （这个函数的goroutine） @ 0x4322a4 0x404db9 0x404d8f 0x404b65 0x72d7b9 0x72d472 0x45d761</span><br><span class="line">#	0x72d7b8	main.alloc2.func1+0x118	C:/Users/13722/data/gopath/src/github.com/ivalue2333/go-science/framework/pprof_demo/first/main2.go:53 （显然是这里泄露了）</span><br><span class="line">#	0x72d471	main.alloc2+0x31	C:/Users/13722/data/gopath/src/github.com/ivalue2333/go-science/framework/pprof_demo/first/main2.go:54</span><br><span class="line"></span><br><span class="line">1 @ 0x403e15 0x44c42a 0x4a710c 0x4c54d3 0x56e903 0x56fb6b 0x589989 0x58825f 0x6a1a16 0x6a0844 0x6a057b 0x72d583 0x72d529 0x45d761</span><br><span class="line">#	0x44c429	syscall.Syscall+0xe9				C:/Users/13722/data/software/go1.12.9/go/src/runtime/syscall_windows.go:184</span><br><span class="line">#	0x4a710b	syscall.SetFileCompletionNotificationModes+0x6b	C:/Users/13722/data/software/go1.12.9/go/src/syscall/zsyscall_windows.go:1747</span><br><span class="line">#	0x4c54d2	internal/poll.(*FD).Init+0x102			C:/Users/13722/data/software/go1.12.9/go/src/internal/poll/fd_windows.go:395</span><br><span class="line">#	0x56e902	net.(*netFD).init+0x52				C:/Users/13722/data/software/go1.12.9/go/src/net/fd_windows.go:56</span><br><span class="line">#	0x56fb6a	net.(*netFD).accept+0x2aa			C:/Users/13722/data/software/go1.12.9/go/src/net/fd_windows.go:210</span><br><span class="line">#	0x589988	net.(*TCPListener).accept+0x38			C:/Users/13722/data/software/go1.12.9/go/src/net/tcpsock_posix.go:139</span><br><span class="line">#	0x58825e	net.(*TCPListener).AcceptTCP+0x4e		C:/Users/13722/data/software/go1.12.9/go/src/net/tcpsock.go:247</span><br><span class="line">#	0x6a1a15	net/http.tcpKeepAliveListener.Accept+0x35	C:/Users/13722/data/software/go1.12.9/go/src/net/http/server.go:3264</span><br><span class="line">#	0x6a0843	net/http.(*Server).Serve+0x233			C:/Users/13722/data/software/go1.12.9/go/src/net/http/server.go:2859</span><br><span class="line">#	0x6a057a	net/http.(*Server).ListenAndServe+0xea		C:/Users/13722/data/software/go1.12.9/go/src/net/http/server.go:2797</span><br><span class="line">#	0x72d582	net/http.ListenAndServe+0x82			C:/Users/13722/data/software/go1.12.9/go/src/net/http/server.go:3037</span><br><span class="line">#	0x72d528	main.main.func1+0x28				C:/Users/13722/data/gopath/src/github.com/ivalue2333/go-science/framework/pprof_demo/first/main2.go:16</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="命令行交互式方法"><a href="#命令行交互式方法" class="headerlink" title="命令行交互式方法"></a>命令行交互式方法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof -base pprof.leak_demo.goroutine.001.pb.gz pprof.leak_demo.goroutine.002.pb.gz</span><br><span class="line"></span><br><span class="line">traces</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">traces能列出002中比001中多的那些goroutine的调用栈，这里只有1个调用栈，有20312个goroutine都执行这个调用路径，可以看到alloc2中的匿名函数alloc2.func1调用了写channel的操作，然后阻塞挂起了goroutine，使用list列出alloc2.func1的代码，显示有20312个goroutine阻塞在53行：</span></span><br><span class="line"></span><br><span class="line">list main.alloc2.func1</span><br></pre></td></tr></table></figure>

<h2 id="一些指令"><a href="#一些指令" class="headerlink" title="一些指令"></a>一些指令</h2><h3 id="生成图像"><a href="#生成图像" class="headerlink" title="生成图像"></a>生成图像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要生成分析图像可以使用 -png、-gif 或 -svg 标签，重定向 stdout 到“文件”：</span></span><br><span class="line">go tool pprof -png http://localhost:6060/debug/pprof/heap &gt; data.png</span><br></pre></td></tr></table></figure>

<h3 id="inuse-alloc-space-inuse-alloc-objects区别"><a href="#inuse-alloc-space-inuse-alloc-objects区别" class="headerlink" title="--inuse/alloc_space --inuse/alloc_objects区别"></a><code>--inuse/alloc_space</code> <code>--inuse/alloc_objects</code>区别</h3><p>通常情况下：</p>
<ul>
<li>用<code>--inuse_space</code>来分析程序常驻内存的占用情况;</li>
<li>用<code>--alloc_objects</code>来分析内存的临时分配情况，可以提高程序的运行速度。</li>
</ul>
<h2 id="输出理解"><a href="#输出理解" class="headerlink" title="输出理解"></a>输出理解</h2><h3 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/fpWs2t"><img src="https://z3.ax1x.com/2021/08/02/fpWs2t.png" alt="fpWs2t.png"></a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="goroutine泄露的本质"><a href="#goroutine泄露的本质" class="headerlink" title="goroutine泄露的本质"></a>goroutine泄露的本质</h3><p>goroutine泄露的本质是channel阻塞，无法继续向下执行，导致此goroutine关联的内存都无法释放，进一步造成内存泄露。</p>
<h3 id="goroutine泄露的发现和定位"><a href="#goroutine泄露的发现和定位" class="headerlink" title="goroutine泄露的发现和定位"></a>goroutine泄露的发现和定位</h3><p>利用好go pprof获取goroutine profile文件，然后利用3个命令top、traces、list定位内存泄露的原因。</p>
<h3 id="goroutine泄露的场景"><a href="#goroutine泄露的场景" class="headerlink" title="goroutine泄露的场景"></a>goroutine泄露的场景</h3><p>泄露的场景不仅限于以下两类，但因channel相关的泄露是最多的。</p>
<ol>
<li>channel的读或者写：<ol>
<li>无缓冲channel的阻塞通常是写操作因为没有读而阻塞</li>
<li>有缓冲的channel因为缓冲区满了，写操作阻塞</li>
<li>期待从channel读数据，结果没有goroutine写</li>
</ol>
</li>
<li>select操作，select里也是channel操作，如果所有case上的操作阻塞，goroutine也无法继续执行。</li>
</ol>
<h3 id="编码goroutine泄露的建议"><a href="#编码goroutine泄露的建议" class="headerlink" title="编码goroutine泄露的建议"></a>编码goroutine泄露的建议</h3><p>为避免goroutine泄露造成内存泄露，启动goroutine前要思考清楚：</p>
<ol>
<li>goroutine如何退出？</li>
<li>是否会有阻塞造成无法退出？如果有，那么这个路径是否会创建大量的goroutine？</li>
</ol>
<h2 id="一次问题分析"><a href="#一次问题分析" class="headerlink" title="一次问题分析"></a>一次问题分析</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">前面分析了porfile，发现频繁GC，于是分析内存，分析实时内存效果不佳，开始分析累计内存</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">（不到1分钟执行两次下面操作）看下面的结果，很明显能看到，不到一分钟的时间，NewLeechedGinResponseWriter这个函数申请了6个G的内存，这个肯定就是代码有问题了。</span></span><br><span class="line"></span><br><span class="line">go tool pprof -alloc_space http://localhost:18089/debug/pprof/heap</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">350.43GB 33.95% 33.95%   350.43GB 33.95%  github.com/nickxb/gin-http-logger.NewLeechedGinResponseWriter</span></span><br><span class="line"></span><br><span class="line">go tool pprof -alloc_space http://localhost:18089/debug/pprof/heap</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">356.08GB 33.98% 33.98%   356.08GB 33.98%  github.com/nickxb/gin-http-logger.NewLeechedGinResponseWriter</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接访问 web</span></span><br><span class="line">http://10.112.4.199:9499/debug/pprof/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远端</span></span><br><span class="line">go tool pprof -alloc_space http://10.112.4.199:9499/debug/pprof/profile</span><br><span class="line">go tool pprof -alloc_space http://10.145.49.36:9385//debug/pprof/heap\?seconds=10</span><br><span class="line"></span><br><span class="line">go tool pprof http://10.112.4.199:9499/debug/pprof/profile\?seconds\=10s -output cpu.pprof</span><br><span class="line"></span><br><span class="line">go tool pprof -png http://10.112.4.199:9499/debug/pprof/heap\?seconds\=10 &gt; data.png</span><br><span class="line"></span><br><span class="line">go tool pprof -http :8888 http://ip:port/debug/pprof/</span><br><span class="line">go tool pprof -http :8888 http://10.22.31.47:9489/debug/pprof/</span><br><span class="line"></span><br><span class="line">go tool pprof -http :8888 http://fdbd:dc02:4:239::19:9211/debug/pprof/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种可视化数据的方法是火焰图，需手动安装原生 PProf 工具：</span></span><br><span class="line"><span class="comment"># pprof</span></span><br><span class="line">go get -u github.com/google/pprof</span><br><span class="line"><span class="comment"># https://graphviz.org/download/</span></span><br><span class="line">brew install graphviz</span><br><span class="line"></span><br><span class="line">pprof -http=:8080 cpu.prof</span><br><span class="line"></span><br><span class="line">go tool pprof http://fdbd:dc02:108:311::172:9370/debug/pprof/heap?seconds\=20s</span><br><span class="line"></span><br><span class="line">top10</span><br><span class="line">top20 -cum</span><br><span class="line">traces</span><br><span class="line">list</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016412013">煎鱼pprof文章,很适合入门</a></p>
<p><a target="_blank" rel="noopener" href="http://lessisbetter.site/2019/05/18/go-goroutine-leak/">入门文章</a></p>
<p><a target="_blank" rel="noopener" href="https://lrita.github.io/2017/05/26/golang-memory-pprof/#go-tool">go pprof </a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dillanzhou/article/details/107032180">heap pprof 含义</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/10/12/redis/redis%E4%B8%ADscan%E7%9A%84%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/12/redis/redis%E4%B8%ADscan%E7%9A%84%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">redis中scan的详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-12 20:40:33" itemprop="dateCreated datePublished" datetime="2019-10-12T20:40:33+08:00">2019-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">从开始开始遍历</span></span><br><span class="line"> scan 0 MATCH key* COUNT 10</span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">或者</span></span><br><span class="line"> scan 0 MATCH &quot;key*&quot; COUNT 10</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">它有两个返回值，第一个返回值，表示下一次游标开始的位置，第二个返回值，是一个key的数组，当返回的游标再一次是<span class="string">&quot;0&quot;</span>时，表示遍历完成。（这是唯一迭代结束的判定方式，而不能通过返回结果集是否为空判断迭代结束。）</span></span><br><span class="line">1) &quot;76&quot;</span><br><span class="line">2)  1) &quot;key56&quot;</span><br><span class="line">    2) &quot;key91&quot;</span><br><span class="line">    3) &quot;key17&quot;</span><br><span class="line">    4) &quot;key51&quot;</span><br><span class="line">    5) &quot;key54&quot;</span><br><span class="line">    6) &quot;key86&quot;</span><br><span class="line">    7) &quot;key98&quot;</span><br><span class="line">    8) &quot;key0&quot;</span><br><span class="line">    9) &quot;key41&quot;</span><br><span class="line">   10) &quot;key97&quot;</span><br><span class="line">   11) &quot;key82&quot;</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如，下一次迭代</span></span><br><span class="line">scan 76 MATCH &quot;key*&quot; COUNT 10</span><br></pre></td></tr></table></figure>

<h3 id="和keys对比"><a href="#和keys对比" class="headerlink" title="和keys对比"></a>和keys对比</h3><p>keys *的缺点</p>
<ul>
<li>没有 offset、limit 参数，一次性吐出所有满足条件的 key，万一实例中有几百 w 个 key 满足条件，</li>
<li>keys 算法是遍历算法，复杂度是 O(n)，如果实例中有千万级以上的 key，这个指令就会导致 Redis 服务卡顿，</li>
<li>所有读写 Redis 的其它的指令都会被延后甚至会超时报错，</li>
<li>因为 Redis 是单线程程序，顺序执行所有指令，其它指令必须等到当前的 keys 指令执行完了才可以继续。</li>
<li><strong>建议生产环境屏蔽keys命令</strong></li>
</ul>
<h3 id="大key扫描"><a href="#大key扫描" class="headerlink" title="大key扫描"></a>大key扫描</h3><p>有时候会因为业务人员使用不当，在 Redis 实例中会形成很大的对象，比如一个很大的 hash，一个很大的 zset 这都是经常出现的。这样的问题是在内存分配上，如果一个 key 太大，那么当它需要扩容时，会一次性申请更大的一块内存，这也会导致卡顿。如果这个大 key 被删除，内存会一次性回收，卡顿现象会再一次产生。</p>
<h4 id="如何定位大key"><a href="#如何定位大key" class="headerlink" title="如何定位大key"></a>如何定位大key</h4><p>用 <code>scan</code> 指令，对于扫描出来的每一个 key，使用 type 指令获得 key 的类型，然后使用相应数据结构的 size 或者 len 方法来得到它的大小，对于每一种类型，保留大小的前 N 名作为扫描结果展示出来。</p>
<p>上面这样的过程需要编写脚本，比较繁琐，不过 Redis 官方已经在 redis-cli 指令中提供了这样的扫描功能，我们可以直接拿来即用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-cli  --bigkeys</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果你担心这个指令会大幅抬升 Redis 的 ops 导致线上报警，还可以增加一个休眠参数。</span></span><br><span class="line">redis-cli --bigkeys -i 0.1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面这个指令每隔 100 条 scan 指令就会休眠 0.1s，ops 就不会剧烈抬升，但是扫描的时间会变长。</span></span><br></pre></td></tr></table></figure>

<h2 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h2><h3 id="count选项"><a href="#count选项" class="headerlink" title="count选项"></a>count选项</h3><p>虽然增量式迭代命令不保证每次迭代所返回的元素数量， 但我们可以使用 COUNT 选项， 对命令的行为进行一定程度上的调整。</p>
<p>基本上， COUNT 选项的作用就是让用户告知迭代命令， 在每次迭代中应该从数据集里返回多少元素。</p>
<p>虽然 COUNT 选项只是对增量式迭代命令的一种提示（hint）， 但是在大多数情况下， 这种提示都是有效的。</p>
<p>COUNT 参数的默认值为 10 </p>
<h3 id="MATCH-选项"><a href="#MATCH-选项" class="headerlink" title="MATCH 选项"></a>MATCH 选项</h3><p>增量式迭代命令也可以通过提供一个 glob 风格的模式参数， 让命令只返回和给定模式相匹配的元素。需要注意的是， 对元素的模式匹配工作是在命令从数据集中取出元素之后， 向客户端返回元素之前的这段时间内进行的， 所以如果被迭代的数据集中只有少量元素和模式相匹配， 那么迭代命令或许会在多次执行中都不返回任何元素。</p>
<h3 id="redis-server支持多个迭代并发进行"><a href="#redis-server支持多个迭代并发进行" class="headerlink" title="redis server支持多个迭代并发进行"></a>redis server支持多个迭代并发进行</h3><p>在同一时间， 可以有任意多个客户端对同一数据集进行迭代， 客户端每次执行迭代都需要传入一个游标， 并在迭代执行之后获得一个新的游标， 而这个游标就包含了迭代的所有状态， 因此，redis服务器无须为迭代记录任何状态。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>同一个元素可能会被返回多次。 处理重复元素的工作交由应用程序负责， 比如说， 可以考虑将迭代返回的元素仅仅用于可以安全地重复执行多次的操作上。</p>
<p>如果一个元素是在迭代过程中被添加到数据集的， 又或者是在迭代过程中从数据集中被删除的， 那么这个元素可能会被返回， 也可能不会， 这是未定义的（undefined）。</p>
<p>遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="http://doc.redisfans.com/key/scan.html">http://doc.redisfans.com/key/scan.html</a></p>
<p><a target="_blank" rel="noopener" href="http://jinguoxing.github.io/redis/2018/09/04/redis-scan/">http://jinguoxing.github.io/redis/2018/09/04/redis-scan/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/10/08/golang/golang%20%E5%91%BD%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/08/golang/golang%20%E5%91%BD%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC/" class="post-title-link" itemprop="url">golang 命名返回值</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-08 16:14:42" itemprop="dateCreated datePublished" datetime="2019-10-08T16:14:42+08:00">2019-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-26 23:35:58" itemprop="dateModified" datetime="2023-02-26T23:35:58+08:00">2023-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="返回值是一种声明"><a href="#返回值是一种声明" class="headerlink" title="返回值是一种声明"></a>返回值是一种声明</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TestModel <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	golang 在返回值中声明返回对象需要注意的点，实际上和var声明是一样的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值声明就是相当于使用var申明了，这在map和指针的情况下回产生空指针异常。</span></span><br><span class="line"><span class="comment">// 请理解一下空指针取址能取到，这其实很简单。</span></span><br><span class="line"><span class="comment">// 指针对象指的是这个符号的内存存的是指针，空指针是说他的内存存的内存是nil。</span></span><br><span class="line"><span class="comment">// 而这个对象肯定是有一个内存地址来保存它的，想想吧，任意一个能看见的编码符号，都是有地址在存储的。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">()</span></span> (</span><br><span class="line">	model TestModel, modelPtr, testModel *TestModel, modelList []TestModel, modelPtrList []*TestModel,</span><br><span class="line">	modelListPtr *[]TestModel, mapData <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// 能取址说明是有地址的</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(&amp;model, model)</span><br><span class="line">	fmt.Println(&amp;modelPtr, modelPtr)</span><br><span class="line">	fmt.Println(&amp;modelList, modelList)</span><br><span class="line">	fmt.Println(&amp;modelPtrList, modelPtrList)</span><br><span class="line">	<span class="comment">// 空指针</span></span><br><span class="line">	fmt.Println(&amp;modelListPtr, modelListPtr)</span><br><span class="line">	fmt.Println(&amp;mapData, mapData)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// map 是空的如果要使用，需要先make: mapData = make(map[string]bool)注意不是 &quot;:=&quot;</span></span><br><span class="line">	<span class="comment">//list := []string&#123;&quot;abc&quot;, &quot;def&quot;&#125;</span></span><br><span class="line">	<span class="comment">//for _, data := range list &#123;</span></span><br><span class="line">	<span class="comment">//	mapData[data] = true</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 其实和上面一样</span></span><br><span class="line">	<span class="comment">//var modelListIn []TestModel</span></span><br><span class="line">	<span class="comment">//var modelPtrListIn []*TestModel</span></span><br><span class="line">	<span class="comment">//var modelListPtrIn *[]TestModel</span></span><br><span class="line">	<span class="comment">//fmt.Println(&amp;modelListIn)</span></span><br><span class="line">	<span class="comment">//fmt.Println(&amp;modelPtrListIn)</span></span><br><span class="line">	<span class="comment">//fmt.Println(modelListPtrIn)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// list 可以直接用</span></span><br><span class="line">	<span class="comment">//var list []string</span></span><br><span class="line">	<span class="comment">//list = append(list, &quot;abc&quot;)</span></span><br><span class="line">	<span class="comment">//fmt.Println(list)</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	test1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="返回值和defer使用"><a href="#返回值和defer使用" class="headerlink" title="返回值和defer使用"></a>返回值和defer使用</h2><p>defer定义的方法会在return后被执行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeferFunc1</span><span class="params">(i <span class="type">int</span>)</span></span> (t <span class="type">int</span>) &#123;</span><br><span class="line">	t = i</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		t += <span class="number">3</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeferFunc2</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	t := i</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		t += <span class="number">3</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeferFunc3</span><span class="params">(i <span class="type">int</span>)</span></span> (t <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		t += i</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Println(DeferFunc1(<span class="number">1</span>))</span><br><span class="line">	fmt.Println(DeferFunc2(<span class="number">1</span>))</span><br><span class="line">	fmt.Println(DeferFunc3(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	答案</span></span><br><span class="line"><span class="comment">	4</span></span><br><span class="line"><span class="comment">	1</span></span><br><span class="line"><span class="comment">	3</span></span><br><span class="line"><span class="comment">	分析</span></span><br><span class="line"><span class="comment">		1. 当函数有可命名结果形参时，结果形参的初始值被设置为零值，函数的return语句会设置结果形参的值</span></span><br><span class="line"><span class="comment">		2. 当函数有可命名结果形参时，defer函数是可以修改它，然后再将它的值返回</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DeferFunc1 :</span></span><br><span class="line"><span class="comment">	t:= 0</span></span><br><span class="line"><span class="comment">	t = 1</span></span><br><span class="line"><span class="comment">	t +=3 -&gt; t = 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DeferFunc3:</span></span><br><span class="line"><span class="comment">	t:=0</span></span><br><span class="line"><span class="comment">	t = 2</span></span><br><span class="line"><span class="comment">	t += 1 -&gt; t = 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/10/08/learn/docker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E9%87%8D%E5%90%AF-%E7%BD%91%E7%BB%9C%E6%9C%AA%E6%B8%85%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/08/learn/docker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E9%87%8D%E5%90%AF-%E7%BD%91%E7%BB%9C%E6%9C%AA%E6%B8%85%E7%90%86/" class="post-title-link" itemprop="url">docker容器无法重启-网络未清理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-08 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-08T00:00:00+08:00">2019-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-23 13:57:48" itemprop="dateModified" datetime="2021-06-23T13:57:48+08:00">2021-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">虚拟化</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="现场"><a href="#现场" class="headerlink" title="现场"></a>现场</h2><h3 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker container rm -f user_service</span><br><span class="line">docker run -d --restart=always\</span><br><span class="line">    --net=host\</span><br><span class="line">    --name user_service\</span><br><span class="line">    -v `pwd`/config/:/etc/config/\</span><br><span class="line">    -v /var/log/xiaoduo:/var/log/xiaoduo\</span><br><span class="line">        -v `pwd`:/app\</span><br><span class="line">        -w /app\</span><br><span class="line">    registry.cn-hangzhou.aliyuncs.com/xiaoduoai/centos7 /app/user_service -c /etc/config/user_service.toml</span><br></pre></td></tr></table></figure>

<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/docker-current: Error response from daemon: service endpoint with name user_service already exists</span><br></pre></td></tr></table></figure>

<p>首先明白报错信息的意思，具有名称用户服务的服务端点已经存在，指的是user_service这个入口名已经存在了。但是我的脚本明明是已经删除了user_service这个容器了的。而且这个脚本之前一直都是稳健运行的。</p>
<h2 id="问网友"><a href="#问网友" class="headerlink" title="问网友"></a>问网友</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/bf7ae7919473">https://www.jianshu.com/p/bf7ae7919473</a></p>
<p>网友大概就是知道怎么解决，但是为什么会产生这个原因，并不知道，而且解决得相对有点粗放。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>在我的启动脚本中增加清理容器网络占用的指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker network disconnect --force host user_service</span><br><span class="line"></span><br><span class="line">docker network inspect host | grep -A 5 -B 3 apigate</span><br><span class="line"></span><br><span class="line">host表示容器启动时指定的网络模式（有4中网络模式，Bridge， Host， Containe， None这里不展开了）</span><br></pre></td></tr></table></figure>

<p>修改后的完整指令如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker stop user_uservice</span><br><span class="line">docker container rm -f user_service</span><br><span class="line"></span><br><span class="line">docker network disconnect --force host user_service</span><br><span class="line"></span><br><span class="line">docker run -d --restart=always\</span><br><span class="line">    --net=host\</span><br><span class="line">    --name user_service\</span><br><span class="line">    -v `pwd`/config/:/etc/config/\</span><br><span class="line">    -v /var/log/xiaoduo:/var/log/xiaoduo\</span><br><span class="line">        -v `pwd`:/app\</span><br><span class="line">        -w /app\</span><br><span class="line">    registry.cn-hangzhou.aliyuncs.com/xiaoduoai/centos7 /app/user_service -c /etc/config/user_service.toml</span><br></pre></td></tr></table></figure>

<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><h3 id="涉及到指令"><a href="#涉及到指令" class="headerlink" title="涉及到指令"></a>涉及到指令</h3><ul>
<li>清理此容器的网络占用：docker network disconnect –force 网络模式 容器名称</li>
<li>检查是否还有同名容器占用： docker network inspect 网络模式 | grep 容器名称</li>
</ul>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>没有解决的问题：不知道是什么原因造成的，之前的指令在其他机器上都还是正常运行的。所以彻底解决得方案没有找到。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/09/19/database/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/19/database/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">为什么要使用联合索引</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-19 20:53:42" itemprop="dateCreated datePublished" datetime="2019-09-19T20:53:42+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-24 20:12:43" itemprop="dateModified" datetime="2021-06-24T20:12:43+08:00">2021-06-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="mysql中的一些查询规则"><a href="#mysql中的一些查询规则" class="headerlink" title="mysql中的一些查询规则"></a>mysql中的一些查询规则</h3><ol>
<li>在一次查询中，MySQL只能使用一个索引， or 语句会导致可能使用多个。</li>
<li>在真实项目中，SQL语句中的WHERE子句里通常会包含多个查询条件还会有排序、分组等。</li>
<li>若表中索引过多，会影响INSERT及UPDATE性能，简单说就是会影响数据写入性能。因为更新数据的同时，也要同时更新索引。</li>
</ol>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><h3 id="原因零：在and的查询语句中，一次查询只会走一个索引"><a href="#原因零：在and的查询语句中，一次查询只会走一个索引" class="headerlink" title="原因零：在and的查询语句中，一次查询只会走一个索引"></a>原因零：在and的查询语句中，一次查询只会走一个索引</h3><p>以mongo为例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 来看这样一条查询</span></span><br><span class="line">db.presale_day_platform_snick_goods_question.explain(&quot;executionStats&quot;).find(&#123;&quot;shop_id&quot;: &quot;59f452501a6b200895100003&quot;, date: &#123;&quot;$gte&quot;: 20191012, &quot;$lte&quot;: 20191019&#125;, &quot;question_id&quot;: ObjectId(&quot;59f452501a6b200895100060&quot;)&#125;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果分别对shop_id, <span class="built_in">date</span>, question_id 三个分别建立索引，在查询时只会走一个索引，我这里线上数据胜出的索引是（其他两个索引失效了）</span></span><br><span class="line">&quot;indexBounds&quot;: &#123;</span><br><span class="line">  &quot;question_id&quot;: [</span><br><span class="line">    &quot;[ObjectId(&#x27;59f452501a6b200895100060&#x27;), ObjectId(&#x27;59f452501a6b200895100060&#x27;)]&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果对shop_id, <span class="built_in">date</span>, question_id 三列建立联合索引，那么会走这个联合索引</span></span><br><span class="line">&quot;indexBounds&quot; : &#123;</span><br><span class="line">&quot;shop_id&quot;: [</span><br><span class="line">    &quot;[\&quot;59f452501a6b200895100003\&quot;, \&quot;59f452501a6b200895100003\&quot;]&quot;</span><br><span class="line">  ],</span><br><span class="line">&quot;date&quot;: [</span><br><span class="line">    &quot;[20191019.0, 20191012.0]&quot;</span><br><span class="line">  ],</span><br><span class="line">&quot;question_id&quot;: [</span><br><span class="line">    &quot;[ObjectId(&#x27;59f452501a6b200895100060&#x27;), ObjectId(&#x27;59f452501a6b200895100060&#x27;)]&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">来看这样一条带排序的查询</span></span><br><span class="line">db.mock.explain(&quot;executionStats&quot;).find(&#123;&quot;day&quot;: &quot;2019-10-19&quot;, &quot;shop_id&quot;: ObjectId(&quot;59f452501a6b200895100091&quot;)&#125;).sort(&#123;&quot;num&quot;: -1&#125;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果有这样的联合索引，那么会走这个联合索引！</span></span><br><span class="line">db.mock.createIndex(&#123;shop_id:1, day:-1, num: -1&#125;, &#123;background: true&#125;)</span><br><span class="line"></span><br><span class="line">&quot;indexBounds&quot; : &#123;</span><br><span class="line">        &quot;shop_id&quot; : [</span><br><span class="line">                &quot;[ObjectId(&#x27;59f452501a6b200895100091&#x27;), ObjectId(&#x27;59f452501a6b200895100091&#x27;)]&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;day&quot; : [</span><br><span class="line">                &quot;[\&quot;2019-10-19\&quot;, \&quot;2019-10-19\&quot;]&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;num&quot; : [</span><br><span class="line">                &quot;[MaxKey, MinKey]&quot;</span><br><span class="line">        ]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意在多个键上排序时（来自mongo文档）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 您可以指定在索引的所有键或者部分键上排序。但是，排序键的顺序必须和它们在索引中的排列顺序 一致 。例如，索引 &#123; a: 1, b: 1 &#125; 可以支持排序 &#123; a: 1, b: 1 &#125; 但不支持 &#123; b: 1, a: 1 &#125; 排序。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 此外，<span class="built_in">sort</span>中指定的所有键的排序顺序(例如递增/递减）必须和索引中的对应键的排序顺序 完全相同, 或者 完全相反 。例如，索引 &#123; a: 1, b: 1 &#125; 可以支持排序 &#123; a: 1, b: 1 &#125; 和排序 &#123; a: -1, b: -1 &#125; ，但 不支持 排序 &#123; a: -1, b: 1 &#125; 。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">现在有两个索引</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">db.mock.createIndex(&#123;shop_id:1, <span class="built_in">date</span>:-1, num: -1, category: -1&#125;, &#123;background: <span class="literal">true</span>&#125;)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">db.mock.createIndex(&#123;shop_id:1, <span class="built_in">date</span>:-1, num: -1&#125;, &#123;background: <span class="literal">true</span>&#125;)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个会使用第一个索引</span></span><br><span class="line">db.mock.explain(&quot;executionStats&quot;).find(&#123;&quot;shop_id&quot;: ObjectId(&quot;59f452501a6b200895100008&quot;), &quot;date&quot;: 20191022&#125;).sort(&#123;&quot;num&quot;: 1, &quot;category&quot;: 1&#125;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个会使用第二个索引</span></span><br><span class="line">db.mock.explain(&quot;executionStats&quot;).find(&#123;&quot;shop_id&quot;: ObjectId(&quot;59f452501a6b200895100008&quot;), &quot;date&quot;: 20191022&#125;).sort(&#123;&quot;num&quot;: 1, &quot;category&quot;: -1&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="原因一：一个顶三个"><a href="#原因一：一个顶三个" class="headerlink" title="原因一：一个顶三个"></a>原因一：一个顶三个</h3><p>建了一个(a,b,c)的复合索引，那么实际等于建了(a),(a,b),(a,b,c)三个索引，因为每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，这可是不小的开销！</p>
<h3 id="原因二：单次筛选"><a href="#原因二：单次筛选" class="headerlink" title="原因二：单次筛选"></a>原因二：单次筛选</h3><p>索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select * from table where a &#x3D; 1 and b &#x3D;2 and c &#x3D; 3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W*10%&#x3D;100w 条数据，然后再回表从100w条数据中找到符合b&#x3D;2 and c&#x3D; 3的数据，然后再排序，再分页；如果是复合索引，通过索引筛选出1000w *10% *10% *10%&#x3D;1w，然后再排序、分页，哪个更高效，一眼便知。</p>
<h3 id="原因三：覆盖索引"><a href="#原因三：覆盖索引" class="headerlink" title="原因三：覆盖索引"></a>原因三：覆盖索引</h3><p>覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。</p>
<p>当一条查询语句符合覆盖索引条件时，sql只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I&#x2F;O。提高效率。因为这里如果不是覆盖索引的话，还需要其他字段，那么就会拿着索引对应的id，去数据表里走随机I&#x2F;O（类似于数组中查询其中list[i]），但是即使不用遍历，相对而言，随机I&#x2F;O依然是一个相对费时的操作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当索引字段超过三个时，一定要考虑联合索引的可行性</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000000342176">https://segmentfault.com/q/1010000000342176</a></p>
<p><a target="_blank" rel="noopener" href="http://hedengcheng.com/?p=577">http://hedengcheng.com/?p=577</a></p>
<p><a target="_blank" rel="noopener" href="http://www.mongoing.com/docs/tutorial/sort-results-with-indexes.html">http://www.mongoing.com/docs/tutorial/sort-results-with-indexes.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/09/16/learn/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/16/learn/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E8%AE%B0/" class="post-title-link" itemprop="url">微信开发采坑记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-16 21:33:42" itemprop="dateCreated datePublished" datetime="2019-09-16T21:33:42+08:00">2019-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="踩坑点"><a href="#踩坑点" class="headerlink" title="踩坑点"></a>踩坑点</h2><h3 id="消息不可达服务"><a href="#消息不可达服务" class="headerlink" title="消息不可达服务"></a>消息不可达服务</h3><ul>
<li>问题<ul>
<li>用户A先关注了微信订阅号，然后订阅号启动了服务，让后用户A发送消息，服务接受不到用户的A的消息。</li>
</ul>
</li>
<li>解决<ul>
<li>取消关注，并重新关注</li>
</ul>
</li>
</ul>
<h3 id="python3下文档中代码不可用"><a href="#python3下文档中代码不可用" class="headerlink" title="python3下文档中代码不可用"></a>python3下文档中代码不可用</h3><ul>
<li>问题<ul>
<li>使用python官方demo，在python3下使用sha1对相关数据进行文摘，文摘和signature不一致</li>
</ul>
</li>
<li>解决<ul>
<li>不要使用map()函数，使用正常的迭代，不要用自己不懂的代码</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/09/09/learn/git%E4%B8%8D%E5%90%8C%E9%98%B6%E6%AE%B5%E6%92%A4%E5%9B%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/09/learn/git%E4%B8%8D%E5%90%8C%E9%98%B6%E6%AE%B5%E6%92%A4%E5%9B%9E/" class="post-title-link" itemprop="url">git不同阶段撤回</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-09 20:40:33" itemprop="dateCreated datePublished" datetime="2019-09-09T20:40:33+08:00">2019-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-07 11:53:07" itemprop="dateModified" datetime="2022-09-07T11:53:07+08:00">2022-09-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>通过这篇文章，你会知道：</p>
<ul>
<li><p>git有四个区：工作区，暂存区，本地仓库，远程仓库</p>
</li>
<li><p>文件有5个状态：origin， modified，staged，committed，pushed</p>
</li>
<li><p>如何撤销工作区的修改，如何撤销暂存区的修改，如何撤销本地的提交，如何撤销远程仓库的修改</p>
</li>
</ul>
<p>[TOC]</p>
<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>大家都知道 Git 是一个分布式版本控制，所以 Git 会有一个本地库，和一个远端库，而平时提交代码的时候，一般也都是先从本地工作区提交代码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;commit&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>这几个步骤，虽然平淡无奇，但是展开说，就体现了 Git 的重要的环节，一段代码的提交顺序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">工作区  -&gt;  git add .  -&gt; 暂存区 -&gt; git commit -&gt; 本地仓库（实际这是一个在暂存区的提交） -&gt; git push -&gt; 远程仓库</span><br></pre></td></tr></table></figure>

<p>这里就要提到 Git 中的四个区：</p>
<ul>
<li>工作区 working</li>
<li>暂存区 stage</li>
<li>本地仓库 local repository</li>
<li>远程仓库 remote repository</li>
</ul>
<p>被追踪的文件，在未进入和进入上述四个区之后分别有一个状态，所以一共有五个状态：</p>
<ul>
<li>未修改 origin</li>
<li>已修改 modified</li>
<li>已暂存 staged</li>
<li>已提交 committed</li>
<li>已推送 pushed</li>
</ul>
<p>在了解这几个基本概念之后，如何检查本地的修改，以及如何查看不同状态之间的修改，这就要用到 <code>git diff</code> 命令。</p>
<ul>
<li>git diff：查看已修改，未暂存的内容</li>
<li>git diff –cached：查看已暂存，未提交的内容</li>
<li>git diff origin&#x2F;dev dev： 查看已提交，未推送的差异。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">工作区          暂存区           本地仓库                    远程仓库</span><br><span class="line">    \          /     \          /         \                  /</span><br><span class="line">     \        /       \        /           \                /</span><br><span class="line">     git diff         git diff --cached     git diff origin/dev dev</span><br></pre></td></tr></table></figure>

<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><h3 id="撤销工作区修改"><a href="#撤销工作区修改" class="headerlink" title="撤销工作区修改"></a>撤销工作区修改</h3><p>如果只是在编辑器中修改了文件的内容，还未使用 <code>git add</code> 将修改提交到暂存区，那么可以使用 <code>git checkout .</code> 或者 <code>git checkout -- &lt;file&gt;</code> 来丢弃本地全部修改或者丢弃某文件的修改。</p>
<p>可以将 <code>git add .</code> 和 <code>git checkout .</code> 看做一对反义词，修改完成后，如果想 Git 往前进一步，让修改进入暂存区，执行 <code>git add .</code> 如果向后退则执行 <code>git checkout .</code></p>
<h3 id="撤销暂存区修改"><a href="#撤销暂存区修改" class="headerlink" title="撤销暂存区修改"></a>撤销暂存区修改</h3><p>如果已经执行了 <code>git add</code>，意味着暂存区中已经有了修改，但是需要丢弃暂存区的修改，那么可以执行 <code>git reset</code></p>
<p>对于已经被 Git 追踪的文件，可以使用以下命令来单独将文件从暂存区中丢弃，将修改放到工作区</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;file&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">等价于</span></span><br><span class="line">git reset --soft &lt;file&gt;</span><br></pre></td></tr></table></figure>

<p>对于从来没有被 Git 追踪过，是 new file 的文件，则需要使用命令来将新文件从暂存区中取出放到工作区。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure>

<p>如果确定暂存区中的修改完全不需要，则可以使用以下命令直接将修改抛弃，<strong>谨慎使用 –hard 命令</strong>， 暂存区中所有修改都会被丢弃。修改内容也不会被重新放到工作区。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard</span><br></pre></td></tr></table></figure>

<h3 id="撤销本地提交"><a href="#撤销本地提交" class="headerlink" title="撤销本地提交"></a>撤销本地提交</h3><p>对于已经本地的提交，也就是使用 git add 并且执行了 git commit 的修改，这时候本地的修改已经进入了本地仓库，而这是需要撤销这一次提交，或者本地的多次提交，怎么办？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure>

<p>同样还是 <code>git reset</code> 命令，但是多了 <code>origin/master</code> ，<code>origin</code> 表示远端仓库的名字，默认为 origin，可能也有其他自己的名字，<code>origin/master</code> 表示远程仓库，既然本地的修改已经不再需要，那么从远端将代码拉回来就行。</p>
<p>不过不建议直接使用 <code>git reset --hard origin/master</code> 这样太强的命令，如果想要撤销本地最近的一次提交，可以使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD~1</span><br></pre></td></tr></table></figure>

<p>这行命令表示，将最近一次提交 <code>HEAD~1</code> 从本地仓库回退到暂存区，<code>--soft</code> 不会丢弃修改，而是将修改放到暂存区，后续继续修改，或者丢弃暂存区的修改就可以随意了。如果要撤销本地两次修改，则改成 <code>HEAD~2</code> 即可，其他同类。</p>
<p>不过要注意的是，已经提交到远端的提交，不要使用 <code>git reset</code> 来修改，对于多人协作项目会给其他人带来很多不必要的麻烦。</p>
<h3 id="撤销远程提交"><a href="#撤销远程提交" class="headerlink" title="撤销远程提交"></a>撤销远程提交</h3><p>对于已经推送的修改，原则上是不要撤销的，不过 Git 给了使用者充分的自由，在明确自己在做什么的情况下，可以使用 <code>git push -f</code> 使用 force 选项来将本地库 force 覆盖远端仓库，强制 push 到远端。</p>
<p>对于个人，一个人使用的项目使用这样的方式，并没有太大问题，但是如果对于多人项目，如果你强行改变了远端仓库，别人再使用的时候就会出现很多问题，所以使用 <code>git push -f</code> 时一定要想清楚自己在做什么事情。</p>
<p><strong>不要再公共分支上 git push -f</strong></p>
<h2 id="怎么实现"><a href="#怎么实现" class="headerlink" title="怎么实现"></a>怎么实现</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这篇文章，你会知道。</p>
<ul>
<li><p>git有四个区：工作区，暂存区，本地仓库，远程仓库</p>
</li>
<li><p>文件有5个状态：origin， modified，staged，committed，pushed</p>
</li>
<li><p>如何撤销工作区的修改，如何撤销暂存区的修改，如何撤销本地的提交，如何撤销远程仓库的修改</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>原文链接：<a target="_blank" rel="noopener" href="http://einverne.github.io/post/2017/12/git-reset.html">http://einverne.github.io/post/2017/12/git-reset.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/08/30/concurrent%20and%20gc/golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/30/concurrent%20and%20gc/golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" class="post-title-link" itemprop="url">【gc】golang垃圾回收</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-30 17:43:42" itemprop="dateCreated datePublished" datetime="2019-08-30T17:43:42+08:00">2019-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<p>这里垃圾回收是指语言层面的对堆上的不再使用的对象，释放他们占用的空间。语言层面上的垃圾回收是一种自动内存管理（automatic memory management that consists of determining which objects should be deallocated (“garbage collected”)）</p>
<p>通过这篇文章，你会知道：</p>
<ul>
<li>golang不同版本的几个垃圾收集的方式</li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>自动内存管理的另一个重要的组成部分便是自动回收。在自动内存回收中， 垃圾回收器扮演一个十分重要的角色。通常， 垃圾回收器的执行过程可根据代码的行为被划分为两个半独立的组件： 赋值器（Mutator）和回收器（Collector）。</p>
<h2 id="三色标记详解（Tri-color-marking）"><a href="#三色标记详解（Tri-color-marking）" class="headerlink" title="三色标记详解（Tri-color marking）"></a>三色标记详解（Tri-color marking）</h2><p>有三种集合：白色，黑色，灰色</p>
<ul>
<li>白色集合，或者叫危险集合，是垃圾回收的候选对象的集合</li>
<li>黑色集合，黑色集合是根集合可达的集合，且没有白色集合中对象的传出引用，不参与垃圾回收</li>
<li>灰色集包含从根可到达的所有对象，但尚未扫描以查找对“白色”对象的引用。 由于已知它们可以从根部到达，因此它们不能被垃圾收集，并且在扫描后将最终成为黑色集合。</li>
</ul>
<h3 id="清理过程"><a href="#清理过程" class="headerlink" title="清理过程"></a>清理过程</h3><p>在垃圾收集器开始工作时，程序中不存在任何的黑色对象，垃圾收集的根对象会被标记成灰色，垃圾收集器只会从灰色对象集合中取出对象开始扫描，当灰色集合中不存在任何对象时，标记阶段就会结束。</p>
<p><strong>三色标记垃圾收集器的工作原理很简单，我们可以将其归纳成以下几个步骤：</strong></p>
<ol>
<li>从灰色对象的集合中选择一个灰色对象并将其标记成黑色；</li>
<li>将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；</li>
<li>重复上述两个步骤直到对象图中不存在灰色对象；</li>
</ol>
<p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/d3fab54fd63a47a0a6e2fe0a57200c52.png"></p>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>因为用户程序可能在标记执行的过程中修改对象的指针，所以三色标记清除算法本身是不可以并发或者增量执行的，它仍然需要 STW，在如下所示的三色标记过程中，用户程序建立了从 A 对象到 D 对象的引用，但是因为程序中已经不存在灰色对象了，所以 D 对象会被垃圾收集器错误地回收。</p>
<p><img src="https://s1.ax1x.com/2020/07/24/UvJWNR.png"></p>
<h3 id="屏障技术"><a href="#屏障技术" class="headerlink" title="屏障技术"></a>屏障技术</h3><p>想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的任意一种：</p>
<ul>
<li>强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；</li>
<li>弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径</li>
</ul>
<p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/1de88ce079714e568d5a2786edf759e0.png"></p>
<p>遵循上述两个不变性中的任意一个，我们都能保证垃圾收集算法的正确性，而屏障技术就是在并发或者增量标记过程中保证三色不变性的重要技术。</p>
<p>垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用写屏障保证三色不变性。</p>
<p>我们在这里想要介绍的是 Go 语言中使用的两种写屏障技术，分别是 Dijkstra 提出的插入写屏障和 Yuasa 提出的删除写屏障，这里会分析它们如何保证三色不变性和垃圾收集器的正确性。</p>
<h4 id="插入写屏障"><a href="#插入写屏障" class="headerlink" title="插入写屏障"></a>插入写屏障</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">writePointer(slot, ptr):</span><br><span class="line">    shade(ptr)</span><br><span class="line">    *slot = ptr</span><br></pre></td></tr></table></figure>

<p>上述插入写屏障的伪代码非常好理解，每当我们执行类似 <code>*slot = ptr</code> 的表达式时，我们会执行上述写屏障通过 <code>shade</code> 函数尝试改变指针的颜色。如果 <code>ptr</code> 指针是白色的，那么该函数会将该对象设置成灰色，其他情况则保持不变。</p>
<p>假设我们在应用程序中使用 Dijkstra 提出的插入写屏障，在一个垃圾收集器和用户程序交替运行的场景中会出现如上图所示的标记过程：</p>
<ol>
<li>垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色；</li>
<li>用户程序修改 A 对象的指针，将原本指向 B 对象的指针指向 C 对象，这时触发写屏障将 C 对象标记成灰色；</li>
<li>垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色；</li>
</ol>
<p>Dijkstra 的插入写屏障是一种相对保守的屏障技术，它会将<strong>有存活可能的对象都标记成灰色</strong>以满足强三色不变性。在如上所示的垃圾收集过程中，实际上不再存活的 B 对象最后没有被回收；而如果我们在第二和第三步之间将指向 C 对象的指针改回指向 B，垃圾收集器仍然认为 C 对象是存活的，这些被错误标记的垃圾对象只有在下一个循环才会被回收。</p>
<p>插入式的 Dijkstra 写屏障虽然实现非常简单并且也能保证强三色不变性，但是它也有很明显的缺点。因为栈上的对象在垃圾收集中也会被认为是根对象，所以为了保证内存的安全，Dijkstra 必须为栈上的对象增加写屏障或者在标记阶段完成重新对栈上的对象进行扫描，这两种方法各有各的缺点，前者会大幅度增加写入指针的额外开销，后者重新扫描栈对象时需要暂停程序，垃圾收集算法的设计者需要在这两者之前做出权衡。</p>
<h4 id="删除写屏障"><a href="#删除写屏障" class="headerlink" title="删除写屏障"></a>删除写屏障</h4><p>Yuasa 在 1990 年的论文 Real-time garbage collection on general-purpose machines 中提出了删除写屏障，因为一旦该写屏障开始工作，它就会保证开启写屏障时堆上所有对象的可达，所以也被称作快照垃圾收集（Snapshot GC）</p>
<p>该算法会使用如下所示的写屏障保证增量或者并发执行垃圾收集时程序的正确性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">writePointer(slot, ptr)</span><br><span class="line">    shade(*slot)</span><br><span class="line">    *slot = ptr</span><br></pre></td></tr></table></figure>

<p>上述代码会在老对象的引用被删除时，将白色的老对象涂成灰色，这样删除写屏障就可以保证弱三色不变性，老对象引用的下游对象一定可以被灰色对象引用。</p>
<p>假设我们在应用程序中使用 Yuasa 提出的删除写屏障，在一个垃圾收集器和用户程序交替运行的场景中会出现如上图所示的标记过程：</p>
<ol>
<li>垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色；</li>
<li>用户程序将 A 对象原本指向 B 的指针指向 C，触发删除写屏障，但是因为 B 对象已经是灰色的，所以不做改变；</li>
<li><strong>用户程序将 B 对象原本指向 C 的指针删除，触发删除写屏障，白色的 C 对象被涂成灰色</strong>；</li>
<li>垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色；</li>
</ol>
<h5 id="增量和并发"><a href="#增量和并发" class="headerlink" title="增量和并发"></a>增量和并发</h5><p>远古时代的计算资源还没有今天这么丰富，今天的计算机往往都是多核的处理器，垃圾收集器一旦开始执行就会浪费大量的计算资源，为了减少应用程序暂停的最长时间和垃圾收集的总暂停时间，我们会使用下面的策略优化现代的垃圾收集器：</p>
<ul>
<li>增量垃圾收集 — 增量地标记和清除垃圾，降低应用程序暂停的最长时间；</li>
<li>并发垃圾收集 — 利用多核的计算资源，在用户程序执行时并发标记和清除垃圾；</li>
</ul>
<p>因为增量和并发两种方式都可以与用户程序交替运行，所以我们需要<strong>使用屏障技术</strong>保证垃圾收集的正确性；与此同时，应用程序也不能等到内存溢出时触发垃圾收集，因为当内存不足时，应用程序已经无法分配内存，这与直接暂停程序没有什么区别，增量和并发的垃圾收集需要提前触发并在内存不足前完成整个循环，避免程序的长时间暂停。</p>
<h4 id="增量收集器"><a href="#增量收集器" class="headerlink" title="增量收集器"></a>增量收集器</h4><p>增量式（Incremental）的垃圾收集是减少程序最长暂停时间的一种方案，它可以将原本时间较长的暂停时间切分成多个更小的 GC 时间片，虽然从垃圾收集开始到结束的时间更长了，但是这也减少了应用程序暂停的最大时间：</p>
<p>需要注意的是，增量式的垃圾收集需要与三色标记法一起使用，为了保证垃圾收集的正确性，我们需要在垃圾收集开始前打开写屏障，这样用户程序对内存的修改都会先经过写屏障的处理，保证了堆内存中对象关系的强三色不变性或者弱三色不变性。虽然增量式的垃圾收集能够减少最大的程序暂停时间，但是增量式收集也会增加一次 GC 循环的总时间，在垃圾收集期间，因为写屏障的影响用户程序也需要承担额外的计算开销，所以增量式的垃圾收集也不是只有优点的。</p>
<h4 id="并发收集器"><a href="#并发收集器" class="headerlink" title="并发收集器"></a>并发收集器</h4><p>并发（Concurrent）的垃圾收集不仅能够减少程序的最长暂停时间，还能减少整个垃圾收集阶段的时间，通过开启读写屏障、<strong>利用多核优势与用户程序并行执行</strong>，并发垃圾收集器确实能够减少垃圾收集对应用程序的影响：</p>
<h3 id="golang的垃圾回收器演进过程"><a href="#golang的垃圾回收器演进过程" class="headerlink" title="golang的垃圾回收器演进过程"></a>golang的垃圾回收器演进过程</h3><p>Go 语言的垃圾收集器从诞生的第一天起就一直在演进，除了少数几个版本没有大更新之外，几乎每次发布的小版本都会提升垃圾收集的性能，而与性能一同提升的还有垃圾收集器代码的复杂度，本节将从 Go 语言 v1.0 版本开始分析垃圾收集器的演进过程。</p>
<h3 id="Go-语言的并发收集"><a href="#Go-语言的并发收集" class="headerlink" title="Go 语言的并发收集"></a>Go 语言的并发收集</h3><p>Go 语言的并发垃圾收集器会在扫描对象之前暂停程序做一些标记对象的准备工作，其中包括启动后台标记的垃圾收集器以及开启写屏障，如果在后台执行的垃圾收集器不够快，应用程序申请内存的速度超过预期，运行时就会让申请内存的应用程序辅助完成垃圾收集的扫描阶段，在标记和标记终止阶段结束之后就会进入异步的清理阶段，将不用的内存增量回收。</p>
<p>v1.5 版本实现的并发垃圾收集策略由专门的 Goroutine 负责在处理器之间同步和协调垃圾收集的状态。当其他的 Goroutine 发现需要触发垃圾收集时，它们需要将该信息通知给负责修改状态的主 Goroutine，然而这个通知的过程会带来一定的延迟，这个延迟的时间窗口很可能是不可控的，用户程序会在这段时间分配界面很多内存空间。</p>
<p>v1.6 引入了去中心化的垃圾收集协调机制，将垃圾收集器变成一个显式的状态机，任意的 Goroutine 都可以调用方法触发状态的迁移，常见的状态迁移方法包括以下几个</p>
<h4 id="STW-垃圾收集器的垃圾收集时间"><a href="#STW-垃圾收集器的垃圾收集时间" class="headerlink" title="STW 垃圾收集器的垃圾收集时间"></a>STW 垃圾收集器的垃圾收集时间</h4><p>因为并发垃圾收集器会与程序一起运行，所以它无法准确的控制堆内存的大小，并发收集器需要在达到目标前触发垃圾收集，这样才能够保证内存大小的可控，并发收集器需要尽可能保证垃圾收集结束时的堆内存与用户配置的 GOGC 一致。</p>
<p><img src="https://img.draveness.me/2020-03-16-15843705141890-concurrent-garbage-collector-heap.png"></p>
<h3 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="混合写屏障"></a>混合写屏障</h3><p>在 Go 语言 v1.7 版本之前，运行时会使用 Dijkstra 插入写屏障保证强三色不变性，但是运行时并没有在所有的垃圾收集根对象上开启插入写屏障。因为 Go 语言的应用程序可能包含成百上千的 Goroutine，而垃圾收集的根对象一般包括全局变量和栈对象，如果运行时需要在几百个 Goroutine 的栈上都开启写屏障，会带来巨大的额外开销，所以 Go 团队在实现上选择了在标记阶段完成时<strong>暂停程序、将所有栈对象标记为灰色并重新扫描</strong>，在活跃 Goroutine 非常多的程序中，重新扫描的过程需要占用 10 ~ 100ms 的时间。</p>
<p>Go 语言在 v1.8 组合 Dijkstra 插入写屏障和 Yuasa 删除写屏障构成了如下所示的混合写屏障，该写屏障会<strong>将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">writePointer(slot, ptr):</span><br><span class="line">    shade(*slot)</span><br><span class="line">    <span class="keyword">if</span> current <span class="built_in">stack</span> is grey:</span><br><span class="line">        shade(ptr)</span><br><span class="line">    *slot = ptr</span><br></pre></td></tr></table></figure>

<p>为了移除栈的重扫描过程，除了引入混合写屏障之外，在垃圾收集的标记阶段，我们还需要<strong>将创建的所有新对象都标记成黑色</strong>，防止新分配的栈内存和堆内存中的对象被错误地回收，因为栈内存在标记阶段最终都会变为黑色，所以不再需要重新扫描栈空间。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>在介绍垃圾收集器的演进过程之前，我们需要对最新垃圾收集器的执行周期有一些初步的了解，这对我们了解其全局的设计会有比较大的帮助。Go 语言的垃圾收集可以分成清除终止、标记、标记终止和清除四个不同阶段，它们分别完成了不同的工作</p>
<p><img src="https://img.draveness.me/2020-03-16-15843705141897-garbage-collector-phaes.png"></p>
<h4 id="垃圾收集的多个阶段"><a href="#垃圾收集的多个阶段" class="headerlink" title="垃圾收集的多个阶段"></a>垃圾收集的多个阶段</h4><ol>
<li>清理终止阶段；<ol>
<li><strong>暂停程序</strong>，所有的处理器在这时会进入安全点（Safe point）；</li>
<li>如果当前垃圾收集循环是强制触发的，我们还需要处理还未被清理的内存管理单元；</li>
</ol>
</li>
<li>标记阶段；<ol>
<li>将状态切换至 <code>_GCmark</code>、开启写屏障、用户程序协助（Mutator Assiste）并将根对象入队；</li>
<li>恢复执行程序，标记进程和用于协助的用户程序会开始并发标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色；</li>
<li>开始扫描根对象，包括所有 Goroutine 的栈、全局对象以及不在堆中的运行时数据结构，扫描 Goroutine 栈期间会暂停当前处理器；</li>
<li>依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；</li>
<li>使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段；</li>
</ol>
</li>
<li>标记终止阶段；<ol>
<li><strong>暂停程序</strong>、将状态切换至 <code>_GCmarktermination</code> 并关闭辅助标记的用户程序；</li>
<li>清理处理器上的线程缓存；</li>
</ol>
</li>
<li>清理阶段；<ol>
<li>将状态切换至 <code>_GCoff</code> 开始清理阶段，初始化清理状态并关闭写屏障；</li>
<li>恢复用户程序，所有新创建的对象会标记成白色；</li>
<li>后台并发清理所有的内存管理单元，当 Goroutine 申请新的内存管理单元时就会触发清理；</li>
</ol>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 实际上，gc低延迟是有代价的，其中最大的是吞吐量的下降。由于需要实现并行处理，线程间同步和多余的数据生成复制都会占用实际逻辑业务代码运行的时间。这就导致业务代码执行时间减少，吞吐量下降。并行GC的第二个代价是不可预测的堆空间扩大。程序在GC的运行期间仍能不断分配任意大小的堆空间，因此我们需要在到达最大的堆空间之前实行一次GC（不然就堆溢出了），但是过早实行GC会造成不必要的GC扫描，这也是需要衡量利弊的。</p>
<p><strong>golang的垃圾收集简单概括可以是，STW 扫描一次协程栈 + 混合写屏障 （创建对象默认黑色） + 三色标记。这里创建对象是指所有的，包括堆上和栈上的。</strong></p>
<p>垃圾收集是一门非常古老的技术，它的执行速度和利用率很大程度上决定了程序的运行速度，Go 语言为了实现高性能的并发垃圾收集器，使用<strong>三色抽象、并发增量回收、混合写屏障、调步算法以及用户程序协助等机制</strong>将垃圾收集的暂停时间优化至毫秒级以下，从早期的版本看到今天，我们能体会到其中的工程设计和演进，作者觉得分析垃圾收集的是实现还是非常有趣和值得的。</p>
<p>垃圾收集是一个难题，没有所谓十全十美的方案，通常是为了适应应用场景做出的一种取舍。</p>
<p>通过这篇文章，你会知道：</p>
<ul>
<li>垃圾回收的常见的几种方式：引用计数，标记清理，复制收集，分代收集</li>
<li>golang不同版本的几个垃圾收集的方式</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/">主要的参考：大佬详解垃圾收集器</a></p>
<p><a target="_blank" rel="noopener" href="http://idiotsky.top/2017/08/16/gc-three-color/">一张图了解三色标记</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking">维基百科-</a></p>
<p><a target="_blank" rel="noopener" href="http://legendtkl.com/2017/04/28/golang-gc/#more">Golang 垃圾回收剖析</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018161588">https://segmentfault.com/a/1190000018161588</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/08/30/translation/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91%E7%90%86%E8%A7%A3pulsar%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/30/translation/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91%E7%90%86%E8%A7%A3pulsar%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/" class="post-title-link" itemprop="url">【翻译】理解pulsar如何工作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-30 17:43:42" itemprop="dateCreated datePublished" datetime="2019-08-30T17:43:42+08:00">2019-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<p>译者注：</p>
<p>翻译：pulsar broker：pulsar经纪人（代理）。Ledger：分类账。fragment：片段。cursor：游标。Entity：条目。split-brain：裂脑（不是很好的翻译）。chaos testing：混乱测试</p>
<p>原文：<a target="_blank" rel="noopener" href="https://jack-vanlightly.com/blog/2018/10/2/understanding-how-apache-pulsar-works">https://jack-vanlightly.com/blog/2018/10/2/understanding-how-apache-pulsar-works</a></p>
<h2 id="消息系统"><a href="#消息系统" class="headerlink" title="消息系统"></a>消息系统</h2><p>我将撰写一系列关于Apache Pulsar的博客文章，包括一些Kafka vs Pulsar的帖子。 首先，我将在Pulsar集群上运行一些极端情况测试（原文为：chaos tests，译者注），就像我使用RabbitMQ和Kafka一样，看看它有什么故障模式及其消息丢失情况。</p>
<p>我将尝试通过利用管理员或开发人员的设计缺陷，实现错误或不良配置来做到这一点。</p>
<p>在这篇文章中，我们将介绍Apache Pulsar设计，以便我们可以更好地设计故障情况。 这篇文章不适合那些想要了解如何使用Apache Pulsar，相反，这篇文章适合想要了解它如何工作的人。 我一直在努力以简单易懂的方式对其架构进行清晰的概述。 我很感激有关此文章的任何反馈。</p>
<h2 id="申明"><a href="#申明" class="headerlink" title="申明"></a>申明</h2><p>我感兴趣的主要声明（指Apache Pulsar的申明，译者注）是：</p>
<ul>
<li>保证没有消息丢失（如果应用推荐的配置，并且您的整个数据中心没有出故障）</li>
<li>强大的实时订阅保证</li>
<li>可预测的读写延时</li>
</ul>
<p>Apache Pulsar选择一致性而不是可用性，就像它的姐妹项目BookKeeper和ZooKeeper一样。 我们尽一切努力保持一致性。</p>
<p>我们将看看Pulsar的设计，看看这些说法是否有效。 在下一篇文章中，我们将对该设计的实现进行测试。 我不会在这篇文章中讨论地理复制，我们将在以后看一下，现在，我们只关注一个集群。</p>
<h2 id="多层抽象"><a href="#多层抽象" class="headerlink" title="多层抽象"></a>多层抽象</h2><p>Apache Pulsar具有主题和订阅的高级概念，其最低级别的数据存储在二进制文件中，这些文件交叉分布在多个服务器上的多个主题的数据。 在它们之间是无数的细节和活动部分。 我个人觉得如果把它分成不同的抽象层，就更容易理解Pulsar架构，所以这就是我在这篇文章中要做的。</p>
<p>让我们先看一下分层：</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/56894e581c1210fead06f878/1538489997612-OYXFLJVUBYP4TOQDPHW9/ke17ZwdGBToddI8pDm48kBPBTeNcxcfAWtNCaUBD_ARZw-zPPgdn4jUwVcJE1ZvWQUxwkmyExglNqGp0IvTJZUJFbgE-7XRK3dMEBRBhUpyljvS97cYyH0zedltf2oBd_u8JnbgcCswL75I3h5uF8XFnsN0KVckq8AMHMQSUl2Q/LayersOfAbstraction.png"></p>
<h3 id="第一层-主题，订阅和游标"><a href="#第一层-主题，订阅和游标" class="headerlink" title="第一层-主题，订阅和游标"></a>第一层-主题，订阅和游标</h3><p>这不是关于可以使用Apache Pulsar构建的消息传递体系结构的帖子。 我们将简要介绍主题，订阅和游标的基础知识，但不是关于Pulsar支持的更广泛的消息传递模式的深度。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/56894e581c1210fead06f878/1538490975658-WSDKSTF2F07QFPMCPJ5H/ke17ZwdGBToddI8pDm48kJV1jAkwtpW9vkLNCzSf2apZw-zPPgdn4jUwVcJE1ZvWQUxwkmyExglNqGp0IvTJZUJFbgE-7XRK3dMEBRBhUpytRA8_xlmUAUvzOGbUpaLvE7_WuxAn6m-fbd5YwLMJktLDmY5AqKXXDP2XJA3wYEg/TopicsSubscriptions.png"></p>
<p>消息存储在主题中。 逻辑上，一个主题是一个日志结构，每个消息都在一个偏移量。 Apache Pulsar使用术语Cursor来描述偏移的跟踪。 生产者将他们的消息发送到给定的主题，Pulsar保证一旦消息被确认，它就不会丢失（除非一些超级糟糕的灾难或糟糕的配置）。</p>
<p>消费者通过订阅来消费主题的消息。 订阅是跟踪游标（当前消费者偏移）的逻辑实体，并且还根据订阅类型提供一些额外保证：</p>
<ul>
<li>独占订阅 - 一次只有一个消费者可以通过订阅阅读该主题。</li>
<li>共享订阅 - 竞争消费者可以同时通过同一订阅阅读主题。</li>
<li>故障转移订阅 - 消费者的活动&#x2F;备份模式。 如果活跃消费者死亡，则备份接管。 但是，同时从来没有两个活跃的消费者。</li>
</ul>
<p>一个主题可以有多个附加订阅。 订阅不包含数据，仅包含元数据和游标。<br>Pulsar通过允许消费者将Pulsar主题视为在消费者确认后删除消息的队列，或者像消费者可以根据需要回放游标的日志来提供排队和日志语义。 存储模型底层是相同的 - 日志。</p>
<p>如果未对主题（通过其名称空间）设置数据保留策略，则在附加订阅的所有游标都已通过其偏移量后，将删除消息。 也就是说，该消息已在附加到该主题的所有订阅上得到确认。</p>
<p>但是，如果存在涵盖主题的数据保留策略，则一旦通过策略边界（主题的大小，主题中的时间），就会删除消息。</p>
<p>消息也可以在到期时发送。 如果这些消息在未确认的情况下超过TTL，则会被删除。 这意味着可以在任何消费者有机会阅读之前删除它们。 到期仅适用于未确认的消息，因此更适合于排队语义方面。</p>
<p>TTL分别适用于每个订阅，这意味着“删除”是逻辑删除。 实际删除将根据其他订阅和任何数据保留策略中发生的情况稍后发生。</p>
<p>消费者逐个或累积地确认他们的消息。 累积确认对吞吐量会更好，但在消费者失败后会引入重复的消息处理。 但是，累积确认不适用于共享订阅，因为确认基于偏移。 但是，消费者API确实也允许批量确认，这些确认最终会得到相同数量的确认，但这种模式会产生少量的RPC调用。 这可以提高共享订阅上竞争消费者的吞吐量。</p>
<p>最后，有一些类似于Kafka主题的分区主题。 区别在于Pulsar中的分区也是主题。 就像kafka一样，生产者可以使用散列算法或明确选择分区， 循环发送消息。</p>
<p>这是对高级概念的旋风式介绍，我们现在将深入研究。 请记住，这不是从顶层来学习使用Apache Pulsar的入门读物，而是看看它在底层的工作原理。</p>
<h3 id="第二层-逻辑存储模型"><a href="#第二层-逻辑存储模型" class="headerlink" title="第二层-逻辑存储模型"></a>第二层-逻辑存储模型</h3><p>现在Apache BookKeeper进入了场景。 我将在Apache Pulsar的背景下讨论BookKeeper，尽管BookKeeper是一个通用的日志存储解决方案。</p>
<p>首先，BookKeeper在一组节点上存储数据。 每个BookKeeper节点都称为Bookie。 其次，Pulsar和BookKeeper都使用Apache Zookeeper来存储元数据和监控节点健康状况。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/56894e581c1210fead06f878/1538572211110-2C6EPHJTLLAOTVMVHXM1/ke17ZwdGBToddI8pDm48kNuQg4DPj-ZiSLlQ1mA-m5VZw-zPPgdn4jUwVcJE1ZvWQUxwkmyExglNqGp0IvTJZUJFbgE-7XRK3dMEBRBhUpziKpoV5IaTDWe156eBon-JdNkIvVB8rdM9jZ1mHzghMHtuQ3Bc-WEW1Zva2BOApwg/PulsarBkZkCluster.png" alt="Fig 3. Apache Pulsar, BookKeeper and ZooKeeper working together"></p>
<p>一个主题实际上是一个Ledgers流。 Ledger本身就是一个日志。 因此，我们将一系列子日志（Ledgers）中组合成父日志（主题）。</p>
<p>分类帐（Ledgers）附加到主题，条目（消息或消息组）附加到分类帐。 Ledgers一旦关闭，是不可改变的。 分类帐作为一个单元被删除，也就是说，我们不能删除单个条目而是删除整个分类帐。</p>
<p>Ledgers本身也被分解成片段。 片段是BookKeeper集群中最小的分布单元（根据您的观点，条带化可能会使该声明无效（原文为：depending on your perspective, striping might invalidate that claim，译者注））。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/56894e581c1210fead06f878/1538497275047-DGDCYE3LX945H79I1MOI/ke17ZwdGBToddI8pDm48kP4OquFsp0z_4M9SgEdkA-1Zw-zPPgdn4jUwVcJE1ZvWQUxwkmyExglNqGp0IvTJZUJFbgE-7XRK3dMEBRBhUpwZopll50m_pEdS__uD2SDZ8yBY1t3JP7PQYoqOUTuOGEif_HaDux59pPCV6sKZagQ/LogLedgerFragmentEntry.png"></p>
<p>主题是Pulsar概念。 分类帐，片段和条目是BookKeeper的概念，尽管Pulsar理解并使用了分类帐和条目。</p>
<p>每个Ledger（由一个或多个片段组成）可以跨多个BookKeeper节点（Bookies）进行复制，以实现冗余和读取性能。 每个片段都在一组不同的Bookies中复制（如果存在足够的Bookies）。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/56894e581c1210fead06f878/1538497570494-EIP81VKC3W4VZQBWCWWH/ke17ZwdGBToddI8pDm48kIbud3I0PP4grOx6GV69VKdZw-zPPgdn4jUwVcJE1ZvWQUxwkmyExglNqGp0IvTJZamWLI2zvYWH8K3-s_4yszcp2ryTI0HqTOaaUohrI8PILXN0epPzkBEfvjJ1KHqFVVIpd5CcZ1H4NuqC5vYibEQ/SubTopicLedgerFragmentBookie.png"></p>
<p>每个Ledger有三个关键配置：</p>
<ul>
<li>集合大小（Ensemble Size (E)）</li>
<li>写法定大小（Write Quorum Size (Qw)）</li>
<li>确认法定大小（Ack Quorum Size (Qa)）</li>
</ul>
<p>这些配置应用于主题级别，然后Pulsar在主题的BookKeeper Ledgers &#x2F; Fragments上设置。</p>
<p>注意：“Ensemble”表示将写入的实际Bookies列表。 集合大小是指Pulsar说它应该创造多大的集合。 请注意，您至少需要E个Bookies才能进行写入。 默认情况下，Bookies被从可用Bookies列表中随机选取（每个Bookies在Zookeeper中注册自己）。</p>
<p>通过将Bookies标记为属于特定机架，还可以选择配置机架感知。 机架可以是逻辑构造（例如：云环境中的可用区域）。 通过机架感知策略，Pulsar客户端的BookKeeper客户端将尝试从不同的机架中选择Bookies。 也可以插入自定义策略以执行不同类型的选择。</p>
<p>集合大小（E）控制Pulsar写入的Ledger可用的Bookies池的大小。 每个片段可能有不同的集合，经纪人（pulsar broker）将在创建片段时选择一组Bookies（broker是选取一组bookies作为存储体，这一组存储体就存储这个片段（fragment），译者注），但整体将始终是由E指示的大小。必须有足够的Bookies可用于覆盖E。</p>
<p>Write Quorum（Qw）是Pulsar写入条目的实际Bookies数。 它可以等于或小于E。A fragment of 8 entries stored across an ensemble of 3 with each entry written to 3 bookies.</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/56894e581c1210fead06f878/1538556992096-2Y1LIUC0GI3XKGGM064I/ke17ZwdGBToddI8pDm48kMhWbqEOzLM2QU2fvTknMAlZw-zPPgdn4jUwVcJE1ZvWhcwhEtWJXoshNdA9f1qD7YIE3ZwwVlGd312yABb759F_qgn4yC8n-gJY79c93t1ZXZ9isb_v9u5N1MTxi-8cgA/FragmentEnsemble.png"></p>
<p>当Qw小于E时，我们得到条带化，它以这样的方式分配读&#x2F;写，即每个Bookie只需要提供读&#x2F;写请求的子集。 条带化可以提高总吞吐量并降低延迟。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/56894e581c1210fead06f878/1538557218910-2K8O0CLWOD9N7ZXX45JS/ke17ZwdGBToddI8pDm48kH1uC8zMwd-1etWmzsTwoCRZw-zPPgdn4jUwVcJE1ZvWEtT5uBSRWt4vQZAgTJucoTqqXjS3CfNDSuuf31e0tVGTXPL0VIdgPuIggbScLSveBvIJz4D2sTx6V5oRWqJGh5uG45vQwBxdpDrCGUSSl5w/FragmentWithStriping.png"></p>
<p>Ack Quorum（Qa）是必须承认写入的Bookies的数量，Pulsar经纪人将其确认发送给其客户（客户端：译者注）。 在实践中它可能是：</p>
<ul>
<li>(Qa &#x3D;&#x3D; Qw) or</li>
<li>(Qa &#x3D;&#x3D; Qw -1) —&gt; This will improve latency by ignoring the slowest bookie.</li>
</ul>
<p>最终，每个预订者都必须收到写确认。 但是，如果我们总是等待所有的Bookies做出回应，我们就会得到波动的延迟（原文为：spiky latency意为高低不平的延时，且作者有拼写错误，译者注）和没有吸引力的尾部延迟。 Pulsar毕竟承诺可预测的延迟。</p>
<p>（译者注：topic被分为多个Ledger分类账，而一个分类账需要多个bookie来做记录（高可读和容灾），这多个bookie就为了方便描述就被描述为fragment，但是ledger和fragment并不等价，一个Ledger有多个fragment。<strong>topic和Ledger的关系有点像fragment和bookie的关系</strong>）</p>
<p>当创建新主题或发生翻转（Roll-over）时，会创建分类帐。 翻转是在以下任何一种情况下创建新Ledger的概念：</p>
<ul>
<li>一个分类账的大小或者时间限制已经满足</li>
<li>一个分类账所有权（一个pulsar经纪人）发生改变</li>
</ul>
<p>当一下情形发生时，片段被创建：</p>
<ul>
<li>一个分类账被创建</li>
<li>当前片段集合的一个bookie在写操作时返回一个错误，或者超时</li>
</ul>
<p>当一个bookie无法提供写作时，Pulsar经纪人就会忙着创建一个新的片段，并确保写入得到Qw个bookie的认可。 就像终结者一样，它不会停止，直到该消息被持久化。</p>
<blockquote>
<p>Insight＃1：增加E以优化延迟和吞吐量。 以写入吞吐量为代价增加Qw以实现冗余。 增加Qa，就增加了已确认写入的持久性，也增加了额外延迟和更长尾部延迟的风险。</p>
<p>Insight＃2：E和Qw不是Bookies列表。 它们只是表明可以为给定的Ledger服务的Bookies池有多大。 Pulsar将在创建新的Ledger或Fragment时使用E和Qw。 每个片段在其整体中都有一组固定的Bookies，永远不会改变。</p>
<p>Insight＃3：添加新Bookies并不意味着需要执行手动重新平衡。 这些新的Bookies将自动成为新片段的候选者。 加入群集后，将在创建新的片段&#x2F;分类帐后立即写入新的Bookies。 每个片段都可以存储在群集中不同的Bookies子集中！ 我们不会将主题或分类帐连接到给定的Bookie或Bookies集合。</p>
</blockquote>
<p>让我们停下来评估一下。 对于卡夫卡来说，这是一个非常不同且更复杂的模型。 使用Kafka，每个分区副本完全存储在单个代理上。 分区副本由一系列段和索引文件组成。这篇博文（ <a target="_blank" rel="noopener" href="https://thehoard.blog/how-kafkas-storage-internals-work-3a29b02e026%EF%BC%89%E5%BE%88%E5%A5%BD%E5%9C%B0%E6%8F%8F%E8%BF%B0%E4%BA%86%E5%AE%83%E3%80%82">https://thehoard.blog/how-kafkas-storage-internals-work-3a29b02e026）很好地描述了它。</a></p>
<p>Kafka模型的优点在于它简单快速。 所有读写都是顺序的。 糟糕的是，单个代理必须有足够的存储空间来处理该副本，因此非常大的副本可能会迫使您拥有非常大的磁盘。 第二个缺点是，在扩展集群时重新平衡分区变得必要。 这可能是痛苦的，需要良好的计划和执行才能在没有任何障碍的情况下拉开。</p>
<p>回到Pulsar + BookKeeper模型。 给定主题的数据分布在多个Bookies中。 该主题已分为Ledgers， 而Ledgers分为片段，并带有条带化，成为可计算的片段集合子集。 当您需要扩展集群时，只需添加更多Bookies，它们就会在创建新片段时开始写入。 不再需要卡夫卡式的再平衡。 但是，读取和写入现在必须在Bookies之间跳跃一点。 我们将在这篇文章看到Pulsar如何管理并高速处理。</p>
<p>但现在每个Pulsar经纪人都需要跟踪每个主题所包含的Ledgers和Fragments。 这个元数据存储在ZooKeeper中，如果你丢失了，那么你就会陷入严重的困境。</p>
<p>在存储层中，我们编写的主题均匀的分布到BookKeeper集群。 我们避免了将Topic副本耦合到特定节点的陷阱。 卡夫卡主题就像Toblerone（一种巧克力冰激凌，用中文可以说为老冰棍的棍子，译者注）的棒子一样，我们的Pulsar主题就像一个气体膨胀来填补可用空间。 这避免了痛苦的再平衡。</p>
<h3 id="第二层-pulsar的broker和topic所有权"><a href="#第二层-pulsar的broker和topic所有权" class="headerlink" title="第二层-pulsar的broker和topic所有权"></a>第二层-pulsar的broker和topic所有权</h3><p>同样在我的抽象层的第2层，我们有Pulsar Brokers。 Pulsar Brokers（经纪人）没有会丢失的持久状态。 它们与存储层分开。 BookKeeper集群本身并不执行复制，每个Bookie只是一个跟随者，被领导者告知应该做什么 - 领导者是Pulsar经纪人。 <strong>每个主题都只由单独一个Pulsar经纪人拥有。 该经纪服务于该主题的所有读写操作。</strong></p>
<p>当Pulsar经纪人接收到写入时，它将针对该主题的当前片段的集合执行该写入。 请记住，如果没有条带化，则每个条目（<strong>Entity，条目可以认为是一条记录，类似sql中的一行记录</strong>，译者注）的集合与片段集合相同。 如果发生条带化，那么每个条目都有自己的集合，这是片段集合的一个子集。</p>
<p>在一般情况下，当前的Ledger中将有一个Fragment。 一旦Qa个经纪人承认写入，Pulsar经纪人将向生产者客户发送确认。</p>
<p>只有在所有先前消息都已通过Qa个确认时，才能发送确认。 如果对于给定的消息，Bookie响应错误或根本没有响应，则经纪人将在新的Bookies集合上创建新的片段（不包括问题Bookie）。</p>
<p>对于特定的主题，一个经纪人服务所有的读写</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/56894e581c1210fead06f878/1538559874547-UYUESUUV7Q33RK5BJXDB/ke17ZwdGBToddI8pDm48kEhfMt_UJWE-NBWU6gIQCfBZw-zPPgdn4jUwVcJE1ZvWQUxwkmyExglNqGp0IvTJZUJFbgE-7XRK3dMEBRBhUpzMDXHj_QteqFFq4zPI8ZR9qIgV0hNheP2G3x6v_w8PhyA9VS238vByjKbGT0QZicU/PulsarBrokerWrites.png"></p>
<p>请注意，经纪人只会等待来自bookie的Qa ack。</p>
<p>读取也通过所有者。 作为给定主题的单一入口点的经纪人知道哪些偏移已经安全地保存到BookKeeper。 它只需要从一个Bookie读取即可进行读取。 我们将在第3层中看到它如何使用缓存从其内存缓存中提供许多读取，而不是将读取发送到BookKeeper。</p>
<p>只需要从一个bookie去读取</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/56894e581c1210fead06f878/1538560169571-MKFXQQ8FJ6MMJH4V59EO/ke17ZwdGBToddI8pDm48kEhfMt_UJWE-NBWU6gIQCfBZw-zPPgdn4jUwVcJE1ZvWQUxwkmyExglNqGp0IvTJZUJFbgE-7XRK3dMEBRBhUpzMDXHj_QteqFFq4zPI8ZR9qIgV0hNheP2G3x6v_w8PhyA9VS238vByjKbGT0QZicU/PulsarBrokerReads.png"></p>
<p>Pulsar Broker的健康状况由ZooKeeper监控。 当代理失败或变得不可用（对ZooKeeper）时，会发生所有权更改。 新的代理成为主题所有者，然后所有客户端都被定向读取&#x2F;写入此新代理。</p>
<p>BookKeeper有一个非常重要的功能，称为Fencing。 Fencing允许BookKeeper保证只有一个写入者（Pulsar经纪人）可以写入分类账。</p>
<p>它按如下流程工作</p>
<ol>
<li>拥有主题X的当前Pulsar经纪人（B1）被视为已死或不可用（通过ZooKeeper来监控并判定）。</li>
<li>另一个代理（B2）将主题X的当前分类帐的状态从OPEN更新为IN_RECOVERY。</li>
<li>B2向分类账的当前片段的所有bookies发送围栏消息，并等待（Qw-Qa）+1响应。 收到此响应数后，分类帐现在会被围起来。 旧代理如果它实际上仍然存活，则无法进行写入，因为它无法获得Qa确认（由于屏蔽异常响应）。</li>
<li>B2然后从片段集合中的每个bookie请求他们最后确认的条目是什么。 它需要最新的条目ID，然后从该点开始向前阅读。 它确保从那一点开始的所有条目（可能以前未向Pulsar经纪人确认）都会被复制到Qw个bookies。 一旦B2无法读取并复制任何更多条目，分类帐将完全恢复。</li>
<li>B2将分类账的状态改变为closed</li>
<li>B2现在可以在新的分类账上接受写和读操作</li>
</ol>
<p>关于这种架构的伟大之处在于，通过让领导者（Pulsar经纪人）没有状态，BookKeeper的围栏功能可以很好地处理裂脑（原文为split-brain， 译者注）问题。 没有裂脑，没有分歧，没有数据丢失。</p>
<h3 id="第二层-游标追踪"><a href="#第二层-游标追踪" class="headerlink" title="第二层-游标追踪"></a>第二层-游标追踪</h3><p>每个订阅都存储一个游标。 游标是日志中的当前偏移量。 订阅将其游标存储在BookKeeper的分类帐中。 这使游标跟踪可以像主题一样进行扩展。</p>
<h3 id="第三层-bookie存储"><a href="#第三层-bookie存储" class="headerlink" title="第三层-bookie存储"></a>第三层-bookie存储</h3><p>Ledgers和Fragments是逻辑结构，在ZooKeeper中维护和跟踪。 物理上，数据不存储在与Ledgers和Fragments对应的文件中。 BookKeeper中存储的实际实现是可插拔的，Pulsar默认使用名为DbLedgerStorage的存储实现来存储数据。</p>
<h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><p>当发生对Bookie的写入时，首先将该消息写入日志文件。 这是一个预写日志（WAL），它有助于BookKeeper在发生故障时避免数据丢失。 这和关系数据库实现其持久性保证的相同机制。</p>
<p>写入操作也写入写入缓存。 写入缓存会累积写入并定期将写入排序并刷盘到条目日志文件。 对写入进行排序，以便将同一分类帐的条目放在一起，从而提高读取性能。 如果条目以严格的时间顺序（strict temporal）写入，则读取将不能受益于磁盘上的顺序布局。 通过聚合和排序，我们实现了分类账级别的时间排序，这是我们关心的。</p>
<p>Write Cache还将条目写入RocksDB，RocksDB存储每个条目位置的索引。 它只是将（ledgerId，entryId）映射到（entryLogId，文件中的偏移量）。</p>
<p>由于<strong>写入缓存具有最新消息</strong>，因此读取首先达到写入缓存。 如果存在写入缓存未命中，则它将命中读取缓存。 如果存在第二次缓存未命中，则读取缓存会在RocksDB中查找所请求条目的位置，然后在正确的条目日志文件中读取该条目。 它执行预读并更新读缓存，以便后续请求更有可能获得缓存命中。 这两层缓存意味着读取通常从内存中提供。</p>
<p>BookKeeper允许您将磁盘IO与读写隔离。 写入都按顺序写入日志文件，可以存储在专用磁盘上，并以组的形式提交，以获得更高的吞吐量。 之后，从写入者的角度来看，不需要磁盘IO的同步。 数据只写入内存缓冲区。</p>
<p>写缓存在后台线程上异步执行批量写入Entry Log文件和RocksDB，所以写缓存通常运行自己的共享磁盘。 因此，一个磁盘用于同步写入（日志文件），另一个磁盘用于异步优化写入和所有读取。（译者注：一个磁盘用于批量写入，另一个磁盘接受写入和读取请求（这些都是不连续的））</p>
<h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><p>在读的方面，读者要么被读缓存服务，要么被日志条目文件和RocksDB服务</p>
<h4 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h4><p>还要考虑到写入可以使入口网络带宽（ ingress network bandwidth）饱和，并且读取可以使出口网络带宽（egress network bandwidth）饱和，但它们不会相互影响。</p>
<p>这种优雅的隔离读取来自磁盘和网络级别的写入。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/56894e581c1210fead06f878/1538601042753-J8IXQ06HUPV1R7PEAPFE/ke17ZwdGBToddI8pDm48kGp6mpaF6fRR69MhdwssQUgUqsxRUqqbr1mOJYKfIPR7LoDQ9mXPOjoJoqy81S2I8N_N4V1vUb5AoIIIbLZhVYxCRW4BPu10St3TBAUQYVKcUp2nWII0JUNTlurDWjlSqtH1pYxrnuysKJX4SS0MkLn8sIGgGTuW_pGj0nnlCENC/image-asset.png" alt="Fig 10. A Bookie with the default (with Apache Pulsar) DbLedgerStorage architecture."></p>
<h3 id="第三层-pulsar代理人缓存"><a href="#第三层-pulsar代理人缓存" class="headerlink" title="第三层-pulsar代理人缓存"></a>第三层-pulsar代理人缓存</h3><p>每个主题都仅有一个代理所有者的代理。 所有读写都通过该代理进行。 这提供了许多好处。</p>
<p>首先，代理可以将日志尾部缓存在内存中，这意味着代理可以在不需要BookKeeper的情况下为尾部读取器（tailing readers， 译者注）提供服务。 这避免了支付网络往返（network round-trip， 译者注）的费用以及Bookie上可能的磁盘读取。</p>
<p>经纪人也知道Last Add Confirmed条目的id。 它可以跟踪哪条消息是最后一个安全持久的消息。</p>
<p>当代理在其缓存中没有消息时，它将从该消息的片段集合中的一个Bookie请求数据。 这意味着尾部读取器和追赶读取器（catch-up readers， 译者注）之间的读取服务性能差异很大。 尾部读取器可以从Pulsar代理的内存中提供，而如果写入和读取高速缓存都没有数据，则追赶读取器可能必须承担额外的网络往返和多次磁盘读取的成本。</p>
<p>因此，我们从高层次上涵盖了消息的逻辑和物理表示，以及Pulsar集群中的不同参与者及其相互之间的关系。 有很多细节尚未涵盖，但我们会将其作为以后的练习。</p>
<p>接下来我们将介绍Apache Pulsar集群如何确保在节点故障后消息得到充分复制。</p>
<h2 id="恢复协议"><a href="#恢复协议" class="headerlink" title="恢复协议"></a>恢复协议</h2><p>当一个bookie失败时，所有在该bookie上有碎片的分类账现在都在复制。 恢复是“重新复制”片段的过程，以确保为每个分类帐维护复制因子（Qw）。</p>
<p>有两种类型的恢复：手动或自动。 两者的重复复制协议相同，但自动恢复使用内置的失败节点检测机制来注册要执行的重复复制任务。 手动过程需要手动干预。</p>
<p>我们将聚焦自动回复机制</p>
<p>自动恢复可以在AutoRecoveryMain流程中从一组专用服务器运行，也可以在Bookies上托管。 其中一个自动恢复进程被选为审计员（原文为：Auditor，译者注）。 审计员的作用是检测崩溃的Bookies然后：</p>
<ul>
<li>阅读ZK的完整分类帐清单，找到托管（原文为：hosted on）在失败的Bookies上的分类帐。</li>
<li>对于每个分类帐，它将在ZooKeeper中的&#x2F;underreplicated znode中创建重新复制任务。</li>
</ul>
<p>如果Auditor节点出现故障，则另一个节点将升级为Auditor。 Auditor是AutoRecoveryMain过程中的一个线程。</p>
<p>AutoRecoveryMain进程还有一个运行Replication Task Worker的线程。 每个工作人员（worker）都会监视未充分复制的znode以查找任务。</p>
<p>在看到任务时，它会尝试锁定它（获取锁，译者注）。 如果它无法获取锁定，它将进入下一个任务。</p>
<p>如果它确实设法获得了锁，那么：</p>
<ul>
<li>扫描分类帐，查找本地bookie不属于的碎片</li>
<li>对于每个匹配的片段，它将来自另一个bookie的数据复制到自己的bookie，使用新的集合更新ZooKeeper，并将片段标记为完全复制。</li>
</ul>
<p>如果分类帐仍然存在未复制的碎片，则释放锁定。 如果所有片段都完全复制，则从 &#x2F;underreplicated 删除任务。</p>
<p>如果片段没有结束条目ID，则复制任务将等待并再次检查，如果片段仍然没有结束条目ID，则它会在重新复制片段之前对分类帐进行隔离（fences）。</p>
<p>因此，使用自动恢复模式，Pulsar集群能够完全复制细节，以确保每个分类帐的正确复制因子。 管理员只需确保部署适量的bookies。</p>
<h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><p>Pulsar和BookKeeper都需要ZooKeeper。 如果Pulsar节点失去所有ZooKeeper节点的可见性，那么它将停止接受读写并重新启动。 这是一种预防措施，可确保群集无法进入不一致状态。</p>
<p>这意味着如果ZooKeeper发生故障，一切都变得不可用，并且所有Pulsar节点缓存都将被擦除。 因此，在恢复服务时，理论上可能存在由于所有读取都到达BookKeeper而导致的延迟峰值。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul>
<li>主题有一个所有者经纪人</li>
<li>每一个主题逻辑上被分为，分类账们，片段们和条目们</li>
<li>片段分布在bookie集群中。 给定的主题与给定的bookies没有耦合。</li>
<li>片段可以跨多个bookies条带化</li>
<li>当Pulsar经纪人失败（可以翻译为崩溃，但译者不愿意：译者注）时，该经纪人的主题的所有权将故障转移给另一个经纪人。 Fencing避免了两个可能认为自己的所有者同时实际写入当前主题分类帐的经纪人。</li>
<li>当bookie失败时，自动恢复（如果启用）将自动将数据“重新复制”到其他bookies。 如果禁用，则可以启动手动过程。</li>
<li>经纪人缓存日志尾部，使他们能够非常有效地为尾部读取器提供服务</li>
<li>bookie使用日志来提供失败保证。 该日志可用于恢复发生故障时，尚未写入Entry Log文件的数据。</li>
<li>所有主题的条目都在Entry Log文件中交错。 查找索引保存在RocksDB中。</li>
<li>Bookies按如下方式提供服务: Write Cache -&gt; Read Cache -&gt; Log Entry files</li>
<li>Bookies可以通过单独的磁盘隔离读取写入IO，用于日志文件，日志条目文件和RocksDB</li>
<li>ZooKeeper存储Pulsar和BookKeeper的所有元数据。 如果ZooKeeper不可用，则Pulsar不可用</li>
<li>存储可以单独扩展到Pulsar经纪人。 如果存储是瓶颈，那么只需添加更多的bookies ，他们将开始承担负载而无需重新平衡。</li>
</ul>
<p><img src="https://images.squarespace-cdn.com/content/v1/56894e581c1210fead06f878/1538583413563-QVJ2MWQQK1B10NIP45NZ/ke17ZwdGBToddI8pDm48kF9K_vvjtFzVXH1W4f_DQEpZw-zPPgdn4jUwVcJE1ZvWQUxwkmyExglNqGp0IvTJZUJFbgE-7XRK3dMEBRBhUpyf1S8Qn827K1psbrnM8HhCaEP0bNw_lw7ho1MuAex3PfHhIYVgeZkiJDc-4VfhUAY/RoundUp.png"></p>
<h2 id="关于潜在的数据丢失的初步思考"><a href="#关于潜在的数据丢失的初步思考" class="headerlink" title="关于潜在的数据丢失的初步思考"></a>关于潜在的数据丢失的初步思考</h2><p>–这一部分未完全翻译</p>
<p>让我们来看看RabbitMQ和Kafka承认的写消息丢失情况，看看它们是否适用于Pulsar。</p>
<h3 id="RabbitMQ具有Ignore或Autoheal模式的裂脑"><a href="#RabbitMQ具有Ignore或Autoheal模式的裂脑" class="headerlink" title="RabbitMQ具有Ignore或Autoheal模式的裂脑"></a>RabbitMQ具有Ignore或Autoheal模式的裂脑</h3><p>分区的丢失方丢失了自分区开始以来未传递的任何消息。</p>
<p>Apache Pulsar在理论上不存在存储层上的裂脑。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>还有更多的细节，我要么没有涉及，要么还不知道。在协议和存储模型方面，ApachePulsar比ApacheKafka复杂得多。</p>
<p>pulsar集群的两个显著特点是：</p>
<ul>
<li>将存储器与存储分离，结合BookKeepers防护功能，可以优雅地避免可能引起数据丢失的裂脑情况。</li>
<li>将主题分解为分类帐和碎片，并在群集中分发这些主题，使Pulsar群集可以轻松扩展。 新数据自动开始写入新的bookie。 不需要重新平衡。</li>
</ul>
<p>此外，我甚至没有进行到地理复制和分层存储，这也是令人惊叹的功能。</p>
<p>我的感觉是Pulsar和BookKeeper是下一代数据流系统的一部分。 他们的协议经过深思熟虑，相当优雅。 但随着复杂性的增加，增加了漏洞的风险。 在下一篇文章中，我们将开始对Apache Pulsar集群进行混乱测试，看看我们是否可以识别协议中的弱点，以及任何实现错误或异常。</p>
<p>标签：Apache Pulsar</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Percy"
      src="https://ivalue2333.github.io/percy/images/percy.jpg">
  <p class="site-author-name" itemprop="name">Percy</p>
  <div class="site-description" itemprop="description">IOT2014</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">156</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">194</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Percy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
