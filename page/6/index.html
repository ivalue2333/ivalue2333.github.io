<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="IOT2014">
<meta property="og:type" content="website">
<meta property="og:title" content="blog | percy">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="blog | percy">
<meta property="og:description" content="IOT2014">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Percy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>blog | percy</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blog | percy</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/21/io/Nginx%20%E6%83%8A%E7%BE%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/21/io/Nginx%20%E6%83%8A%E7%BE%A4/" class="post-title-link" itemprop="url">Nginx 惊群</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-21 20:32:42" itemprop="dateCreated datePublished" datetime="2020-11-21T20:32:42+08:00">2020-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IO/" itemprop="url" rel="index"><span itemprop="name">IO</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>惊群通常发生在server 上，当父进程绑定一个端口监听socket，然后fork出多个子进程，子进程们开始循环处理（比如accept）这个socket。每当用户发起一个TCP连接时，多个子进程同时被唤醒，然后其中一个子进程accept新连接成功，余者皆失败，重新休眠。</p>
<p>惊群现象（thundering herd）就是当多个进程和线程在同时阻塞等待同一个事件时，如果这个事件发生，会唤醒所有的进程，但最终只可能有一个进程&#x2F;线程对该事件进行处理，其他进程&#x2F;线程会在失败后重新休眠，这种性能浪费就是惊群。</p>
<p>那么，我们不能只用一个进程去accept新连接么？然后通过消息队列等同步方式使其他子进程处理这些新建的连接，这样惊群不就避免了？没错，惊群是避免了，但是效率低下，因为这个进程只能用来accept连接。对多核机器来说，仅有一个进程去accept，这也是程序员在自己创造accept瓶颈。所以，我仍然坚持需要多进程处理accept事件。</p>
<p>其实，在linux2.6内核上，accept系统调用已经不存在惊群了（至少我在2.6.18内核版本上已经不存在）。大家可以写个简单的程序试下，在父进程中bind,listen，然后fork出子进程，所有的子进程都accept这个监听句柄。这样，当新连接过来时，大家会发现，仅有一个子进程返回新建的连接，其他子进程继续休眠在accept调用上，没有被唤醒。</p>
<p>但是很不幸，通常我们的程序没那么简单，不会愿意阻塞在accept调用上，我们还有许多其他网络读写事件要处理，linux下我们爱用epoll解决非阻塞socket。所以，即使accept调用没有惊群了，我们也还得处理惊群这事，因为epoll有这问题。上面说的测试程序，如果我们在子进程内不是阻塞调用accept，而是用epoll_wait，就会发现，新连接过来时，多个子进程都会在epoll_wait后被唤醒！</p>
<p>nginx就是这样，master进程监听端口号（例如80），所有的nginx worker进程开始用epoll_wait来处理新事件（linux下），如果不加任何保护，一个新连接来临时，会有多个worker进程在epoll_wait后被唤醒，然后发现自己accept失败。现在，我们可以看看nginx是怎么处理这个惊群问题了。</p>
<h2 id="Nginx如何处理惊群问题"><a href="#Nginx如何处理惊群问题" class="headerlink" title="Nginx如何处理惊群问题"></a>Nginx如何处理惊群问题</h2><h3 id="ngx-process-events-and-timers"><a href="#ngx-process-events-and-timers" class="headerlink" title="ngx_process_events_and_timers"></a>ngx_process_events_and_timers</h3><p>nginx的每个worker进程在函数ngx_process_events_and_timers中处理事件，(void) ngx_process_events(cycle, timer, flags);封装了不同的事件处理机制，在linux上默认就封装了epoll_wait调用。我们来看看ngx_process_events_and_timers为解决惊群做了什么：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ngx_process_events_and_timers</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ngx_uint_t</span>  flags;</span><br><span class="line">    <span class="type">ngx_msec_t</span>  timer, delta;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ngx_timer_resolution) &#123;</span><br><span class="line">        timer = NGX_TIMER_INFINITE;</span><br><span class="line">        flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        timer = ngx_event_find_timer();</span><br><span class="line">        flags = NGX_UPDATE_TIME;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_WIN32)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* handle signals from master in case of network inactivity */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timer == NGX_TIMER_INFINITE || timer &gt; <span class="number">500</span>) &#123;</span><br><span class="line">            timer = <span class="number">500</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ngx_use_accept_mutex表示是否需要通过对accept加锁来解决惊群问题。</span></span><br><span class="line">    <span class="comment">// 当nginx worker进程数&gt;1时且配置文件中打开accept_mutex时，这个标志置为1</span></span><br><span class="line">    <span class="keyword">if</span> (ngx_use_accept_mutex) &#123;</span><br><span class="line">        <span class="comment">// ngx_accept_disabled表示此时满负荷，没必要再处理新连接了，我们在nginx.conf曾经配置了每一个nginx worker进程</span></span><br><span class="line">        <span class="comment">// 能够处理的最大连接数，当达到最大数的7/8时，ngx_accept_disabled为正，说明本nginx worker进程非常繁忙，</span></span><br><span class="line">        <span class="comment">// 将不再去处理新连接，这也是个简单的负载均衡</span></span><br><span class="line">        <span class="keyword">if</span> (ngx_accept_disabled &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ngx_accept_disabled--;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获得accept锁，多个worker仅有一个可以得到这把锁。获得锁不是阻塞过程，都是立刻返回，</span></span><br><span class="line">            <span class="comment">// 获取成功的话ngx_accept_mutex_held被置为1。拿到锁，意味着监听句柄被放到本进程的epoll中了，</span></span><br><span class="line">            <span class="comment">// 如果没有拿到锁，则监听句柄会被从epoll中取出。</span></span><br><span class="line">            <span class="keyword">if</span> (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拿到锁的话，置flag为NGX_POST_EVENTS，这意味着ngx_process_events函数中，</span></span><br><span class="line">            <span class="comment">// 任何事件都将延后处理，会把accept事件都放到ngx_posted_accept_events链表中，</span></span><br><span class="line">            <span class="comment">// epollin|epollout事件都放到ngx_posted_events链表中</span></span><br><span class="line">            <span class="keyword">if</span> (ngx_accept_mutex_held) &#123;</span><br><span class="line">                flags |= NGX_POST_EVENTS;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 拿不到锁，也就不会处理监听的句柄，这个timer实际是传给epoll_wait的超时时间，</span></span><br><span class="line">                <span class="comment">// 修改为最大ngx_accept_mutex_delay意味着epoll_wait更短的超时返回，以免新连接长时间没有得到处理</span></span><br><span class="line">                <span class="keyword">if</span> (timer == NGX_TIMER_INFINITE</span><br><span class="line">                    || timer &gt; ngx_accept_mutex_delay)</span><br><span class="line">                &#123;</span><br><span class="line">                    timer = ngx_accept_mutex_delay;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ngx_queue_empty(&amp;ngx_posted_next_events)) &#123;</span><br><span class="line">        ngx_event_move_posted_next(cycle);</span><br><span class="line">        timer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delta = ngx_current_msec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//linux下，调用ngx_epoll_process_events函数开始处理</span></span><br><span class="line">    (<span class="type">void</span>) ngx_process_events(cycle, timer, flags);</span><br><span class="line"></span><br><span class="line">    delta = ngx_current_msec - delta;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="string">&quot;timer delta: %M&quot;</span>, delta);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果ngx_posted_accept_events链表有数据，就开始accept建立新连接</span></span><br><span class="line">    ngx_event_process_posted(cycle, &amp;ngx_posted_accept_events);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁后再处理下面的EPOLLIN EPOLLOUT请求</span></span><br><span class="line">    <span class="keyword">if</span> (ngx_accept_mutex_held) &#123;</span><br><span class="line">        ngx_shmtx_unlock(&amp;ngx_accept_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (delta) &#123;</span><br><span class="line">        ngx_event_expire_timers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后再处理正常的数据读写请求。因为这些请求耗时久，</span></span><br><span class="line">    <span class="comment">// 所以在 ngx_process_events里NGX_POST_EVENTS标志将事件都放入ngx_posted_events链表中，延迟到锁释放了再处理。</span></span><br><span class="line">    ngx_event_process_posted(cycle, &amp;ngx_posted_events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的注释可以看到，无论有多少个nginx worker进程，同一时刻只能有一个worker进程在自己的epoll中加入监听的句柄。这个处理accept的nginx worker进程置flag为NGX_POST_EVENTS，这样它在接下来的ngx_process_events 函数（在linux中就是ngx_epoll_process_events函数）中不会立刻处理事件，延后，先处理完所有的accept事件后，释放锁，然后再处理正常的读写socket事件。我们来看下 **ngx_epoll_process_events **是怎么做的</p>
<h3 id="ngx-epoll-process-events-获得锁后的事件处理"><a href="#ngx-epoll-process-events-获得锁后的事件处理" class="headerlink" title="ngx_epoll_process_events-获得锁后的事件处理"></a>ngx_epoll_process_events-获得锁后的事件处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ngx_int_t</span></span><br><span class="line"><span class="title function_">ngx_epoll_process_events</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle, <span class="type">ngx_msec_t</span> timer, <span class="type">ngx_uint_t</span> flags)</span>&#123;</span><br><span class="line">    		ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="string">&quot;epoll timer: %M&quot;</span>, timer);</span><br><span class="line"></span><br><span class="line">    		events = epoll_wait(ep, event_list, (<span class="type">int</span>) nevents, timer);</span><br><span class="line">    		</span><br><span class="line">			rev-&gt;ready = <span class="number">1</span>;</span><br><span class="line">            rev-&gt;available = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有NGX_POST_EVENTS标志的话，就把accept事件放到ngx_posted_accept_events队列中，</span></span><br><span class="line">            <span class="comment">// 把正常的事件放到ngx_posted_events队列中延迟处理</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; NGX_POST_EVENTS) &#123;</span><br><span class="line">                <span class="built_in">queue</span> = rev-&gt;accept ? &amp;ngx_posted_accept_events</span><br><span class="line">                                    : &amp;ngx_posted_events;</span><br><span class="line"></span><br><span class="line">                ngx_post_event(rev, <span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rev-&gt;handler(rev);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        wev = c-&gt;write;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((revents &amp; EPOLLOUT) &amp;&amp; wev-&gt;active) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;fd == <span class="number">-1</span> || wev-&gt;instance != instance) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * the stale event from a file descriptor</span></span><br><span class="line"><span class="comment">                 * that was just closed in this iteration</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line"></span><br><span class="line">                ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                               <span class="string">&quot;epoll: stale event %p&quot;</span>, c);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            wev-&gt;ready = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_THREADS)</span></span><br><span class="line">            wev-&gt;complete = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//同理，有NGX_POST_EVENTS标志的话，写事件延迟处理，放到ngx_posted_events队列中</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; NGX_POST_EVENTS) &#123;</span><br><span class="line">                ngx_post_event(wev, &amp;ngx_posted_events);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                wev-&gt;handler(wev);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加锁的逻辑-ngx-trylock-accept-mutex"><a href="#加锁的逻辑-ngx-trylock-accept-mutex" class="headerlink" title="加锁的逻辑-ngx_trylock_accept_mutex"></a>加锁的逻辑-ngx_trylock_accept_mutex</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ngx_int_t</span></span><br><span class="line"><span class="title function_">ngx_trylock_accept_mutex</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ngx_shmtx_trylock是非阻塞取锁的，返回1表示成功，0表示没取到锁</span></span><br><span class="line">    <span class="keyword">if</span> (ngx_shmtx_trylock(&amp;ngx_accept_mutex)) &#123;</span><br><span class="line"></span><br><span class="line">        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                       <span class="string">&quot;accept mutex locked&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ngx_accept_mutex_held &amp;&amp; ngx_accept_events == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> NGX_OK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ngx_enable_accept_events会把监听的句柄都塞入到本worker进程的epoll中</span></span><br><span class="line">        <span class="keyword">if</span> (ngx_enable_accept_events(cycle) == NGX_ERROR) &#123;</span><br><span class="line">            ngx_shmtx_unlock(&amp;ngx_accept_mutex);</span><br><span class="line">            <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ngx_accept_mutex_held置为1，表示拿到锁了，返回</span></span><br><span class="line">        ngx_accept_events = <span class="number">0</span>;</span><br><span class="line">        ngx_accept_mutex_held = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> NGX_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="string">&quot;accept mutex lock failed: %ui&quot;</span>, ngx_accept_mutex_held);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理没有拿到锁的逻辑，ngx_disable_accept_events会把监听句柄从epoll中取出</span></span><br><span class="line">    <span class="keyword">if</span> (ngx_accept_mutex_held) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ngx_disable_accept_events(cycle, <span class="number">0</span>) == NGX_ERROR) &#123;</span><br><span class="line">            <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ngx_accept_mutex_held = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NGX_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OK，关于锁的细节是如何实现的，这篇限于篇幅就不说了，下篇帖子再来讲。现在大家清楚nginx是怎么处理惊群了吧？简单了说，<strong>就是同一时刻只允许一个nginx worker在自己的epoll中处理监听句柄 （listenfd）</strong>。它的负载均衡也很简单，当达到最大connection的7&#x2F;8时，本worker不会去试图拿accept锁，也不会去处理新连接，这样其他nginx worker进程就更有机会去处理监听句柄，建立新连接了。而且，由于timeout的设定，使得没有拿到锁的worker进程，去拿锁的频繁更高。</p>
<p><strong>同一时间，只有一个 worker 能拿到 listenfd(监听句柄)， 拿到 listenfd 的 worker 将这个文件描述符通过 epoll_ctl， 将这个句柄加入自己的监听列表中，其他没有拿到 listenfd 的 worker 就只处理 connfd (已连接的句柄)。这当然还涉及到多个worker的负载均衡的问题。单总体来说，同一时间，只有一个 worker 持有了 listenfd.</strong></p>
<p>加锁的方式是对 listenFd 文件上锁</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/russell_tao/article/details/7204260">原文：“惊群”，看看nginx是怎么解决它的</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/21/io/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%20epoll%20%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/21/io/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%20epoll%20%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">【IO】epoll 触发方式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-21 17:24:37" itemprop="dateCreated datePublished" datetime="2020-11-21T17:24:37+08:00">2020-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IO/" itemprop="url" rel="index"><span itemprop="name">IO</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在网络编程中，会涉及到水平触发与边缘触发的概念，工程中以边缘触发较为常见，本文讲述了边缘触发与水平触发的概念，并给出代码示例，通过代码可以很清楚的看到它们之间的区别。</p>
<h2 id="水平触发与边缘触发"><a href="#水平触发与边缘触发" class="headerlink" title="水平触发与边缘触发"></a>水平触发与边缘触发</h2><p>水平触发(level-trggered)</p>
<ul>
<li>只要文件描述符关联的读内核缓冲区非空，有数据可以读取，就一直发出可读信号进行通知，</li>
<li>当文件描述符关联的内核写缓冲区不满，有空间可以写入，就一直发出可写信号进行通知</li>
</ul>
<p>边缘触发(edge-triggered)</p>
<ul>
<li>当文件描述符关联的读内核缓冲区由空转化为非空的时候，则发出可读信号进行通知，</li>
<li>当文件描述符关联的内核写缓冲区由满转化为不满的时候，则发出可写信号进行通知</li>
</ul>
<h3 id="两者的区别？"><a href="#两者的区别？" class="headerlink" title="两者的区别？"></a>两者的区别？</h3><p>水平触发是只要读缓冲区有数据，就会一直触发可读信号，而边缘触发仅仅在空变为非空的时候通知一次，举个例子：</p>
<ol>
<li>读缓冲区刚开始是空的</li>
<li>读缓冲区写入2KB数据</li>
<li>水平触发和边缘触发模式此时都会发出可读信号</li>
<li>收到信号通知后，读取了1kb的数据，读缓冲区还剩余1KB数据</li>
<li>水平触发会再次进行通知，而边缘触发不会再进行通知</li>
</ol>
<p>所以边缘触发需要一次性的把缓冲区的数据读完为止，也就是一直读，直到读到<code>EGAIN</code>(<code>EGAIN</code>说明缓冲区已经空了)为止，因为这一点，边缘触发需要设置文件句柄为非阻塞。</p>
<blockquote>
<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p>
</blockquote>
<p>这里只简单的给出了水平触发与边缘触发的处理方式的不同，边缘触发相对水平触发处理的细节更多一些，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//水平触发， 如果这次从 fd 中没有将所有的字节读完，那么这个 fd 就还会再次唤醒</span></span><br><span class="line">ret = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line"><span class="comment">//边缘触发（代码不完整，仅为简单区别与水平触发方式的代码）</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    ret = read(fd, buf, <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    <span class="keyword">if</span> (ret == EAGAIN) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903878685622285">看这一篇就可以了</a></p>
<p>代码： cpp&#x2F;io&#x2F;epollet&#x2F;server.c</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/20/io/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%20epoll%20%E6%83%8A%E7%BE%A4%20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/20/io/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%20epoll%20%E6%83%8A%E7%BE%A4%20/" class="post-title-link" itemprop="url">IO多路复用 epoll 惊群</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-20 20:32:40" itemprop="dateCreated datePublished" datetime="2020-11-20T20:32:40+08:00">2020-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IO/" itemprop="url" rel="index"><span itemprop="name">IO</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>单纯 accept ， linux 系统已经解决了惊群的问题，通过<strong>只唤醒等待队列上的第一个进程或线程</strong></li>
<li>epoll 下的 accept 函数还是会有惊群，这是因为 epoll 下会， epoll wait 会唤醒所有的进程，当这些进程都去 accept 时，就会出现惊群现象。</li>
</ul>
<p><strong>IO 中的惊群指的是，多个进程同时去 accept 一个新来的连接，这会导致只有一个成功，另外几个失败。</strong></p>
<h2 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h2><p>我们已经知道了“惊群”是怎么回事，那么就按照上面的图编码实现看一下效果。我尝试使用多进程模型，创建一个父进程绑定一个端口监听socket，然后fork出多个子进程，子进程们开始循环处理（比如accept）这个socket。测试代码如下所示：</p>
<p>fork_s2.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IP   <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT  8888</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORKER 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">worker</span><span class="params">(<span class="type">int</span> listenfd, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am worker %d, begin to accept connection.\n&quot;</span>, i);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">        <span class="type">socklen_t</span> client_addrlen = <span class="keyword">sizeof</span>( client_addr );</span><br><span class="line">        <span class="type">int</span> connfd = accept( listenfd, ( <span class="keyword">struct</span> sockaddr* )&amp;client_addr, &amp;client_addrlen );</span><br><span class="line">        <span class="keyword">if</span> (connfd != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;worker %d accept a connection success.\t&quot;</span>, i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ip :%s\t&quot;</span>,inet_ntoa(client_addr.sin_addr));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;port: %d \n&quot;</span>,client_addr.sin_port);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;worker %d accept a connection failed,error:%s&quot;</span>, i, strerror(errno));</span><br><span class="line">            close(connfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton( AF_INET, IP, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = htons(PORT);</span><br><span class="line">    <span class="type">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; WORKER; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Create worker %d\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="comment">/*child  process */</span></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            worker(listenfd, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*wait child process*/</span></span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行，在本机上使用telnet 127.0.0.1 8888测试，结果如下所示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">|&gt;<span class="comment"># ./a.out </span></span><br><span class="line">Create worker 1</span><br><span class="line">Create worker 2</span><br><span class="line">I am worker 0, begin to accept connection.</span><br><span class="line">Create worker 3</span><br><span class="line">I am worker 1, begin to accept connection.</span><br><span class="line">Create worker 4</span><br><span class="line">I am worker 2, begin to accept connection.</span><br><span class="line">I am worker 3, begin to accept connection.</span><br><span class="line">worker 0 accept a connection success.	ip :127.0.0.1	port: 33141 </span><br><span class="line">I am worker 0, begin to accept connection.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>按照“惊群”现象，期望结果应该是4个子进程都会accpet到请求，其中只有一个成功，另外三个失败的情况。而实际的结果显示，父进程开始创建4个子进程，每个子进程开始等待accept连接。当telnet连接来的时候，只有worker2 子进程accpet到请求，而其他的三个进程并没有接收到请求。</p>
<p>这是什么原因呢？难道惊群现象是假的吗？于是赶紧google查一下，惊群到底是怎么出现的。</p>
<p>其实在Linux2.6版本以后，内核内核已经解决了accept()函数的“惊群”问题，大概的处理方式就是，当内核接收到一个客户连接后，<strong>只会唤醒等待队列上的第一个进程或线程</strong>。所以，如果服务器采用accept阻塞调用方式，在最新的Linux系统上，已经没有“惊群”的问题了。</p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>但是，对于实际工程中常见的服务器程序，大都使用select、poll或epoll机制，此时，服务器不是阻塞在accept，而是阻塞在select、poll或epoll_wait，这种情况下的“惊群”仍然需要考虑。接下来以epoll为例分析：</p>
<p>使用epoll非阻塞实现代码如下所示：epoll_et_fork_s.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IP   <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT  8888</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_NUM 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXEVENTS 64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">create_and_bind</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton( AF_INET, IP, &amp;serveraddr.sin_addr);</span><br><span class="line">    serveraddr.sin_port = htons(PORT);</span><br><span class="line">    bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">make_socket_non_blocking</span> <span class="params">(<span class="type">int</span> sfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> flags, s;</span><br><span class="line">    flags = fcntl (sfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (flags == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror (<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line">    s = fcntl (sfd, F_SETFL, flags);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror (<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">worker</span><span class="params">(<span class="type">int</span> sfd, <span class="type">int</span> efd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">/* The event loop */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> n, i;</span><br><span class="line">        n = epoll_wait(efd, events, MAXEVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;worker  %d return from epoll_wait!\n&quot;</span>, k);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((events[i].events &amp; EPOLLERR) || (events[i].events &amp; EPOLLHUP) || (!(events[i].events &amp;EPOLLIN))) &#123;</span><br><span class="line">                <span class="comment">/* An error has occured on this fd, or the socket is not ready for reading (why were we notified then?) */</span></span><br><span class="line">                <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;epoll error\n&quot;</span>);</span><br><span class="line">                close (events[i].data.fd);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sfd == events[i].data.fd) &#123;</span><br><span class="line">                <span class="comment">/* We have a notification on the listening socket, which means one or more incoming connections. */</span></span><br><span class="line">                <span class="keyword">struct</span> sockaddr in_addr;</span><br><span class="line">                <span class="type">socklen_t</span> in_len;</span><br><span class="line">                <span class="type">int</span> infd;</span><br><span class="line">                <span class="type">char</span> hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];</span><br><span class="line">                in_len = <span class="keyword">sizeof</span> in_addr;</span><br><span class="line">                infd = accept(sfd, &amp;in_addr, &amp;in_len);</span><br><span class="line">                <span class="keyword">if</span> (infd == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;worker %d accept failed!\n&quot;</span>, k);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;worker %d accept successed!\n&quot;</span>, k);</span><br><span class="line">                <span class="comment">/* Make the incoming socket non-blocking and add it to the list of fds to monitor. */</span></span><br><span class="line">                close(infd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sfd, s;</span><br><span class="line">    <span class="type">int</span> efd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span></span><br><span class="line">    sfd = create_and_bind();</span><br><span class="line">    <span class="keyword">if</span> (sfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">abort</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">    s = make_socket_non_blocking (sfd);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">abort</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">    s = listen(sfd, SOMAXCONN);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror (<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">    efd = epoll_create(MAXEVENTS);</span><br><span class="line">    <span class="keyword">if</span> (efd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    event.data.fd = sfd;</span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    s = epoll_ctl(efd, EPOLL_CTL_ADD, sfd, &amp;event);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Buffer where events are returned */</span></span><br><span class="line">    events = <span class="built_in">calloc</span>(MAXEVENTS, <span class="keyword">sizeof</span> event);</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; PROCESS_NUM; k++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Create worker %d\n&quot;</span>, k+<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            worker(sfd, efd, events, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">    <span class="built_in">free</span> (events);</span><br><span class="line">    close (sfd);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父进程中创建套接字，并设置为非阻塞，开始listen。然后fork出4个子进程，在worker中调用epoll_wait开始accpet连接。使用telnet测试结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Create worker <span class="number">1</span></span><br><span class="line">Create worker <span class="number">2</span></span><br><span class="line">Create worker <span class="number">3</span></span><br><span class="line">Create worker <span class="number">4</span></span><br><span class="line">worker  <span class="number">3</span> <span class="keyword">return</span> from epoll_wait!</span><br><span class="line">worker  <span class="number">2</span> <span class="keyword">return</span> from epoll_wait!</span><br><span class="line">worker <span class="number">3</span> accept successed!</span><br><span class="line">worker  <span class="number">1</span> <span class="keyword">return</span> from epoll_wait!</span><br><span class="line">worker <span class="number">2</span> accept failed!</span><br><span class="line">worker <span class="number">1</span> accept failed!</span><br><span class="line">worker  <span class="number">0</span> <span class="keyword">return</span> from epoll_wait!</span><br><span class="line">worker <span class="number">0</span> accept failed!</span><br></pre></td></tr></table></figure>

<p>从结果看出，与上面是一样的，只有一个进程接收到连接，其他三个没有收到，说明没有发生惊群现象。这又是为什么呢？</p>
<p>在早期的Linux版本中，内核对于阻塞在epoll_wait的进程，也是采用全部唤醒的机制，所以存在和accept相似的“惊群”问题。新版本的的解决方案也是<strong>只会唤醒等待队列上的第一个进程或线程</strong>，所以，新版本Linux <strong>部分的</strong>解决了epoll的“惊群”问题。所谓<strong>部分的</strong>解决，意思就是：对于部分特殊场景，使用epoll机制，已经不存在“惊群”的问题了，但是对于大多数场景，epoll机制仍然存在“惊群”。</p>
<h2 id="epoll-and-sleep"><a href="#epoll-and-sleep" class="headerlink" title="epoll and sleep"></a>epoll and sleep</h2><p>发现确实如上面那篇博客里所说，当我模拟发起一个请求时，只有一个或少数几个进程被唤醒了。也就是说，到目前为止，还没有得到一个确定的答案。但后来，在下面这篇博客中看到这样一个评论：<a target="_blank" rel="noopener" href="http://blog.csdn.net/spch2008/article/details/18301357">http://blog.csdn.net/spch2008/article/details/18301357</a></p>
<p><strong>这个总结，需要进一步阐述，你的实验，看上去是只有 1 个进程唤醒了，而事实上，其余进程没有被唤醒的原因是你的某个进程已经处理完这个 accept，内核队列上已经没有这个事件，无需唤醒其他进程。你可以在 epoll 获知这个 accept 事件的时候，不要立即去处理，而是 sleep 下，这样所有的进程都会被唤起。</strong></p>
<p>epoll存在惊群的场景如下：在worker保持工作的状态下，都会被唤醒，例如在epoll_wait后调用sleep一次。改写woker函数如下：epoll_et_fork_s2.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">worker</span><span class="params">(<span class="type">int</span> sfd, <span class="type">int</span> efd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">/* The event loop */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> n, i;</span><br><span class="line">        n = epoll_wait(efd, events, MAXEVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">/*keep running*/</span></span><br><span class="line">        sleep(<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;worker  %d return from epoll_wait!\n&quot;</span>, k); </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((events[i].events &amp; EPOLLERR) || (events[i].events &amp; EPOLLHUP) || (!(events[i].events &amp;EPOLLIN))) &#123;</span><br><span class="line">                <span class="comment">/* An error has occured on this fd, or the socket is not ready for reading (why were we notified then?) */</span></span><br><span class="line">                <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;epoll error\n&quot;</span>);</span><br><span class="line">                close (events[i].data.fd);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sfd == events[i].data.fd) &#123;</span><br><span class="line">                <span class="comment">/* We have a notification on the listening socket, which means one or more incoming connections. */</span></span><br><span class="line">                <span class="keyword">struct</span> sockaddr in_addr;</span><br><span class="line">                <span class="type">socklen_t</span> in_len;</span><br><span class="line">                <span class="type">int</span> infd;</span><br><span class="line">                <span class="type">char</span> hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];</span><br><span class="line">                in_len = <span class="keyword">sizeof</span> in_addr;</span><br><span class="line">                infd = accept(sfd, &amp;in_addr, &amp;in_len);</span><br><span class="line">                <span class="keyword">if</span> (infd == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;worker %d accept failed,error:%s\n&quot;</span>, k, strerror(errno));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;worker %d accept successed!\n&quot;</span>, k); </span><br><span class="line">                <span class="comment">/* Make the incoming socket non-blocking and add it to the list of fds to monitor. */</span></span><br><span class="line">                close(infd); </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试：telnet 127.0.0.1 8888</span></span><br><span class="line">|&gt;<span class="comment"># ./a.out </span></span><br><span class="line">Create worker 1</span><br><span class="line">Create worker 2</span><br><span class="line">Create worker 3</span><br><span class="line">Create worker 4</span><br><span class="line">worker  3 <span class="built_in">return</span> from epoll_wait!</span><br><span class="line">worker  2 <span class="built_in">return</span> from epoll_wait!</span><br><span class="line">worker  1 <span class="built_in">return</span> from epoll_wait!</span><br><span class="line">worker  0 <span class="built_in">return</span> from epoll_wait!</span><br><span class="line">worker 3 accept successed!</span><br><span class="line">worker 2 accept failed!</span><br><span class="line">worker 0 accept failed!</span><br><span class="line">worker 1 accept failed!</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/russell_tao/article/details/7204260">“惊群”，看看nginx是怎么解决它的</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Anker/p/7071849.html">Linux网络编程“惊群”问题总结</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-20671208-id-4935141.html">关于多进程epoll与“惊群”问题</a></p>
<p><a target="_blank" rel="noopener" href="https://pureage.info/2015/12/22/thundering-herd.html">accept 与 epoll 惊群</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/20/io/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%20epoll%20%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/20/io/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%20epoll%20%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">【IO】epoll 入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-20 20:32:39" itemprop="dateCreated datePublished" datetime="2020-11-20T20:32:39+08:00">2020-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-21 14:53:05" itemprop="dateModified" datetime="2022-01-21T14:53:05+08:00">2022-01-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IO/" itemprop="url" rel="index"><span itemprop="name">IO</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>网页逐渐替代了纸质媒体，成为了人们获取信息的主要渠道，每时每刻都有许多人在通过网页获取每日的最新资讯，从网页的角度出发，虽然连接的数量可能非常多，但并非每路连接都时时在与服务器交互信息，换言之，对某个网页的服务器来说，多路连接中活跃用户的数量可能远远小于连接的总数。</p>
<p>假如使用select或poll模型搭建此种类型的服务器，对服务器而言，大部分的时间都浪费在了毫无意义的轮询中，真正处理请求的时间反而少之又少。（<strong>连接数太多了，每次轮序，有数据的连接可能就1-2个</strong>）</p>
<p>Linux系统中通常使用epoll模型搭建这种活跃连接较少的服务器，相比select&#x2F;poll的主动查询，<strong>epoll模型采用基于事件的通知方式，事先为建立连接的文件描述符注册事件，一旦该文件描述符就绪，内核会采用类似callback的回调机制，将文件描述符加入到epoll的指定的文件描述符集中，之后进程再根据该集合中文件描述符的数量，对客户端请求逐一进行处理。</strong></p>
<p>虽然epoll机制中返回的同样是就绪文件描述符的数量，但epoll中的文件描述符集只存储了就绪的文件描述符，服务器进程无需再扫描所有已连接的文件描述符；且epoll机制使用内存映射机制（类似共享内存），不必再将内核中的文件描述符集复制到内存空间；此外，epoll机制不受进程可打开最大文件描述符数量的限制（只与系统内存有关），可连接远超过默认FD_SETSIZE的进程。</p>
<p>linux系统中提供了几个与实现epoll机制相关的系统调用——epoll_create()、epoll_ctl()和epoll_wait()，下面将对这些系统调用逐一进行讲解。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// epoll 的 API 非常简洁，涉及到的只有 3 个系统调用：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>; <span class="comment">// int epoll_create1(int flags);</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，epoll_create 创建一个 epoll 实例并返回 epollfd；</p>
<p>epoll_ctl 注册 file descriptor 等待的 I&#x2F;O 事件(比如 EPOLLIN、EPOLLOUT 等) 到 epoll 实例上；</p>
<p>epoll_wait 则是阻塞监听 epoll 实例上所有的 file descriptor 的 I&#x2F;O 事件，<strong>它接收一个用户空间上的一块内存地址 (events 数组)，kernel 会在有 I&#x2F;O 事件发生的时候把文件描述符列表复制到这块内存地址上，然后 epoll_wait 解除阻塞并返回，最后用户空间上的程序就可以对相应的 fd 进行读写了</strong>：</p>
<h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h3><p>epoll_create()函数用于创建一个epoll句柄，并请求内核为该实例后期需存储的文件描述符及对应事件预先分配存储空间，该函数存在于函数库sys&#x2F;poll.h中，其声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>函数中的参数size为在该epoll中<strong>可监听的文件描述符的最大个数</strong>，若该函数调用成功，将返回一个用于引用epoll的句柄；若调用失败，则返回-1，并设置errno。</p>
<p>当所有与该epoll相关的文件描述符都关闭后，内核会销毁epoll实例并释放相关资源，但若该函数返回的epoll句柄不再被使用，用户应主动调用close()函数将其关闭。</p>
<h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h3><p>epoll_ctl()是epoll的事件注册函数，用于将文件描述符添加到epoll的文件描述符集中，或从集合中删除指定文件描述符。该函数存在于函数库sys&#x2F;poll.h中，其声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure>

<p>epoll_ctl()函数中的参数epfd为函数epoll_create()返回的epoll句柄；参数op表示epoll_ctl()的动作，该动作的取值由三个宏指定，这些宏及其含义分别如下：</p>
<p>● EPOLL_CTL_ADD表示epoll_ctl()将会在epfd中为新fd注册事件；</p>
<p>● EPOLL_CTL_MOD表示epoll_ctl()将会修改已注册的fd监听事件；</p>
<p>● EPOLL_CTL_DEL表示epoll_ctl()将会删除epfd中监听的fd。</p>
<p>epoll_ctl()函数的参数fd用于指定待操作的文件描述符；参数event用于设定要监听的事件，该参数是一个struct epoll_event类型的指针，用于传入一个struct epoll_event结构体类型的数组，该结构体的类型定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="type">__uint32_t</span>  events;   <span class="comment">//epoll事件</span></span><br><span class="line">  <span class="type">epoll_data_t</span> data;    <span class="comment">//用户数据变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct epoll_event结构体中的成员events表示要监控的事件，该成员可以是由一些单一事件组成的位集，这些单一事件由一组宏表示，宏及其含义分别如下：</p>
<p>● EPOLLIN表示监控文件描述符fd的读事件（包括socket正常关闭）；</p>
<p>● EPOLLOUT表示监控fd的写事件；</p>
<p>● EPOLLPRI表示监控fd的紧急可读事件（有优先数据到达时触发）；</p>
<p>● EPOLLERR表示监控fd的错误事件；</p>
<p>● EPOLLHUP表示监控fd的挂断事件；</p>
<p>● EPOLLET表示将epoll设置为边缘触发（Edge Triggered）模式；</p>
<p>● EPOLLONESHOT表示只监听一次事件，当此次事件监听完成后，若要再次监听该fd，需将其再次添加到epoll队列中。</p>
<p>struct epoll_event结构体成员data的数据类型是共用体epoll_data_t，其类型定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">  <span class="type">void</span>    *ptr;</span><br><span class="line">  <span class="type">int</span>     fd;</span><br><span class="line">  <span class="type">__uint32_t</span>  u32;</span><br><span class="line">  <span class="type">__uint64_t</span>  u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>

<p>可根据程序需要选择不同的成员，后续的案例中将以fd为例进行示范。</p>
<p>若epoll_ctl()函数调用成功时会返回0；若调用失败，则返回-1，并设置errno。不同于select&#x2F;poll机制在监听事件时才确定事件的类型，epoll机制在连接建立后便会指定要监控的事件。</p>
<h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h3><p>epoll_wait()函数用于等待epoll句柄epfd中所监控事件的发生，当有一个或多个事件发生或等待超时后epoll_wait()返回，该函数存在于函数库sys&#x2F;epoll.h中，其声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数epfd为epoll_create()函数返回的句柄；</li>
<li>参数events指向发生epoll_create()调用时系统事先预备的空间，当有监听的事件发生时，内核会将该事件复制到此段空间中；</li>
<li>参数maxevents表示events的大小，该值不能超过调用epoll_create()时所传参数size的大小；</li>
<li>参数timeout的单位为毫秒，用于设置epoll_wait()的工作方式：若设置为0则立即返回，设置为-1则使epoll无限期等待，设置为大于0的值表示epoll等待一定的时长。</li>
</ul>
<p>若epoll_wait()函数调用成功时返回就绪文件描述符的数量；若等待超时后并无就绪文件描述符则返回0；若调用失败则返回-1，并设置errno。</p>
<h2 id="epoll-的原理"><a href="#epoll-的原理" class="headerlink" title="epoll 的原理"></a>epoll 的原理</h2><p>在实现上 epoll 采用红黑树来存储所有监听的 fd，而红黑树本身插入和删除性能比较稳定，时间复杂度 O(logN)。通过 epoll_ctl 函数添加进来的 fd 都会被放在红黑树的某个节点内，所以，重复添加是没有用的。当把 fd 添加进来的时候时候会完成关键的一步：<strong>该 fd 会与相应的设备（网卡）驱动程序建立回调关系，也就是在内核中断处理程序为它注册一个回调函数，在 fd 相应的事件触发（中断）之后（设备就绪了），内核就会调用这个回调函数，该回调函数在内核中被称为： ep_poll_callback ，这个回调函数其实就是把这个 fd 添加到 rdllist 这个双向链表（就绪链表）中。epoll_wait 实际上就是去检查 rdllist 双向链表中是否有就绪的 fd，当 rdllist 为空（无就绪 fd）时挂起当前进程，直到 rdllist 非空时进程才被唤醒并返回。</strong></p>
<p>相比于 select&amp;poll 调用时会将全部监听的 fd 从用户态空间拷贝至内核态空间并线性扫描一遍找出就绪的 fd 再返回到用户态，epoll_wait 则是直接返回已就绪 fd，因此 epoll 的 I&#x2F;O 性能不会像 select&amp;poll 那样随着监听的 fd 数量增加而出现线性衰减，是一个非常高效的 I&#x2F;O 事件驱动技术。</p>
<p>由于使用 epoll 的 I&#x2F;O 多路复用需要用户进程自己负责 I&#x2F;O 读写，从用户进程的角度看，读写过程是阻塞的，所以 select&amp;poll&amp;epoll 本质上都是同步 I&#x2F;O 模型，而像 Windows 的 IOCP 这一类的异步 I&#x2F;O，只需要在调用 WSARecv 或 WSASend 方法读写数据的时候把用户空间的内存 buffer 提交给 kernel，kernel 负责数据在用户空间和内核空间拷贝，完成之后就会通知用户进程，整个过程不需要用户进程参与，所以是真正的异步 I&#x2F;O。</p>
<p>epoll 在 Linux kernel 里并没有使用 mmap 来做用户空间和内核空间的内存共享，所以那些说 epoll 使用了 mmap 的文章都是误解。</p>
<h2 id="epoll-的工作模式"><a href="#epoll-的工作模式" class="headerlink" title="epoll 的工作模式"></a>epoll 的工作模式</h2><p>epoll有两种工作模式，分别为边缘触发（Edge Triggered）模式和水平触发（LevelTriggered）模式。</p>
<p><strong>所谓边缘触发，指只有当文件描述符就绪时会触发通知，即便此次通知后系统执行I&#x2F;O操作只读取了部分数据，文件描述符中仍有数据剩余，也不会再有通知递达，直到该文件描述符从当前的就绪态变为非就绪态，再由非就绪态再次变为就绪态，才会触发第二次通知；此外，接收缓冲区大小为5字节，也就是说ET模式下若只进行一次I&#x2F;O操作，每次只能接收到5字节的数据。因此系统在收到就绪通知后，应尽量多次地执行I&#x2F;O操作，直到无法再读出数据为止。</strong></p>
<p><strong>而水平触发与边缘触发有所不同，即便就绪通知已发送，内核仍会多次检测文件描述符状态，只要文件描述符为就绪态，内核就会继续发送通知。</strong></p>
<p>epoll的工作模式在调用注册函数epoll_ctl()时确定，由该函数中参数event的成员events指定，默认情况下epoll的工作模式为水平触发，若要将其设置为边缘触发模式，需使用宏EPOLLET对event进行设置，具体示例如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.events=EPOLLIN|EPOLLET;</span><br></pre></td></tr></table></figure>

<p>之后需在循环中不断调用，保证将文件描述符中的数据全部读出。</p>
<p>epoll_s.c 中的epoll便工作在水平模式下，为帮助读者理解，下面给出具体案例，来展示epoll在边缘触发模式下如何实现双端通信。ET模式只能工作在非阻塞模式下，否则单纯使用epoll（单进程）将无法同时处理多个文件描述符，因此在实现案例之前，需先掌握设置文件描述符状态的方法，Linux系统中可使用fcntl()函数来设置文件描述符的属性。</p>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>这两种模式的实现原理：当我们调用epoll_wait的时候，会把就绪链表拷贝到用户态，然后就会清空链表。最后epoll_wait会检查这些返回的socket，如果是LT模式，如果socket还有未被处理的数据，那么会把这个socket继续添加到就绪列表，而ET则没有这个过程。</p>
<h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h3><p>fcntl()函数是Linux中的一个系统调用，其功能为获取或修改已打开文件的性质，该函数存在于函数库fcntl.h中，其声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br></pre></td></tr></table></figure>

<p>其中参数fd为被操作的文件描述符，cmd为操作fd的命令（具体取值可参见Linux的manpage），之后的arg用来接收命令cmd所需使用的参数，该值可为空。</p>
<p>若要通过fcntl()设置文件描述符状态，通常先使用该函数获取fd的当前状态，再对获取的值进行位操作，最后调用fcntl()将操作的结果重新写回文件描述符。如下为修改文件描述符阻塞状态的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag = fcntl(fd, F_GETFL);   <span class="comment">//宏F_GETEL表示获取文件描述符相关属性</span></span><br><span class="line">flag |= O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, flag);   <span class="comment">//使用新属性设置文件描述符</span></span><br></pre></td></tr></table></figure>

<p>函数执行失败，将返回-1并设置errno全局变量来指明错误。</p>
<h4 id="fcntl-常见指令"><a href="#fcntl-常见指令" class="headerlink" title="fcntl 常见指令"></a>fcntl 常见指令</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">F_DUPFD     <span class="comment">//复制文件描述符，跟dup()函数功能一样</span></span><br><span class="line">F_GETFD     <span class="comment">//获取文件描述符标志</span></span><br><span class="line">F_SETFD     <span class="comment">//设置文件描述符标志</span></span><br><span class="line">F_GETFL     <span class="comment">//获取文件状态</span></span><br><span class="line">F_SETFL     <span class="comment">//设置文件状态</span></span><br></pre></td></tr></table></figure>

<h4 id="使用fcntl对文件加锁"><a href="#使用fcntl对文件加锁" class="headerlink" title="使用fcntl对文件加锁"></a>使用fcntl对文件加锁</h4><p>当fcntl中的cmd为F_GETLK,F_SETLK,F_SELFKW时为对文件进行锁操作，此时arg参数为flock。注意：<strong>使用fcntl对文件加锁，加锁效果类似于自旋锁，只有写写互斥和读写互斥，读读并不互斥。</strong></p>
<h2 id="epoll-配合多进程或线程池"><a href="#epoll-配合多进程或线程池" class="headerlink" title="epoll 配合多进程或线程池"></a>epoll 配合多进程或线程池</h2><p>多进程&#x2F;多线程可单独使用，也可与I&#x2F;O多路转接服务器结合，通过转接机制监控客户端程序状态，通过多进程&#x2F;多线程处理用户请求，以期减少资源消耗，提升服务器效率。</p>
<p>然而大多网络端服务器都有一个特点，即单位时间内需处理的连接请求数目虽然巨大，但处理时间却是极短的，如此，若使用多进程&#x2F;多线程机制结合I&#x2F;O多路转接机制搭建的服务器，便需在每时每刻不停地创建、销毁进程或线程，虽说相对进程，线程消耗的资源已相当少，但诸多线程同时创建和销毁，其开销仍是不可忽视的。而Linux系统中的线程池机制便能客服这些问题。</p>
<p>所谓线程池（Thread Pool），简单来说，就是一个用来放置线程的“池子”。线程池的实现原理如下：当服务器程序启动后，预先在其中创建一定数量的线程，并将这些线程依次加入队列中。在没有客户端请求抵达时，线程队列中的线程都处于阻塞状态，此时这些线程只占用一些内存，但不占用cpu。若随后有用户请求到达，由线程池从线程队列中选出一个空闲线程，并将用户请求传给选出的线程，由该线程完成用户请求。用户请求处理完毕，该线程并不退出，而是再次被加入线程队列，等待下一次任务。此外，若线程队列中处于阻塞状态的线程较多，为节约资源，线程池会自动销毁一部分线程；若线程队列中所有线程都有任务执行，线程池会自动创建一定数量的新线程，以提高服务器效率。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://book.itheima.net/course/223/1277519158031949826/1277529181294436354">epoll</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/20/io/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%20poll%20%E5%85%A5%E9%97%A8%20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/20/io/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%20poll%20%E5%85%A5%E9%97%A8%20/" class="post-title-link" itemprop="url">IO多路复用 poll 入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-20 20:32:38" itemprop="dateCreated datePublished" datetime="2020-11-20T20:32:38+08:00">2020-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IO/" itemprop="url" rel="index"><span itemprop="name">IO</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>poll机制的工作原理及流程与select类似，但poll可监控的进程数量不受select中第二个因素——fd_set集合容量的限制，用户可在程序中自行设置被监测的文件描述符集的容量，当然poll在阻塞模式下也采用轮询的方式监测文件描述符集，因此应合理设置poll中监控进程的数量。poll机制主要通过poll()函数实现，下面对poll()函数进行讲解。</p>
<p><strong>poll和select基本上可以认为，唯一的区别就是 pool 没有 FD_SETSIZE 的限制，用户可自定义打开的连接数量，其他的都完全一样，如何阻塞</strong></p>
<h2 id="poll-系统调用"><a href="#poll-系统调用" class="headerlink" title="poll 系统调用"></a>poll 系统调用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>poll()函数中参数fds是一个struct pollfd类型的指针，主要用于传入被监测的多个文件描述符，其数据类型struct pollfd的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> fd;       <span class="comment">//文件描述符</span></span><br><span class="line">  <span class="type">short</span> events;   <span class="comment">//等待的事件</span></span><br><span class="line">  <span class="type">short</span> revents;   <span class="comment">//实际发生的事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该结构体中的成员fd表示文件描述符，当将fd设置为-1时，表示取消对该文件描述符的监测；成员events用于设置程序等待的事件，该值由用户主动设置；成员revents用于设置文件描述符的操作结果对应的事件，该值在函数返回时被设置。poll可能涉及的事件及其对应的宏如表1所示。</p>
<table>
<thead>
<tr>
<th><strong>事件</strong></th>
<th><strong>事件说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>POLLIN</td>
<td>文件描述符中有数据可读（包括普通数据或优先数据）</td>
</tr>
<tr>
<td>POLLRDNORM</td>
<td>文件描述符中有普通数据可读</td>
</tr>
<tr>
<td>POLLRDBAND</td>
<td>文件描述符中有优先数据可读</td>
</tr>
<tr>
<td>POLLPRI</td>
<td>文件描述符中高优先级数据可读</td>
</tr>
<tr>
<td>POLLOUT</td>
<td>文件描述符中有数据可写（包括普通数据或优先数据）</td>
</tr>
<tr>
<td>POLLWRNORM</td>
<td>文件描述符中可写入普通数据</td>
</tr>
<tr>
<td>POLLWRBAND</td>
<td>文件描述符中可写入优先数据</td>
</tr>
<tr>
<td>POLLERR</td>
<td>发生错误事件</td>
</tr>
<tr>
<td>POLLHUP</td>
<td>发生挂起事件</td>
</tr>
<tr>
<td>POLLNVAL</td>
<td>非法请求</td>
</tr>
</tbody></table>
<p>poll()函数中的参数nfds等同于select()函数中的参数nfds，用来设置pollt监控的文件描述符的范围，需设置为文件描述符最大值加1；</p>
<p>参数timeout与select()函数中的参数timeout，都用于设置组设时长，但其取值略有差异，poll()函数中参数timeout的取值及其对应含义如下：</p>
<p>● 当timeout&#x3D;-1时，poll()函数阻塞等待；</p>
<p>● 当timeout&#x3D;0时，poll()函数将立即返回，以轮询的方式监测文件描述符表；</p>
<p>● 当timeout&gt;0时，等待指定时长（单位为毫秒，若当前系统时间精度不够毫秒则向上取值）。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>poll()函数若调用成功将返回就绪文件描述符数量；若等待超时，将返回0，表示没有已就绪的文件描述符；若调用出错，将返回-1，并设置errno。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://book.itheima.net/course/223/1277519158031949826/1277529226395787267">pool</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/20/io/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%20select%20%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/20/io/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%20select%20%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">IO多路复用 select 入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-20 20:32:37" itemprop="dateCreated datePublished" datetime="2020-11-20T20:32:37+08:00">2020-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IO/" itemprop="url" rel="index"><span itemprop="name">IO</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>使用select搭建的多路I&#x2F;O转接服务器是一种基于非阻塞的服务器：当有客户端连接请求到达时，accept会返回一个文件描述符，该文件描述符会被存储到由select监控的文件描述符表中，每个文件描述符对应的文件都可进行I&#x2F;O操作，因此select可通过监控表中各个文件描述符，来获取对应的客户端I&#x2F;O状态。若每路程序中都没有数据到达，线程将阻塞在select上；否则select将已就绪客户端程序的数量返回到服务器。</p>
<p><strong>不阻塞是指不阻塞在 accept 系统调用上， 也不阻塞在 read 系统调用上（因为数据已经准备好了）， 而是阻塞在 select 系统调用上。</strong> 开始时， 系统阻塞在 select系统调用中。一个数据包过来，如果是请求建立连接的， 那么走 accept 系统调用，得到 connFd， 并注册到 select 监控的 文件描述符列表中。如果是建立好的连接发来的数据包，那么遍历文件描述符集，处理已就绪的文件描述符。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/DKnEQ0"><img src="https://s3.ax1x.com/2020/11/19/DKnEQ0.png" alt="DKnEQ0.png"></a></p>
<h2 id="select-系统调用"><a href="#select-系统调用" class="headerlink" title="select 系统调用"></a>select 系统调用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>nfds用来设置select监控的文件描述符的范围，需设置为文件描述符最大值加1</li>
<li>参数readfds、writefds、exceptfds分别用于表示可读取数据的文件描述符集、可写入数据的文件描述符集以及发生异常的文件描述符集，它们都为传入传出参数，其参数类型<strong>fd_set实质为长整型，这些集合中的每一位都对应一个文件描述符的状态</strong>，若集合参数被设置为NULL，表示不关心文件的对应状态。</li>
<li>select()函数的返回值有3种：若返回值大于0，表示已就绪文件描述符的数量，此种情况下某些文件可读写或有错误信息；若返回值等于0，表示等待超时，没有可读写或错误的文件；若返回值-1，表示出错返回，同时errno将被设置。</li>
</ul>
<p>参数timeout用于设置select的阻塞时长，其取值有如下几种情况：</p>
<p>● 若timeval&#x3D;NULL，表示永远等待；</p>
<p>● 若timeval&gt;0，表示等待固定时长；</p>
<p>● 若timeval&#x3D;0，select将在检查过指定文件描述符后立即返回（轮询）。</p>
<h3 id="文件描述符集操作函数"><a href="#文件描述符集操作函数" class="headerlink" title="文件描述符集操作函数"></a>文件描述符集操作函数</h3><table>
<thead>
<tr>
<th><strong>函数声明</strong></th>
<th><strong>函数功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>void FD_CLR(int fd,fd_set *set);</td>
<td>将集合中的文件描述符fd清除（将fd位置为0）</td>
</tr>
<tr>
<td>int FD_ISSET(int fd,fd_set *set);</td>
<td>测试集合中文件描述符fd是否存在于集合中，若存在则返回非0</td>
</tr>
<tr>
<td>void FD_SET(int fd,fd_set *set);</td>
<td>将文件描述符fd添加到集合中（将fd位置为1）</td>
</tr>
<tr>
<td>void FD_ZERO(fd_set *set);</td>
<td>清除集合中所有的文件描述符（所有位置0）</td>
</tr>
</tbody></table>
<h2 id="select-模式存在的问题"><a href="#select-模式存在的问题" class="headerlink" title="select 模式存在的问题"></a>select 模式存在的问题</h2><h3 id="超大数据包或超长的处理时间导致连接饿死"><a href="#超大数据包或超长的处理时间导致连接饿死" class="headerlink" title="超大数据包或超长的处理时间导致连接饿死"></a>超大数据包或超长的处理时间导致连接饿死</h3><p>因为我们知道，当建立好的连接连接发来数据包时，服务会去处理这个数据包，而不是阻塞在系统调用上，那么如果这个数据包的处理时间非常长，比如说1个小时，那么整个服务这一个小时内既不能处理新建连接的数据包，也不能处理已建立的连接发来的数据包。对于不能处理新建连接的数据包的情况，如果新建连接的数量超过<strong>全连接队列的长度</strong>，就会导致新建连接直接拒绝。</p>
<h3 id="数量有限"><a href="#数量有限" class="headerlink" title="数量有限"></a>数量有限</h3><p>select可监控的文件数量是有限的，该数量受到两个因素的限制。第一个因素是进程可打开的文件数量，第二个因素是select中的集合fd_set的容量。进程可打开文件的上限可通过ulimit –n命令或setrlimit函数设置，但系统所能打开的最大文件数也是有限的；select中集合fd_set的容量由宏FD_SETSIZE（定义在linux&#x2F;posix_types.h中）指定，一般为1024，但即便通过重新编译内核的方式修改FD_SETSIZE，也不一定能提升select服务器的性能，因为若select一次监测的进程过多，单轮询便要耗费大量的时间。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>go-science&#x2F;example&#x2F;cpp&#x2F;io&#x2F;select_s.c</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://book.itheima.net/course/223/1277519158031949826/1277529226395787268">select</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/skyfsm/p/7079458.html">还没有看</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/19/io/IO%20%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/19/io/IO%20%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">IO 入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-19 21:33:42" itemprop="dateCreated datePublished" datetime="2020-11-19T21:33:42+08:00">2020-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IO/" itemprop="url" rel="index"><span itemprop="name">IO</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在神作《UNIX 网络编程》里，总结归纳了 5 种 I&#x2F;O 模型，包括同步和异步 I&#x2F;O：</p>
<ul>
<li>阻塞 I&#x2F;O (Blocking I&#x2F;O)</li>
<li>非阻塞 I&#x2F;O (Nonblocking I&#x2F;O)</li>
<li>I&#x2F;O 多路复用 (I&#x2F;O multiplexing)</li>
<li>信号驱动 I&#x2F;O (Signal driven I&#x2F;O)</li>
<li>异步 I&#x2F;O (Asynchronous I&#x2F;O)</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/DtXgAJ"><img src="https://s3.ax1x.com/2020/11/24/DtXgAJ.md.png" alt="DtXgAJ.md.png"></a></p>
<h2 id="阻塞IO-Blocking-I-x2F-O"><a href="#阻塞IO-Blocking-I-x2F-O" class="headerlink" title="阻塞IO (Blocking I&#x2F;O)"></a>阻塞IO (Blocking I&#x2F;O)</h2><p>阻塞型IO指的是进程的IO的系统调用(recv())，会导致这个系统阻塞在这个系统调用上，直到有数据到来且系统准备好了数据之后，系统才能继续处理数据，阻塞型IO一个线程只能处理一个请求。阻塞型IO为了能同时处理多个请求，一般通过多线程技术来实现。但是线程的成本其实很高，所以阻塞模型并不是很适用高并发的场景。</p>
<h2 id="非阻塞IO（non-blocking-IO）"><a href="#非阻塞IO（non-blocking-IO）" class="headerlink" title="非阻塞IO（non-blocking IO）"></a>非阻塞IO（non-blocking IO）</h2><p>Linux下，可以通过设置socket使其变为non-blocking。非阻塞就很简单了，就是服务器不断去忙轮询系统调用(反复调用recv()，因为non-blocking的IO如果数据没有准备好，会立即返回)。 可以看到服务器线程可以通过循环调用recv()接口，可以在单个线程内实现对所有连接的数据接收工作。但是上述模型绝不被推荐。因为，循环调用recv()将大幅度推高CPU 占用率；此外，在这个方案中recv()更多的是起到检测“操作是否完成”的作用，实际操作系统提供了更为高效的检测“操作是否完成“作用的接口，例如select()多路复用模式，可以一次检测多个连接是否活跃。</p>
<h2 id="多路复用IO（IO-multiplexing）-事件驱动-IO"><a href="#多路复用IO（IO-multiplexing）-事件驱动-IO" class="headerlink" title="多路复用IO（IO multiplexing）(事件驱动 IO)"></a>多路复用IO（IO multiplexing）(事件驱动 IO)</h2><p>这种IO方式为事件驱动IO(event driven IO)。select或者epoll类型的IO，当你调用select()函数时，进程会被阻塞直到有数据准备完成。数据准备完成后，需要再调用recv()函数来从系统中接受数据到用户进程（注意这是两次系统调用，一次是阻塞，一次及时返回）。IO多路复用，虽然有一个阻塞的地方，但是多路复用IO依然支持海量并发请求，这是因为，select这个系统调用会让系统内核监视select负责的所有的socket，一旦有数据准备好，就停止这个阻塞，并返回ok，然后用户进程可以再次发起请求，拿取数据。IO多路复用是一种极其高效的IO模型，使用IO多路复用，在高并发的情况下，一个进程能够将CPU的使用发挥到极致（如果在用户进程中有阻塞的地方下面会说）。但是IO多路复用不能充分发挥多核cpu的优点，因为它只使用了一个cpu（不同于多线程+阻塞IO），所以，通常的做法是多进程+多路复用IO，例如nginx和tornado。</p>
<p>如果在用户进程中存在阻塞的地方，那么多路复用IO的效果将大打折扣，所以nginx的主要作用就是做转发。而tornado为自己作为client去请求其他服务器时，可以开启协程模式（异步请求框架!）。熟悉go的开发者应该知道，如果有多个IO读取，多个网络请求，那么，最好是开启多个协程，通过管道来实现数据回流，这能最大化避免阻塞带来的时间消耗。</p>
<p>在多路复用模型中，对于每一个socket，一般都设置成为non-blocking，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。因此select()与非阻塞IO类似。</p>
<p>使用select搭建的服务流程，如果select()发现某句柄捕捉到了“可读事件”，服务器程序应及时做recv()操作，并根据接收到的数据准备好待发送数据，并将对应的句柄值加入writefds，准备下一次的“可写事件”的select()探测。同样，如果select()发现某句柄捕捉到“可写事件”，则程序应及时做send()操作，并准备好下一次的“可读事件”探测准备。</p>
<h3 id="多路复用IO的缺点"><a href="#多路复用IO的缺点" class="headerlink" title="多路复用IO的缺点"></a>多路复用IO的缺点</h3><p>缺点1：该模型将事件探测和事件响应夹杂在一起，一旦事件响应的执行体庞大，则对整个模型是灾难性的。真实案例，线上的tornado服务，和文件上传，下载的服务放在了一起，大量的用时极长的上传下载操作阻塞了所有的进程，最终导致整个服务死掉。</p>
<p>缺点2：select()接口并不是实现“事件驱动”的最好选择。因为当需要探测的句柄值较大时，select()接口本身需要消耗大量时间去轮询各个句柄。很多操作系统提供了更为高效的接口，如linux提供了epoll，BSD提供了kqueue，Solaris提供了&#x2F;dev&#x2F;poll。<strong>epoll和select相比好的地方在于，epoll会向每一个socket注册回调，一旦socket数据准备完成，就会通知epoll()函数，epoll函数再返回，好处就是轮训少了一点，但是阻塞还是在的。</strong></p>
<h2 id="信号驱动-I-x2F-O-Signal-driven-I-x2F-O"><a href="#信号驱动-I-x2F-O-Signal-driven-I-x2F-O" class="headerlink" title="信号驱动 I&#x2F;O (Signal driven I&#x2F;O)"></a>信号驱动 I&#x2F;O (Signal driven I&#x2F;O)</h2><p>信号驱动IO（signal-driven IO），使用信号机制，让内核在描述符就绪时发送SIGIO信号通知用户进程。整个过程是先通过sigaction系统调用安装一个信号处理函数。该系统调用将立即返回，用户进程继续工作，也就是说它没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号，我们随后可以在信号处理函数中调用recvfrom读取内核空间准备好的数据。特点：第一阶段(等待数据报到达期间)进程不被阻塞。</p>
<p>从上图中可以看出，信号驱动IO第一步非阻塞，通过sigaction系统调用达到目标。</p>
<h2 id="异步-I-x2F-O-Asynchronous-I-x2F-O"><a href="#异步-I-x2F-O-Asynchronous-I-x2F-O" class="headerlink" title="异步 I&#x2F;O (Asynchronous I&#x2F;O)"></a>异步 I&#x2F;O (Asynchronous I&#x2F;O)</h2><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<h2 id="IO总结"><a href="#IO总结" class="headerlink" title="IO总结"></a>IO总结</h2><p>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还在准备数据的情况下会立刻返回。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</span><br><span class="line"></span><br><span class="line">An asynchronous I/O operation does not cause the requesting process to be blocked;</span><br></pre></td></tr></table></figure>

<h2 id="tornado"><a href="#tornado" class="headerlink" title="tornado"></a>tornado</h2><p>tornado 作为服务端，其编程模式是多进程+IO多路复用，这种编程模型的好处是能支持10k及以上的并发请求，缺点是一旦一个请求占用时间过长，那么整个系统的可能因为其他请求直接死掉，因为没有其他的线程(worker)来工作了。tornado作为请求的client（tornado也是一个http请求库），他可以实现异步请求。</p>
<p>关于tornado（python的一个web框架），很多文章都在说它是一个异步框架啦，巴拉巴拉，这句话其实不对（只对了一半的话能叫对吗？）官方的说法其实很明显了，tornado是一个非阻塞的web框架（作为服务端，non-blocking不等于异步哦），同时是一个异步请求库（作为客户端的库）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tornado is a Python web framework and asynchronous networking library, originally developed at FriendFeed. By using non-blocking network I/O, Tornado can scale to tens of thousands of open connections, making it ideal for long polling, WebSockets, and other applications that require a long-lived connection to each user.</span><br></pre></td></tr></table></figure>

<p>tornado 实际上和nginx是一个编程模型，优先使用IO多路复用的IO模型(select, epoll)，但是请注意，IO多路复用不是异步IO！IO多路复用的显著特点是这种IO模型可以让系统调用<strong>同时</strong>管理数以万计的请求，实现单进程也可以支持大量并发请求的特性！IO多路复用的模型很应该和Nonblocking IO做对比，实际上IO多路复用是另一种形式的Nonblocking IO。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-28458801-id-4464639.html">http://blog.chinaunix.net/uid-28458801-id-4464639.html</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/tornadoweb/tornado">https://github.com/tornadoweb/tornado</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/11/learn/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%9A%E5%8A%A1%E5%B9%82%E7%AD%89%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/11/learn/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%9A%E5%8A%A1%E5%B9%82%E7%AD%89%E6%80%A7/" class="post-title-link" itemprop="url">如何保证业务的幂等性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-11 20:35:00" itemprop="dateCreated datePublished" datetime="2020-11-11T20:35:00+08:00">2020-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="什么是幂等性"><a href="#什么是幂等性" class="headerlink" title="什么是幂等性"></a>什么是幂等性</h2><p>幂等性是系统服务对外一种承诺，承诺只要调用接口成功，外部多次调用对系统的影响是一致的。声明为幂等的服务会认为外部调用失败是常态，并且<strong>失败之后必然会有重试（如何保证重复请求的幂等性）</strong>。</p>
<h2 id="什么情况下需要幂等"><a href="#什么情况下需要幂等" class="headerlink" title="什么情况下需要幂等"></a>什么情况下需要幂等</h2><p>以SQL为例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无论执行多少次都不会改变状态，是天然的幂等。</span></span><br><span class="line">SELECT col1 FROM tab1 WHER col2=2;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 无论执行成功多少次状态都是一致的，因此也是幂等操作。</span></span><br><span class="line">UPDATE tab1 SET col1=1 WHERE col2=2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次执行的结果都会发生变化，这种不是幂等的。</span></span><br><span class="line">UPDATE tab1 SET col1=col1+1 WHERE col2=2;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如userid为唯一主键，即重复操作上面的业务，只会插入一条用户数据，具备幂等性。如userid不是主键，可以重复，那上面业务多次操作，数据都会新增多条，不具备幂等性。</span></span><br><span class="line">INSERT into user(userid,name) values(1,<span class="string">&#x27;a&#x27;</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多次操作，结果一样，具备幂等性</span></span><br><span class="line">delete from user <span class="built_in">where</span> userid=1;</span><br></pre></td></tr></table></figure>

<p><strong>一些 update 操作，所有的 insert 操作，不是天然的幂等性，需要一些逻辑来保证幂等性</strong></p>
<h2 id="如何保证幂等性"><a href="#如何保证幂等性" class="headerlink" title="如何保证幂等性"></a>如何保证幂等性</h2><h3 id="token-机制"><a href="#token-机制" class="headerlink" title="token 机制"></a>token 机制</h3><ul>
<li>服务端提供了发送token的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取token，服务器会把token保存到redis中。</li>
<li>然后调用业务接口请求时，把token携带过去，一般放在请求头部。</li>
<li>服务器判断token是否存在redis中，存在表示第一次请求，然后删除token,继续执行业务。</li>
<li>如果判断token不存在redis中，就表示是重复操作，直接返回重复标记给client，这样就保证了业务代码，不被重复执行。</li>
</ul>
<p>token机制的核心就是，一个请求过来，server 会先检查这个请求是否需要处理，没有传token或者token不在redis中则不用处理。</p>
<h4 id="先删除token，还是后删除token（update-insert）"><a href="#先删除token，还是后删除token（update-insert）" class="headerlink" title="先删除token，还是后删除token（update, insert）"></a>先删除token，还是后删除token（update, insert）</h4><p>后删除token：如果进行业务处理成功后，删除redis中的token失败了，这样就导致了有可能会发生重复请求，因为token没有被删除。</p>
<p>先删除token：如果系统出现问题导致业务处理出现异常，业务处理没有成功，接口调用方也没有获取到明确的结果，然后进行重试，但token已经删除掉了，服务端判断token不存在，认为是重复请求，就直接返回了，无法进行业务处理了。</p>
<p>先删除token可以保证不会因为重复请求，业务数据出现问题。出现业务异常，可以让调用方配合处理一下，重新获取新的token，再次由业务调用方发起重试请求就ok了。</p>
<h4 id="token机制缺点"><a href="#token机制缺点" class="headerlink" title="token机制缺点"></a>token机制缺点</h4><p>业务请求每次请求，都会有额外的请求（一次获取token请求、判断token是否存在的业务）。其实真实的生产环境中，1万请求也许只会存在10个左右的请求会发生重试，为了这10个请求，我们让9990个请求都发生了额外的请求。</p>
<h3 id="乐观锁机制-数据版本（update）"><a href="#乐观锁机制-数据版本（update）" class="headerlink" title="乐观锁机制-数据版本（update）"></a>乐观锁机制-数据版本（update）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这种方法适合在更新的场景中，根据version版本，也就是在操作库存前先获取当前商品的version版本号，然后操作的时候带上此version号。以下以更新商品的库存数量为例。</span></span><br><span class="line">update t_goods <span class="built_in">set</span> count = count -1 , version = version + 1 <span class="built_in">where</span> good_id=2 and version = 1</span><br></pre></td></tr></table></figure>

<p>客户端每次在需要更新前，先到数据库查询当前goods的版本，然后在更新商品数量的同时，将当时的版本也传过来来，比如当库存版本为<strong>1</strong>时，将商品的数量减一。客户端在重试时，传递的参数还是库存版本为<strong>1</strong>， 但是如果之前已经更新成功了，那么这个重试就不会成功。<strong>乐观锁主要使用于处理读多写少的问题。</strong></p>
<h3 id="唯一主键（insert）"><a href="#唯一主键（insert）" class="headerlink" title="唯一主键（insert）"></a>唯一主键（insert）</h3><p>这个机制是利用了数据库的主键唯一约束的特性，解决了在insert场景时幂等问题。如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关。</p>
<h3 id="防重表-（update，-insert）"><a href="#防重表-（update，-insert）" class="headerlink" title="防重表 （update， insert）"></a>防重表 （update， insert）</h3><p>例如一个支付系统，多增加一个<code>支付去重表，支付去重表以 orderNo 为唯一id</code>， 当请求过来时，先向这个支付去重表插入一条记录，插入成功，表示没有支付过，可以继续走支付流程，插入失败（orderNo唯一键冲突）。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/BLosYj"><img src="https://s1.ax1x.com/2020/11/10/BLosYj.png" alt="BLosYj.png"></a></p>
<h3 id="分布式锁-（update-insert）"><a href="#分布式锁-（update-insert）" class="headerlink" title="分布式锁 （update, insert）"></a>分布式锁 （update, insert）</h3><p>和防重表一样的逻辑，对一个资源加锁。比如对 orderNo 加锁，一旦加锁成功后，其他的请求都无法获得这把锁。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020172463">如何保证接口的幂等性</a></p>
<p><a target="_blank" rel="noopener" href="https://gongfukangee.github.io/2019/03/25/Idempotence/">如何保证业务幂等性</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/09/message%20queue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8Bkafka%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/09/message%20queue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8Bkafka%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">消息队列之kafka 入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-09 19:40:37" itemprop="dateCreated datePublished" datetime="2020-11-09T19:40:37+08:00">2020-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-08 19:57:52" itemprop="dateModified" datetime="2023-02-08T19:57:52+08:00">2023-02-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="Kafka基本概念"><a href="#Kafka基本概念" class="headerlink" title="Kafka基本概念"></a>Kafka基本概念</h2><p>Kafka是一个分布式流数据系统，使用Zookeeper进行集群的管理。与其他消息系统类似，整个系统由生产者、Broker Server和消费者三部分组成，生产者和消费者由开发人员编写，通过API连接到Broker Server进行数据操作。我们重点关注三个概念：</p>
<p>Kafka部分名词解释如下：</p>
<ul>
<li>Broker：<strong>消息中间件处理结点，一个Kafka节点就是一个broker，多个broker可以组成一个Kafka集群。</strong></li>
<li>Topic：一类消息，例如page view日志、click日志等都可以以topic的形式存在，Kafka集群能够同时负责多个topic的分发。</li>
<li>Partition：topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。</li>
</ul>
<h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p>Topic，是Kafka下消息的类别，相当于一条专用的消息通道。对于大多数人来说，在开发的时候只需要关注数据写入到了哪个topic、从哪个topic取出数据。与 pulsar 对比，kafka 没有租户和命名空间的概念，直接就是一个 topic。</p>
<p>Topic 就是数据主题，是数据记录发布的地方,可以用来区分业务系统。Kafka中的Topics总是多订阅者模式，一个topic可以拥有一个或者多个消费者来订阅它的数据。</p>
<p>对于每一个topic， Kafka集群都会维持一个分区日志，如下所示：</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/BHzoZt"><img src="https://s1.ax1x.com/2020/11/09/BHzoZt.png" alt="BHzoZt.png"></a></p>
<p>每个分区都是有序且顺序不可变的记录集，并且不断地追加到结构化的commit log文件。分区中的每一个记录都会分配一个id号来表示顺序，我们称之为offset，<em>offset</em>用来唯一的标识分区中每一条记录。</p>
<p>Kafka 集群保留所有发布的记录—无论他们是否已被消费—并通过一个可配置的参数——保留期限来控制. 举个例子， 如果保留策略设置为2天，一条记录发布后两天内，可以随时被消费，两天过后这条记录会被抛弃并释放磁盘空间。Kafka的性能和数据大小无关，所以长时间存储数据没有什么问题.</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/BHzjMj"><img src="https://s1.ax1x.com/2020/11/09/BHzjMj.png" alt="BHzjMj.png"></a></p>
<p>事实上，<strong>在每一个消费者中唯一保存的元数据是offset（偏移量）</strong> 即消费在log中的位置.偏移量由消费者所控制:通常在读取记录后，消费者会以线性的方式增加偏移量，<strong>但是实际上，由于这个位置由消费者控制，所以消费者可以采用任何顺序来消费记录</strong>。例如，一个消费者可以重置到一个旧的偏移量，从而重新处理过去的数据；也可以跳过最近的记录，从”现在”开始消费。</p>
<p>这些细节说明Kafka 消费者是非常廉价的—消费者的增加和减少，对集群或者其他消费者没有多大的影响。比如，你可以使用命令行工具，对一些topic内容执行 tail操作，并不会影响已存在的消费者消费数据。</p>
<p>日志中的 partition（分区）有以下几个用途。第一，当日志大小超过了单台服务器的限制，允许日志进行扩展。每个单独的分区都必须受限于主机的文件限制，不过一个主题可能有多个分区，因此可以处理无限量的数据。第二，可以作为并行的单元集—关于这一点，更多细节如下</p>
<h3 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h3><p>Partition，是Kafka下数据存储的基本单元，这个是物理上的概念。同一个topic的数据，会被分散的存储到多个partition中，这些partition可以在同一台机器上，也可以是在多台机器上，比如下图所示的topic就有4个partition，分散在两台机器上。这种方式在大多数分布式存储中都可以见到，比如MongoDB、Elasticsearch的分片技术，其优势在于：有利于水平扩展，避免单台机器在磁盘空间和性能上的限制，同时可以通过复制来增加数据冗余性，提高容灾能力。为了做到均匀分布，通常partition的数量通常是Broker Server数量的整数倍。<strong>partition 就是 kafka 支持支持消息和消费者横向扩展的基础</strong></p>
<p>每个分区都有一台 server 作为 “leader”，零台或者多台server作为 follwers 。leader server 处理一切对 partition （分区）的读写请求，而follwers只需被动的同步leader上的数据。当leader宕机了，followers 中的一台服务器会自动成为新的 leader。每台 server 都会成为某些分区的 leader 和某些分区的 follower，因此集群的负载是平衡的。</p>
<h3 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h3><p>Consumer Group，同样是逻辑上的概念，是Kafka实现单播和广播两种消息模型的手段。同一个topic的数据，会广播给不同的group；同一个group中的worker，只有一个worker能拿到这个数据。换句话说，对于同一个topic，每个group都可以拿到同样的所有数据，但是数据进入group后只能被其中的一个worker消费。group内的worker可以使用多线程或多进程来实现，也可以将进程分散在多台机器上，worker的数量通常不超过partition的数量，且二者最好保持整数倍关系，因为Kafka在设计时假定了一个partition只能被一个worker消费（同一group内）。这里其实已经说得很清楚了。对于一个 group 内的多个worker 来看，就是单播， 对于多个 group 来看，就是广播。与 pulsar 作为对比，不同的 group，相当于 Shared 模式下，不同的 subScribetionName。同一个 group 内的多个 worker， 相当于 Shared 模式下，配置了相同的 subScribetionName的 多个 worker。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/BHTMin"><img src="https://s1.ax1x.com/2020/11/09/BHTMin.md.png" alt="BHTMin.md.png"></a></p>
<h4 id="分组消费再平衡策略"><a href="#分组消费再平衡策略" class="headerlink" title="分组消费再平衡策略"></a>分组消费再平衡策略</h4><p>当一个group中,有consumer加入或者离开时,会触发partitions均衡partition.assignment.strategy,决定了partition分配给消费者的分配策略，有两种分配策略：</p>
<h5 id="org-apache-kafka-clients-consumer-RangeAssignor"><a href="#org-apache-kafka-clients-consumer-RangeAssignor" class="headerlink" title="org.apache.kafka.clients.consumer.RangeAssignor"></a>org.apache.kafka.clients.consumer.RangeAssignor</h5><p>默认采用的是这种再平衡方式，这种方式分配只是针对消费者订阅的topic的单个topic所有分区再分配，Consumer Rebalance的算法如下：</p>
<ul>
<li>A&#x3D;(partition数量&#x2F;同分组消费者总个数) </li>
<li>M&#x3D;对上面所得到的A值小数点第一位向上取整 </li>
<li>计算出该消费者拉取数据的patition合集：Ci &#x3D; [P(M*i ),P((i + 1) * M -1)]</li>
</ul>
<p>例如 partition 有 6个，消费者有8个，他们属于同一个消费组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A=6/8=0.75</span><br><span class="line">M=1</span><br><span class="line">C0=[P(1*0),P((<span class="number">0</span>+<span class="number">1</span>)*<span class="number">1</span>-<span class="number">1</span>)]=[P0,P0] </span><br><span class="line">C1=[P(<span class="number">1</span>*<span class="number">1</span>),P((<span class="number">1</span>+<span class="number">1</span>)*<span class="number">1</span>-<span class="number">1</span>)]=[P1,P1] </span><br><span class="line">C2=[P(<span class="number">1</span>*<span class="number">2</span>),P((<span class="number">2</span>+<span class="number">1</span>)*<span class="number">1</span>-<span class="number">1</span>)]=[P2,P2] </span><br><span class="line">C3=[P(<span class="number">1</span>*<span class="number">3</span>),P((<span class="number">3</span>+<span class="number">1</span>)*<span class="number">1</span>-<span class="number">1</span>)]=[P3,P3] </span><br><span class="line">C4=[P(<span class="number">1</span>*<span class="number">4</span>),P((<span class="number">4</span>+<span class="number">1</span>)*<span class="number">1</span>-<span class="number">1</span>)]=[P4,P4] </span><br><span class="line">C5=[P(<span class="number">1</span>*<span class="number">5</span>),P((<span class="number">5</span>+<span class="number">1</span>)*<span class="number">1</span>-<span class="number">1</span>)]=[P5,P5] </span><br><span class="line">C6=[P(<span class="number">1</span>*<span class="number">6</span>),P((<span class="number">6</span>+<span class="number">1</span>)*<span class="number">1</span>-<span class="number">1</span>)]=[P6,P6] </span><br><span class="line">C7=[P(<span class="number">1</span>*<span class="number">7</span>),P((<span class="number">7</span>+<span class="number">1</span>)*<span class="number">1</span>-<span class="number">1</span>)]=[P7,P7]</span><br><span class="line"></span><br><span class="line"># 但是partition只有P0-P5根本就没有P6和P7，所以这两个消费者相当于是会被闲置的，就相当于占用资源，却没什么用，所以在这里真正起到作用的就是C0-C5。</span><br></pre></td></tr></table></figure>

<p>例如 partition 有 6个，消费者有5个，他们属于同一个消费组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A=6/5=1.2 </span><br><span class="line">M=2</span><br><span class="line"></span><br><span class="line">C0=[P(2*0),P((<span class="number">0</span>+<span class="number">1</span>)*<span class="number">2</span>-<span class="number">1</span>)]=[P0,P1] </span><br><span class="line">C1=[P(<span class="number">2</span>*<span class="number">1</span>),P((<span class="number">1</span>+<span class="number">1</span>)*<span class="number">2</span>-<span class="number">1</span>)]=[P2,P3] </span><br><span class="line">C2=[P(<span class="number">2</span>*<span class="number">2</span>),P((<span class="number">2</span>+<span class="number">1</span>)*<span class="number">2</span>-<span class="number">1</span>)]=[P4,P5]</span><br><span class="line">C3=[P(<span class="number">2</span>*<span class="number">3</span>),P((<span class="number">3</span>+<span class="number">1</span>)*<span class="number">2</span>-<span class="number">1</span>)]=[P6,P7] </span><br><span class="line">C4=[P(<span class="number">2</span>*<span class="number">4</span>),P((<span class="number">4</span>+<span class="number">1</span>)*<span class="number">2</span>-<span class="number">1</span>)]=[P8,P9]</span><br><span class="line"># 同上面一样C3和C4没有起到任何作用。</span><br></pre></td></tr></table></figure>

<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li>按照如上的算法，所以如果kafka的消费组需要增加组员，最多增加到和partition数量一致，超过的组员只会占用资源，而不起作用；</li>
<li>kafka的partition的个数一定要大于消费组组员的个数，并且partition的个数对于消费组组员取模一定要为0，不然有些消费者会占用资源却不起作用；</li>
</ul>
<h4 id="分组成员的存活检测"><a href="#分组成员的存活检测" class="headerlink" title="分组成员的存活检测"></a>分组成员的存活检测</h4><p>分组消费有一个比较好的功能就是自动检测失败的消费者并将其踢出分组，然后重新进行分区分配。那么kafka是如何检测失败的消费者的呢。我们就拿0.10.x为例进行讲解说明。</p>
<p>消费着订阅了一组的topic后，会在调用poll(long)函数的时候加入分组，分组内新增消费者就会进行再平衡。Poll 函数的设计目标就是来保证消费者存活的。只要持续不断的调用poll函数，消费者就会留在分组里，连续的从分配给他的分区里消费消息。</p>
<h5 id="存活检测-live"><a href="#存活检测-live" class="headerlink" title="存活检测 (live)"></a>存活检测 (live)</h5><p>消费者也会使用一个后台线程发送周期性的心跳给broker。如果消费者挂掉或者无法在session.timeout.ms时间范围内发送心跳，消费者会被视为死亡，它的分区就会被重新分配。<strong>心跳检测能保证消费者存活。</strong></p>
<h5 id="活跃检测-active"><a href="#活跃检测-active" class="headerlink" title="活跃检测 (active)"></a>活跃检测 (active)</h5><p>由于心跳是后台线程周期性发送的，那么会存在消费者心跳正常发送，但是不消费消息的情况。为了避免这种消费者无限期的占用分配给他的分区这种情况，kafka提供了一种活跃检测机制，使用max.poll.interval.ms配置。根本上来说，<strong>两次调用poll函数的间隔大于该值，消费者就会离开分组，然后它的分区会被其它消费着消费。</strong>当发生这种情况时，你会收到一个offset提交失败的异常。这种机制确保了只有活跃的消费者才能提交offset。<strong>poll 的时间间隔检测能保证消费者的活跃 active</strong></p>
<h2 id="生产者，消费者【非常好的描述】"><a href="#生产者，消费者【非常好的描述】" class="headerlink" title="生产者，消费者【非常好的描述】"></a>生产者，消费者【非常好的描述】</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>生产者可以将数据发布到所选择的topic（主题）中。生产者负责将记录分配到topic的哪一个 partition（分区）中。可以使用循环的方式来简单地实现负载均衡，也可以根据某些语义分区函数(例如：记录中的key)来完成。下面会介绍更多关于分区的使用。</p>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>消费者使用一个 <em>消费组</em> 名称来进行标识，发布到topic中的每条记录被分配给订阅消费组中的一个消费者实例.消费者实例可以分布在多个进程中或者多个机器上。</p>
<ul>
<li><p>如果所有的消费者实例在同一消费组中，消息记录会负载平衡到一个消费者实例（只有一个消费者实例能消费一条消息）.</p>
</li>
<li><p>如果所有的消费者实例在不同的消费组中，每条消息记录会广播到所有的消费者进程（所有的消费者都能想消费同一条消息）.</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/BHxRun"><img src="https://s1.ax1x.com/2020/11/09/BHxRun.png" alt="BHxRun.png"></a></p>
<p>如图，这个 Kafka 集群有两台 server 的，四个分区(p0-p3)和两个消费者组。消费组A有两个消费者，消费组B有四个消费者。</p>
<p>通常情况下，每个 topic 都会有一些消费组，**一个消费组对应一个”逻辑订阅者”**。一个消费组由许多消费者实例组成，便于扩展和容错。这就是发布和订阅的概念，只不过订阅者是一组消费者而不是单个的进程。</p>
<p>在Kafka中实现消费的方式是将日志中的分区划分到每一个消费者实例上，以便在任何时间，<strong>每个实例都是分区唯一的消费者</strong>。维护消费组中的消费关系由Kafka协议动态处理。如果新的实例加入组，他们将从组中其他成员处接管一些 partition 分区;如果一个实例消失，拥有的分区将被分发到剩余的实例。</p>
<p>Kafka 只保证分区内的记录是有序的，而不保证主题中不同分区的顺序。每个 partition 分区按照key值排序足以满足大多数应用程序的需求。但如果你需要总记录在所有记录的上面，可使用仅有一个分区的主题来实现，这意味着每个消费者组只有一个消费者进程。</p>
<h2 id="kafka的保证"><a href="#kafka的保证" class="headerlink" title="kafka的保证"></a>kafka的保证</h2><p>high-level Kafka给予以下保证:</p>
<ul>
<li>生产者发送到特定topic partition 的消息将按照发送的顺序处理。 也就是说，如果记录M1和记录M2由相同的生产者发送，并先发送M1记录，那么M1的偏移比M2小，并在日志中较早出现</li>
<li>一个消费者实例按照日志中的顺序查看记录.</li>
<li>对于具有N个副本的主题，我们最多容忍N-1个服务器故障，从而保证不会丢失任何提交到日志中的记录.</li>
</ul>
<h3 id="如何保证数据不丢失"><a href="#如何保证数据不丢失" class="headerlink" title="如何保证数据不丢失"></a>如何保证数据不丢失</h3><h4 id="broker如何保证数据的不丢失"><a href="#broker如何保证数据的不丢失" class="headerlink" title="broker如何保证数据的不丢失"></a>broker如何保证数据的不丢失</h4><ul>
<li>acks&#x3D;all : 所有副本都写入成功并确认。</li>
<li>retries &#x3D; 一个合理值。</li>
<li>min.insync.replicas&#x3D;2 消息至少要被写入到这么多副本才算成功。</li>
<li>unclean.leader.election.enable&#x3D;false 关闭unclean leader选举，即不允许非ISR中的副本被选举为leader，以避免数据丢失。</li>
</ul>
<h4 id="consumer如果保证数据得不丢失"><a href="#consumer如果保证数据得不丢失" class="headerlink" title="consumer如果保证数据得不丢失"></a>consumer如果保证数据得不丢失</h4><p>enable.auto.commit&#x3D;false 关闭自动提交offset。</p>
<h2 id="kafka的使用"><a href="#kafka的使用" class="headerlink" title="kafka的使用"></a>kafka的使用</h2><h3 id="Kafka作为消息系统"><a href="#Kafka作为消息系统" class="headerlink" title="Kafka作为消息系统"></a>Kafka作为消息系统</h3><p>传统的消息系统有两个模块: 队列 和 发布-订阅。 在队列中，消费者池从server读取数据，每条记录被池子中的一个消费者消费; 在发布订阅中，记录被广播到所有的消费者。两者均有优缺点。 队列的优点在于它允许你将处理数据的过程分给多个消费者实例，使你可以扩展处理过程。 不好的是，队列不是多订阅者模式的—一旦一个进程读取了数据，数据就会被丢弃。 而发布-订阅系统允许你广播数据到多个进程，但是无法进行扩展处理，因为每条消息都会发送给所有的订阅者。</p>
<p>消费组在Kafka有两层概念。在队列中，消费组允许你将处理过程分发给一系列进程(消费组中的成员)。 在发布订阅中，Kafka允许你将消息广播给多个消费组。</p>
<p>Kafka的优势在于每个topic都有以下特性—可以扩展处理并且允许多订阅者模式—不需要只选择其中一个.</p>
<p>Kafka相比于传统消息队列还具有更严格的顺序保证 ……</p>
<p>Kafka 设计的更好。topic中的partition是一个并行的概念。 Kafka能够为一个消费者池提供顺序保证和负载平衡，是通过将topic中的partition分配给消费者组中的消费者来实现的， 以便每个分区由消费组中的一个消费者消耗。通过这样，我们能够确保消费者是该分区的唯一读者，并按顺序消费数据。 众多分区保证了多个消费者实例间的负载均衡。但请注意，消费者组中的消费者实例个数不能超过分区的数量。</p>
<h3 id="Kafka-作为存储系统"><a href="#Kafka-作为存储系统" class="headerlink" title="Kafka 作为存储系统"></a>Kafka 作为存储系统</h3><p>许多消息队列可以发布消息，除了消费消息之外还可以充当中间数据的存储系统。那么Kafka作为一个优秀的存储系统有什么不同呢?</p>
<p>数据写入Kafka后被写到磁盘，并且进行备份以便容错。直到完全备份，Kafka才让生产者认为完成写入，即使写入失败Kafka也会确保继续写入</p>
<p>Kafka使用磁盘结构，具有很好的扩展性—50kb和50TB的数据在server上表现一致。</p>
<p>可以存储大量数据，并且可通过客户端控制它读取数据的位置，您可认为Kafka是一种高性能、低延迟、具备日志存储、备份和传播功能的分布式文件系统。</p>
<h3 id="Kafka用做流处理"><a href="#Kafka用做流处理" class="headerlink" title="Kafka用做流处理"></a>Kafka用做流处理</h3><p>Kafka 流处理不仅仅用来读写和存储流式数据，它最终的目的是为了能够进行实时的流处理。</p>
<p>在Kafka中，流处理器不断地从输入的topic获取流数据，处理数据后，再不断生产流数据到输出的topic中去。</p>
<h2 id="多种消费者模式"><a href="#多种消费者模式" class="headerlink" title="多种消费者模式"></a>多种消费者模式</h2><h3 id="生产消费者模式"><a href="#生产消费者模式" class="headerlink" title="生产消费者模式"></a>生产消费者模式</h3><p>搞清楚了Kafka的基本概念后，我们来看如何设计生产消费者模式来实现上述的“数据接入”场景。在下图中，由Producer负责接收前端上报的数据，投递到对应的topic中（这里忽略了Broker Server的细节），在Consumer端，所有对该数据感兴趣的业务都可以建立自己的group来消费数据，<strong>至于group内部开多少个worke来消费完全取决于数据量和业务的实时性要求了。</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/BHTzlV"><img src="https://s1.ax1x.com/2020/11/09/BHTzlV.md.png" alt="BHTzlV.md.png"></a></p>
<h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>再来看“事件分发”的场景，假如我们有“收藏”、“下单”、“付款”三个事件，业务一对“收藏”和“下单”事件感兴趣，而业务二对“下单”和“付款”事件感兴趣，那么我们如何进行事件订阅？<strong>Kafka只提供了单播和广播的消息模型，无法直接进行消费对象的绑定</strong>，所以理论上Kafka是不适合做此种场景下的订阅发布模式的，如果一定要做，有这么几个方案：</p>
<ul>
<li>方案一：继续使用上述生产消费者的模式，在不同的group中过滤出自己感兴趣的事件数据，然后进行处理。这种方式简单有效，缺点就是每个group都会收到很多自己不感兴趣的垃圾数据。</li>
<li>方案二：把每个事件的数据推送到不同的topic中，即以事件名称来作为topic分类，在Consumer端，建立自己的group来消费自己感兴趣的一组topic。这种方式适用于事件个数可以明确评估并且数量较少，如果事件种类很多，会导致topic的数量过多，创建过多的topic和partition则会影响到Kafka的性能，因为Kafka的每个Topic、每个分区都会对应一个物理文件，当Topic数量增加时，消息分散的落盘策略会导致磁盘IO竞争激烈成为瓶颈。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/BHHL2q"><img src="https://s1.ax1x.com/2020/11/09/BHHL2q.md.png" alt="BHHL2q.md.png"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://kafka.apachecn.org/intro.html">官方文档，看这一篇就够了</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wobuaizhi/article/details/80950387">kafka分区（partition）和和分组（group）</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1639449">Kafka下的生产消费者模式与订阅发布模式</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/09/message%20queue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8B%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/09/message%20queue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8B%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">消息队列之入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-09 19:40:37" itemprop="dateCreated datePublished" datetime="2020-11-09T19:40:37+08:00">2020-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-08 19:58:14" itemprop="dateModified" datetime="2023-02-08T19:58:14+08:00">2023-02-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h2><h3 id="生产消费者模式（队列）"><a href="#生产消费者模式（队列）" class="headerlink" title="生产消费者模式（队列）"></a>生产消费者模式（队列）</h3><p>生产消费者模式，指的是由生产者将数据源源不断推送到消息中心，由不同的消费者从消息中心取出数据做自己的处理，在同一类别下，所有消费者拿到的都是同样的数据。<strong>是一种点对点的方式，消息不会被重复消费，可以粗暴的理解为消息被消费后就被标记删除或者已删除了，这是常见的消息队列通常的模式。比如说进程间通信，这种基于队列实现消息传输服务的。</strong></p>
<p>队列下，就是每条记录被池子中的一个消费者消费。kafka中对队列的实现就是同一个消费者组下面的消费者就是队列式消费。</p>
<h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>订阅发布模式，本质上也是一种生产消费者模式，不同的是，由订阅者首先向消息中心指定自己对哪些数据感兴趣，发布者推送的数据经过消息中心后，每个订阅者拿到的仅仅是自己感兴趣的一组数据（<strong>最简单的实现，就是多个topic</strong>）。这两种模式是使用消息中间件时最常用的，用于功能解耦和分布式系统间的消息通信。</p>
<p>相对于生产者 消费者模式，消息可能会被多方消费，可以简单的理解为一份报纸的内容，订阅它的人都可以读到它，当一个人读完之后也就没必要再次去读了。<strong>并且在发布订阅模式中，通常有个概念叫做topic</strong>，每个topic 有对应的发布者（publisher）、订阅者（subsciber）。<strong>发布订阅模式和设计模式中的观察者模式是一个思路，观察者订阅自己感兴趣的 topic， 然后 topic 有消息就得到通知。</strong></p>
<p>发布订阅模式下，记录被广播到所有的消费者。kafka中对发布订阅的实现就是多个不同的消费者组同时消费同一个topic，多个consumer group 都能消费到每一条数据。但是kafka是多播。</p>
<h2 id="kafka-中的单播和多播"><a href="#kafka-中的单播和多播" class="headerlink" title="kafka 中的单播和多播"></a>kafka 中的单播和多播</h2><h3 id="单播"><a href="#单播" class="headerlink" title="单播"></a>单播</h3><p>一条消息只能被某一个消费者消费的模式称为单播。要实现消息单播，只要让这些消费者属于同一个消费者组即可。当生产者发送一条消息时，同一消费者组中的多个消费者中只有一个能收到消息。</p>
<h3 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h3><p>一条消息能够被多个消费者消费的模式称为多播。之所以不称之为广播，是因为一条消息只能被Kafka同一个分组下某一个消费者消费，而不是所有消费者都能消费，所以从严格意义上来讲并不能算是广播模式，当然如果希望实现广播模式只要保证每个消费者均属于不同的消费者组。针对Kafka同一条消息只能被同一个消费者组下的某一个消费者消费的特性，要实现多播只要保证这些消费者属于不同的消费者组即可。然后通过生产者发送几条消息，可以看到不同消费者组的消费者同时能消费到消息，然而同一个消费者组下的消费者却只能有一个消费者能消费到消息。</p>
<h2 id="消息解耦的优点"><a href="#消息解耦的优点" class="headerlink" title="消息解耦的优点"></a>消息解耦的优点</h2><p>假设有一个用户行为采集系统，负责从App端采集用户点击行为数据。通常会将数据上报和数据处理分离开，即App端通过REST API上报数据，后端拿到数据后放入队列中就立刻返回，而数据处理则另外使用Worker从队列中取出数据来做，如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/BHIkFI"><img src="https://s1.ax1x.com/2020/11/09/BHIkFI.md.png" alt="BHIkFI.md.png"></a></p>
<h3 id="优点一：功能分离"><a href="#优点一：功能分离" class="headerlink" title="优点一：功能分离"></a>优点一：功能分离</h3><p>功能分离，上报的API接口不关心数据处理功能，只负责接入数据</p>
<h3 id="优点二：数据缓冲"><a href="#优点二：数据缓冲" class="headerlink" title="优点二：数据缓冲"></a>优点二：数据缓冲</h3><p>数据上报的速率是不可控的，取决于用户使用频率，采用该模式可以一定程度地缓冲数据</p>
<h3 id="优点三：易于扩展"><a href="#优点三：易于扩展" class="headerlink" title="优点三：易于扩展"></a>优点三：易于扩展</h3><p>在数据量大时，通过增加数据处理Worker来扩展，提高处理速率。这便是典型的生产消费者模式，数据上报为生产者，数据处理为消费者。</p>
<h3 id="有点四：事件分发"><a href="#有点四：事件分发" class="headerlink" title="有点四：事件分发"></a>有点四：事件分发</h3><p>假设有一个电商系统，那么，用户“收藏”、“下单”、“付款”等行为都是非常重要的事件，通常后端服务在完成相应的功能处理外，还需要在这些事件点上做很多其他处理动作，比如发送短信通知、记录用户积分等等。我们可以将这些额外的处理动作放到每个模块中，但这并不是优雅的实现，不利于功能解耦和代码维护。</p>
<p>我们需要的是一个事件分发系统，在各个功能模块中将对应的事件发布出来，由对其感兴趣的处理者进行处理。这里涉及两个角色：A对B感兴趣，A是处理者，B是事件，由事件处理器完成二者的绑定，并向消息中心订阅事件。服务模块是后端的业务逻辑服务，在不同的事件点发布事件，事件经过消息中心分发给事件处理器对应的处理者。整个流程如下图所示。这边是典型的订阅发布模式。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/BHIEfP"><img src="https://s1.ax1x.com/2020/11/09/BHIEfP.md.png" alt="BHIEfP.md.png"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1639449">Kafka下的生产消费者模式与订阅发布模式</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Percy"
      src="https://ivalue2333.github.io/percy/images/percy.jpg">
  <p class="site-author-name" itemprop="name">Percy</p>
  <div class="site-description" itemprop="description">IOT2014</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">156</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">194</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Percy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
