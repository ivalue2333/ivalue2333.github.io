<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="IOT2014">
<meta property="og:type" content="website">
<meta property="og:title" content="blog | percy">
<meta property="og:url" content="http://example.com/page/7/index.html">
<meta property="og:site_name" content="blog | percy">
<meta property="og:description" content="IOT2014">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Percy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>blog | percy</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blog | percy</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/05/message%20queue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8Bkafka%20%E6%8C%87%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/05/message%20queue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8Bkafka%20%E6%8C%87%E4%BB%A4/" class="post-title-link" itemprop="url">消息队列之kafka 指令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-05 19:40:37" itemprop="dateCreated datePublished" datetime="2020-11-05T19:40:37+08:00">2020-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-08 19:58:09" itemprop="dateModified" datetime="2023-02-08T19:58:09+08:00">2023-02-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="消费组（一个分区）"><a href="#消费组（一个分区）" class="headerlink" title="消费组（一个分区）"></a>消费组（一个分区）</h3><h4 id="创建-topic"><a href="#创建-topic" class="headerlink" title="创建 topic"></a>创建 topic</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> mykafka kafka-topics.sh --create --zookeeper myzookeeper:2181 --replication-factor 1 --partitions 1 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h4 id="生产消息"><a href="#生产消息" class="headerlink" title="生产消息"></a>生产消息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生产消息</span></span><br><span class="line">/opt/kafka/bin/kafka-console-producer.sh --broker-list mykafka:9092 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h4 id="两个组名称不同"><a href="#两个组名称不同" class="headerlink" title="两个组名称不同"></a>两个组名称不同</h4><p>生产者每生产一份数据，两个消费组都会收到消息。对应 pulsar中 shared 并 subScriptonName 不同， 每一个组都能消费所有的数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> -group test_group1 --from-beginning</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个新的 group 加入会消费数据，这里指定的是 --from-beginning， 所以会消费所有的数据</span></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> -group test_group2 --from-beginning</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里只会消费后面增加的数据，这里的分区指定为0，因为这里没有分区，所以就是0， 如果指定分区为1，那么无法消费数据</span></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --offset latest --partition 0</span><br></pre></td></tr></table></figure>

<h4 id="两个组名称相同，两个随机分组，两个不指定分组"><a href="#两个组名称相同，两个随机分组，两个不指定分组" class="headerlink" title="两个组名称相同，两个随机分组，两个不指定分组"></a>两个组名称相同，两个随机分组，两个不指定分组</h4><ul>
<li>两个组名称相同，则其中一个会阻塞，另一个能一直获取数据，如果活跃的那个连接挂了，那么阻塞的那个client会获取到连接，并处理接下来的数据。</li>
<li>随机分组和不指定分组， 每一个client都能获取到所有的消息。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分组相同</span></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> -group test_group --from-beginning</span><br><span class="line"></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> -group test_group --from-beginning</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个随机分组</span></span><br><span class="line"><span class="comment"># kafka-console-consumer.sh 这个脚本如果不指定 consumer group， 会随机生成一个，类似这样 console-consumer-5089</span></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --from-beginning</span><br><span class="line"></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --from-beginning</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个不指定分组</span></span><br><span class="line">python3 main.py</span><br><span class="line"></span><br><span class="line">python3 main.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># Consumer Group: 每个消费者都属于一个特定的Consumer Group，可通过group.id配置项指定，若不指定group name则默认为test-consumer-group， 这句话不对，但是不指定 group name 是什么还不知道, 因为通过下面的指令，看不到 test-consumer-group 这个 group</span></span><br><span class="line">/opt/kafka/bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list</span><br></pre></td></tr></table></figure>

<h3 id="单消费（三个分区）"><a href="#单消费（三个分区）" class="headerlink" title="单消费（三个分区）"></a>单消费（三个分区）</h3><h4 id="创建-topic-1"><a href="#创建-topic-1" class="headerlink" title="创建 topic"></a>创建 topic</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三个分区</span></span><br><span class="line">docker <span class="built_in">exec</span> mykafka kafka-topics.sh --create --zookeeper myzookeeper:2181 --replication-factor 1 --partitions 3 --topic test3</span><br></pre></td></tr></table></figure>

<h4 id="生产消息-1"><a href="#生产消息-1" class="headerlink" title="生产消息"></a>生产消息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生产消息</span></span><br><span class="line">/opt/kafka/bin/kafka-console-producer.sh --broker-list mykafka:9092 --topic test3</span><br></pre></td></tr></table></figure>

<h4 id="两个消费者-不指定分区"><a href="#两个消费者-不指定分区" class="headerlink" title="两个消费者-不指定分区"></a>两个消费者-不指定分区</h4><p>两个消费者都能收到同一条消息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test3 --from-beginning</span><br><span class="line"></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test3 --from-beginning</span><br></pre></td></tr></table></figure>

<h4 id="两个消费者-指定分组"><a href="#两个消费者-指定分组" class="headerlink" title="两个消费者-指定分组"></a>两个消费者-指定分组</h4><p>两个消费者来消费所有的数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test3 -group test_group1 </span><br><span class="line"></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test3 -group test_group1 </span><br></pre></td></tr></table></figure>

<h4 id="四个消费者-指定分组"><a href="#四个消费者-指定分组" class="headerlink" title="四个消费者-指定分组"></a>四个消费者-指定分组</h4><p>分组和分区不能同时指定，指定了分组，那么同一个组里的 client 会一起去消费数据，一个消费者消费一个分区（为client 分配了的 分区id），如果消费者数量大于分区数量，那么有一些消费就会挂起，直到一些消费者crash， 这些挂起的消费者才可能获得连接，并开始接收消息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test3 -group test_group1 </span><br><span class="line"></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test3 -group test_group1 </span><br><span class="line"></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test3 -group test_group1</span><br><span class="line"></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test3 -group test_group1</span><br></pre></td></tr></table></figure>

<h4 id="五个消费者-指定分区（不指定分组）"><a href="#五个消费者-指定分区（不指定分组）" class="headerlink" title="五个消费者-指定分区（不指定分组）"></a>五个消费者-指定分区（不指定分组）</h4><p>在分区3上无法收到消息。指定了相同分区的消费者，都能收到同一条消息。分区消费对应着 pulsar 中的 shared 并且 subScriptoinName 相同，所有的 worker 一起消费所有的数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test3 --offset latest --partition 0</span><br><span class="line"></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test3 --offset latest --partition 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定了相同分区的消费者，都能收到同一条消息， 因为这里默认会使用不同的 cg</span></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test3 --offset latest --partition 2</span><br><span class="line"></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test3 --offset latest --partition 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在分区3上无法收到消息</span></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test3 --offset latest --partition 3</span><br></pre></td></tr></table></figure>

<h4 id="五个消费者-指定分区和不指定分区混合（不指定分组）"><a href="#五个消费者-指定分区和不指定分区混合（不指定分组）" class="headerlink" title="五个消费者-指定分区和不指定分区混合（不指定分组）"></a>五个消费者-指定分区和不指定分区混合（不指定分组）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test3 --offset latest --partition 0</span><br><span class="line"></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test3 --offset latest --partition 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定了相同分区的消费者，都能收到同一条消息</span></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test3 --offset latest --partition 2</span><br><span class="line"></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test3 --offset latest --partition 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不指定分区，不指定分区的单独消费一份</span></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test3 --from-beginning</span><br></pre></td></tr></table></figure>

<h2 id="docker-启动"><a href="#docker-启动" class="headerlink" title="docker 启动"></a>docker 启动</h2><p>go-science&#x2F;midd&#x2F;kafka&#x2F;standalone</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们执行如下命令可以创建一个名为 test 的 Topic，该 Topic 包含一个分区和一个 Replica。</span></span><br><span class="line">docker <span class="built_in">exec</span> mykafka kafka-topics.sh --create --zookeeper myzookeeper:2181 --replication-factor 1 --partitions 1 --topic <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建后可以执行如下命令查看当前的 Topics：</span></span><br><span class="line">docker <span class="built_in">exec</span> mykafka kafka-topics.sh --list --zookeeper myzookeeper:2181</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器内操作</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mykafka bash</span><br><span class="line">/opt/kafka/bin/kafka-topics.sh --list --zookeeper myzookeeper:2181</span><br></pre></td></tr></table></figure>

<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>注意：如果事先没有使用 kafka-topics 命令来手工创建 Topic，直接使用下面的内容进行消息创建时也会自动创建 Topics。</p>
<p>首先创建消息生产者。执行如下命令启动 Kafka 基于命令行的消息生产客户端，启动后可以直接在控制台中输入消息来发送，控制台中的每一行数据都会被视为一条消息来发送。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意：此时我们可以尝试输入几行消息，由于此时并没有消费者，所以这些输入的消息都会被阻塞在名为 test 的 Topics 中，直到有消费者将其消费掉。</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mykafka kafka-console-producer.sh --broker-list mykafka:9092 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>接着创建消息消费者。我们打开另一个命令窗口执行如下执行命令启动 Kafka 基于命令行的消息消费客户端，启动之后，马上可以在控制台中看到输出了之前我们在消息生产客户端中发送的消息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mykafka kafka-console-consumer.sh --bootstrap-server mykafka:9092 --topic <span class="built_in">test</span> --from-beginning</span><br></pre></td></tr></table></figure>

<h2 id="指令总结"><a href="#指令总结" class="headerlink" title="指令总结"></a>指令总结</h2><h3 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建topic, 参数 --topic 指定 Topic 名，--partitions 指定分区数，--replication-factor 指定备份数：</span></span><br><span class="line">/opt/kafka/bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有 Topic</span></span><br><span class="line">/opt/kafka/bin/kafka-topics.sh --list --zookeeper localhost:2181 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Topic</span></span><br><span class="line">/opt/kafka/bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic <span class="built_in">test</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加 Topic 的 partition 数</span></span><br><span class="line">/opt/kafka/bin/kafka-topics.sh --zookeeper localhost:2181 --alter --topic <span class="built_in">test</span> --partitions 5 </span><br><span class="line"></span><br><span class="line"> <span class="comment"># 查看 topic 指定分区 offset 的最大值或最小值</span></span><br><span class="line"> <span class="comment"># time 为 -1 时表示最大值，为 -2 时表示最小值：</span></span><br><span class="line"> /opt/kafka/bin/kafka-run-class.sh kafka.tools.GetOffsetShell --topic <span class="built_in">test</span> --time -1 --broker-list 127.0.0.1:9092 --partitions 0 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 topic</span></span><br><span class="line">/opt/kafka/bin/kafka-topics.sh --zookeeper localhost:2181 --topic <span class="built_in">test</span> --delete </span><br></pre></td></tr></table></figure>

<h3 id="消息-1"><a href="#消息-1" class="headerlink" title="消息"></a>消息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生产消息</span></span><br><span class="line">/opt/kafka/bin/kafka-console-producer.sh --broker-list localhost:9092 --topic <span class="built_in">test</span> </span><br></pre></td></tr></table></figure>

<h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从头开始</span></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --from-beginning</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从尾部开始， 从尾部开始取数据，必需要指定分区：</span></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --offset latest --partition 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定分区</span></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --offset latest --partition 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取指定个数</span></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --offset latest --partition 0 --max-messages 1 </span><br></pre></td></tr></table></figure>

<h4 id="消费者-Group"><a href="#消费者-Group" class="headerlink" title="消费者 Group"></a>消费者 Group</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定 Group</span></span><br><span class="line">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> -group test_group --from-beginning</span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者 Group 列表</span></span><br><span class="line">/opt/kafka/bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Group 详情</span></span><br><span class="line">/opt/kafka/bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --group test_group --describe</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 Group 中 Topic</span></span><br><span class="line">/opt/kafka/bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --group test_group --topic <span class="built_in">test</span> --delete</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 Group</span></span><br><span class="line">/opt/kafka/bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --group test_group --delete</span><br><span class="line"></span><br><span class="line"><span class="comment"># 平衡 leader</span></span><br><span class="line">/opt/kafka/bin/kafka-preferred-replica-election.sh --bootstrap-server localhost:9092</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自带压测工具</span></span><br><span class="line">/opt/kafka/bin/kafka-producer-perf-test.sh --topic <span class="built_in">test</span> --num-records 100 --record-size 1 --throughput 100 --producer-props bootstrap.servers=localhost:9092 </span><br></pre></td></tr></table></figure>

<h3 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h3><p>消费者组是属于集群的，不是属于 topic 的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/kafka/bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.hangge.com/blog/cache/detail_2791.html">Docker - 通过容器部署Kafka环境教程（以及ZooKeeper）</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903829352382471#heading-11">kafka常用命令</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/wurstmeister/kafka-docker/blob/master/docker-compose.yml">docker compose 启动 kafka</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/05/message%20queue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8Bkafka%20%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/05/message%20queue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8Bkafka%20%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" class="post-title-link" itemprop="url">消息队列之kafka 的负载均衡</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-05 19:40:37" itemprop="dateCreated datePublished" datetime="2020-11-05T19:40:37+08:00">2020-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-08 19:56:12" itemprop="dateModified" datetime="2023-02-08T19:56:12+08:00">2023-02-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><ul>
<li>ZooKeeper负责管理所有Broker服务器列表，并且建立了对应路径来对其进行管理&#x2F;brokers&#x2F;ids。每个Broker服务器在启动时，都会到ZooKeeper上进行注册，其节点路径为&#x2F;broker&#x2F;ids&#x2F;[0…N]。</li>
<li>Topic注册：Kafka当中，会将同一个Topic的消息分成多个区，分布到多个Broker上，<strong>这些分区信息和Broker的对应关系由ZooKeeper来维护。</strong></li>
<li>每当一个Broker启动时，会首先完成Broker注册过程，在ZooKeeper的节点列表里保存Broker。</li>
<li>Kafka的生产者会对ZooKeeper上的“Broker的新增与减少”、“Topic的新增和减少”和“Broker和Topic关联关系的变化”等事件<strong>注册Watcher监听</strong></li>
<li>通过ZooKeeper的<strong>Watcher通知能够让生产者动态的获取Broker和Topic的变化情况</strong></li>
</ul>
<h2 id="生产者的负载均衡"><a href="#生产者的负载均衡" class="headerlink" title="生产者的负载均衡"></a>生产者的负载均衡</h2><p>在生产中，必须指定topic， topic 对应的 broker 是可以通过 zk 获得的；但是对于partition,有两种指定方式：</p>
<ul>
<li>明确指定partition(0-N)，则数据被发送到指定partition</li>
<li>设置为RD_KAFKA_PARTITION_UA，则kafka会回调partitioner进行均衡选取，partitioner方法需要自己实现。可以轮询或者传入key进行hash。未实现则采用默认的随机方法rd_kafka_msg_partitioner_random随机选择。</li>
</ul>
<h2 id="消费者的负载均衡"><a href="#消费者的负载均衡" class="headerlink" title="消费者的负载均衡"></a>消费者的负载均衡</h2><p>Kafka具有消费分组的概念，某个Topic的某个partition只能由一个Consumer group中的一个Consmer消费。但如果两个Consmer不在同一个Consumer group，那么他们是可以同时消费某Topic的同一个partition的。</p>
<p>对于某些低级别的API，Consumer消费时必须制定topic和partition，这显然不是一种很好的均衡策略。<strong>基于高级别的API，Consumer消费时只需指定topic，借助zookeeper可以根据partition的数量和consumer的数量做到均衡的动态配置。</strong></p>
<h3 id="消费者数量变化"><a href="#消费者数量变化" class="headerlink" title="消费者数量变化"></a>消费者数量变化</h3><p>消费者在启动时会到zookeeper下以自己的conusmer-id创建临时节点&#x2F;consumer&#x2F;[group-id]&#x2F;ids&#x2F;[conusmer-id]，并对&#x2F;consumer&#x2F;[group-id]&#x2F;ids注册监听事件，当消费者发生变化时，同一group的其余消费者会得到通知。</p>
<p>例如，消费组中有 4 个消费者，其中一个突然断开，那么这会促发 rebalance， 这 3 个消费者会一起来消费所有的分区。<strong>促发 rebalance 的时机实际上是消费者的存活检测机制实现的。详细可以看《kafka入门》</strong></p>
<h2 id="broker-的负载均衡"><a href="#broker-的负载均衡" class="headerlink" title="broker 的负载均衡"></a>broker 的负载均衡</h2><p>broker 的负载均衡主要发生在创建 topic 时，会将 topic 的多个分区均衡地分配到多个 broker 上。</p>
<p>不确定 Kafka 的 broker 有没有像pulsar的自动的过载重平衡。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ffbeba5bae13">ZooKeeper为kafka做负载均衡</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/05/message%20queue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8Bpulsar%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/05/message%20queue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8Bpulsar%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">消息队列之pulsar入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-05 19:40:37" itemprop="dateCreated datePublished" datetime="2020-11-05T19:40:37+08:00">2020-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><h3 id="topic-名称"><a href="#topic-名称" class="headerlink" title="topic 名称"></a>topic 名称</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;persistent|non-persistent&#125;://property/cluster/namespace/topic</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">Topic</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">topic 类型</td>
<td align="left"><code>persistent</code></td>
</tr>
<tr>
<td align="left">租户</td>
<td align="left"><code>public</code></td>
</tr>
<tr>
<td align="left">命名空间</td>
<td align="left"><code>default</code></td>
</tr>
</tbody></table>
<p>下表为使用隐式默认值的 topic 名称的转换示例：</p>
<table>
<thead>
<tr>
<th align="left">输入 topic 名称</th>
<th align="left">转换后的 topic 名称</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>my-topic</code></td>
<td align="left"><code>persistent://public/default/my-topic</code></td>
</tr>
<tr>
<td align="left"><code>my-tenant/my-namespace/my-topic</code></td>
<td align="left"><code>persistent://tenant/namespace/topic</code></td>
</tr>
</tbody></table>
<p>对于<a target="_blank" rel="noopener" href="https://pulsar.apache.org/docs/zh-CN/concepts-messaging#non-persistent-topics">非持久化 topics</a>，需要指定 topic 的完整名称，因为持久化 topic 名称的默认规则在此不适用。 因此，不能使用如 <code>non-persistent://my-topic</code> 这样简化的名称，而应使用 <code>non-persistent://public/default/my-topic</code>。</p>
<h3 id="分区topic"><a href="#分区topic" class="headerlink" title="分区topic"></a>分区topic</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/47388267">比拼Kafka，大数据分析新秀Pulsar到底好在哪</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/715068">https://developer.aliyun.com/article/715068</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/05/message%20queue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8Bpulsar%E5%92%8Ckafka%E7%9A%84%E5%AF%B9%E6%AF%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/05/message%20queue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8Bpulsar%E5%92%8Ckafka%E7%9A%84%E5%AF%B9%E6%AF%94/" class="post-title-link" itemprop="url">消息队列之 pulsar 和 kafka 的对比</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-05 19:40:37" itemprop="dateCreated datePublished" datetime="2020-11-05T19:40:37+08:00">2020-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>之前的文章，我们描述了Apache Pulsar能够成为企业级流和消息系统的原因。Pulsar的企业特性包括消息的持久化存储，多租户，多机房互联互备，加密和安全性等。我们经常被问到的一个问题是Apache Pulsar和Apache Kafka有什么不同。</p>
<p>在本系列的Pulsar和Kafka比较文章中，我们将引导您认识和了解消息系统中一些重要关注点，比如健壮性，高可用性和高带宽低延迟等。</p>
<p>在用户选择一个消息系统时，消息模型是用户首先考虑的事情。消息模型应涵盖以下3个方面：</p>
<ol>
<li>消息消费 - 如何发送和消费消息；</li>
<li>消息确认（ack） - 如何确认消息；</li>
<li>消息保存 - 消息保留多长时间，触发消息删除的原因以及怎样删除；</li>
</ol>
<h3 id="消费模型"><a href="#消费模型" class="headerlink" title="消费模型"></a>消费模型</h3><ul>
<li>队列模型</li>
<li>流式模型</li>
</ul>
<h3 id="消费方式"><a href="#消费方式" class="headerlink" title="消费方式"></a>消费方式</h3><ul>
<li>独占</li>
<li>故障切换</li>
<li>共享</li>
</ul>
<h2 id="消息消费模型"><a href="#消息消费模型" class="headerlink" title="消息消费模型"></a>消息消费模型</h2><p>在实时流式架构中，消息传递可以分为两类：队列（Queue）和流（Stream）。</p>
<h3 id="队列（Queue）模型"><a href="#队列（Queue）模型" class="headerlink" title="队列（Queue）模型"></a>队列（Queue）模型</h3><p>队列模型主要是采用无序或者共享的方式来消费消息。通过队列模型，<strong>用户可以创建多个消费者从单个管道中接收消息；当一条消息从队列发送出来后，多个消费者中的只有一个（任何一个都有可能）接收和消费这条消息。</strong>消息系统的具体实现决定了最终哪个消费者实际接收到消息。</p>
<p>队列模型通常与无状态应用程序一起结合使用。无状态应用程序不关心排序，但它们确实需要能够确认（ack）或删除单条消息，以及尽可能地扩展消费并行性的能力。典型的基于队列模型的消息系统包括 RabbitMQ 和RocketMQ。</p>
<h3 id="流式（Stream）模型"><a href="#流式（Stream）模型" class="headerlink" title="流式（Stream）模型"></a>流式（Stream）模型</h3><p>相比之下，流模型要求消息的消费严格排序或独占消息消费。对于一个管道，使用流式模型，始终只会有一个消费者使用和消费消息。消费者按照消息写入管道的确切顺序接收从管道发送的消息。</p>
<p>流模型通常与有状态应用程序相关联。有状态的应用程序更加关注消息的顺序及其状态。消息的消费顺序决定了有状态应用程序的状态。消息的顺序将影响应用程序处理逻辑的正确性。</p>
<h2 id="Pulsar的消息消费模型"><a href="#Pulsar的消息消费模型" class="headerlink" title="Pulsar的消息消费模型"></a>Pulsar的消息消费模型</h2><p>Apache Pulsar通过“订阅”，抽象出了统一的: producer-topic-subscription-consumer 消费模型。Pulsar的消息模型既支持队列模型，也支持流模型。</p>
<p>在Pulsar的消息消费模型中，Topic是用于发送消息的通道。每一个Topic对应着Apache BookKeeper中的一个分布式日志。发布者发布的每条消息只在Topic中存储一次；存储的过程中，BookKeeper会将消息复制存储在多个存储节点上；Topic中的每条消息，可以根据消费者的订阅需求，多次被使用，每个订阅对应一个消费者组（Consumer Group）。</p>
<p>主题（Topic）是消费消息的真实来源。尽管消息仅在主题（Topic）上存储一次，但是用户可以有不同的订阅方式来消费这些消息：</p>
<ul>
<li>消费者被组合在一起以消费消息，每个消费组是一个订阅。</li>
<li>每个Topic可以有不同的消费组。</li>
<li>每组消费者都是对主题的一个订阅。</li>
<li>每组消费者可以拥有自己不同的消费方式： 独占（Exclusive），故障切换（Failover）或共享（Share）。</li>
</ul>
<p>Pulsar通过这种模型，将队列模型和流模型这两种模型结合在了一起，提供了统一的API接口。 这种模型，既不会影响消息系统的性能，也不会带来额外的开销，同时还为用户提供了更多灵活性，方便用户程序以最匹配模式来使用消息系统。</p>
<h3 id="独占订阅（Stream流模型）"><a href="#独占订阅（Stream流模型）" class="headerlink" title="独占订阅（Stream流模型）"></a>独占订阅（Stream流模型）</h3><p>顾名思义，独占订阅中，在任何时间，一个消费者组（订阅）中有且只有一个消费者来消费Topic中的消息。下图是独占订阅的示例。在这个示例中有一个有订阅A的活跃消费者A-0，消息m0到m4按顺序传送并由A-0消费。如果另一个消费者A-1想要附加到订阅A，则是不被允许的。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/s4PeDf"><img src="https://s3.ax1x.com/2021/01/21/s4PeDf.md.png" alt="s4PeDf.md.png"></a></p>
<h3 id="故障切换（Stream流模型）"><a href="#故障切换（Stream流模型）" class="headerlink" title="故障切换（Stream流模型）"></a>故障切换（Stream流模型）</h3><p>使用故障切换订阅，一个消费者组（订阅）中可以有多个消费者（Consumer）可以附加到同一订阅。 但是，一个订阅中的所有消费者，只会有一个消费者被选为该订阅的主消费者。 其他消费者将被指定为故障转移消费者。<br>当主消费者断开连接时，分区将被重新分配给其中一个故障转移消费者，而新分配的消费者将成为新的主消费者。 发生这种情况时，所有未确认（ack）的消息都将传递给新的主消费者。 这类似于Apache Kafka中的Consumer partition rebalance。</p>
<p>下图是故障切换订阅的示例。 消费者B-0和B-1通过订阅B订阅消费消息。B-0是主消费者并接收所有消息。 B-1是故障转移消费者，如果消费者B-0出现故障，它将接管消费。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/s4PhPH"><img src="https://s3.ax1x.com/2021/01/21/s4PhPH.md.png" alt="s4PhPH.md.png"></a></p>
<h3 id="共享订阅（Queue队列模型）"><a href="#共享订阅（Queue队列模型）" class="headerlink" title="共享订阅（Queue队列模型）"></a>共享订阅（Queue队列模型）</h3><p>使用共享订阅，在同一个订阅背后，用户按照应用的需求挂载任意多的消费者。 订阅中的所有消息以循环分发形式发送给订阅背后的多个消费者，并且一个消息仅传递给一个消费者。</p>
<p>当消费者断开连接时，所有传递给它但是未被确认（ack）的消息将被重新分配和组织，以便发送给该订阅上剩余的剩余消费者。</p>
<p>下图是共享订阅的示例。 消费者C-1，C-2和C-3都在同一主题上消费消息。 每个消费者接收大约所有消息的1&#x2F;3。<br>如果想提高消费的速度，用户不需要不增加分区数量，只需要在同一个订阅中添加更多的消费者。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/s4iQeK"><img src="https://s3.ax1x.com/2021/01/21/s4iQeK.md.png" alt="s4iQeK.md.png"></a></p>
<h3 id="三种订阅模式的选择"><a href="#三种订阅模式的选择" class="headerlink" title="三种订阅模式的选择"></a>三种订阅模式的选择</h3><p>独占和故障切换订阅，仅允许一个消费者来使用和消费，每个对主题的订阅。这两种模式都按主题分区顺序使用消息。它们最适用于需要严格消息顺序的流（Stream）用例。</p>
<p>共享订阅允许每个主题分区有多个消费者。同一订阅中的每个消费者仅接收主题分区的一部分消息。共享订阅最适用于不需要保证消息顺序的队列（Queue）的使用模式，并且可以按照需要任意扩展消费者的数量。</p>
<p>pulsar 的订阅实际上与Apache Kafka中的Consumer Group的概念类似。创建订阅的操作很轻量化，而且具有高度可扩展性，用户可以根据应用的需要创建任意数量的订阅。</p>
<p>对同一主题的不同订阅，也可以采用不同的订阅类型。比如用户可以在同一主题上可以提供一个包含3个消费者的故障切换订阅，同时也提供一个包含20个消费者的共享订阅，并且可以在不改变分区数量的情况下，向共享订阅添加更多的消费者。</p>
<p>下图描绘了一个包含3个订阅A，B和C的主题，并说明了消息如何从生产者流向消费者。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/s4F8BV"><img src="https://s3.ax1x.com/2021/01/21/s4F8BV.md.png" alt="s4F8BV.md.png"></a></p>
<h2 id="Pulsar的消息确认（ACK）"><a href="#Pulsar的消息确认（ACK）" class="headerlink" title="Pulsar的消息确认（ACK）"></a>Pulsar的消息确认（ACK）</h2><p>由于分布式系统的特性，当使用分布式消息系统时，可能会发生故障。比如在消费者从消息系统中的主题消费消息的过程中，消费消息的消费者和服务于主题分区的消息代理（Broker）都可能发生错误。消息确认（ACK）的目的就是保证当发生这样的故障后，消费者能够从上一次停止的地方恢复消费，保证既不会丢失消息，也不会重复处理已经确认（ACK）的消息。</p>
<p>在Apache Kafka中，恢复点通常称为Offset，更新恢复点的过程称为消息确认或提交Offset。</p>
<p>在Apache Pulsar中，每个订阅中都使用一个专门的数据结构–游标（Cursor）来跟踪订阅中的每条消息的确认（ACK）状态。每当消费者在主题分区上确认消息时，游标都会更新。更新游标可确保消费者不会再次收到消息。</p>
<p>Apache Pulsar提供两种消息确认方法，单条确认（Individual Ack）和累积确认（Cumulative Ack）。通过累积确认，消费者只需要确认它收到的最后一条消息。主题分区中的所有消息（包括）提供消息ID将被标记为已确认，并且不会再次传递给消费者。累积确认与Apache Kafka中的Offset更新类似。</p>
<p>Apache Pulsar可以支持消息的单条确认，也就是选择性确认。消费者可以单独确认一条消息。 被确认后的消息将不会被重新传递。下图说明了单条确认和累积确认的差异（灰色框中的消息被确认并且不会被重新传递）。在图的上半部分，它显示了累计确认的一个例子，M12之前的消息被标记为acked。在图的下半部分，它显示了单独进行acking的示例。仅确认消息M7和M12 - 在消费者失败的情况下，除了M7和M12之外，其他所有消息将被重新传送。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/s4FHUS"><img src="https://s3.ax1x.com/2021/01/21/s4FHUS.md.png" alt="s4FHUS.md.png"></a>  </p>
<p>独占订阅或故障切换订阅的消费者能够对消息进行单条确认和累积确认；共享订阅的消费者只允许对消息进行单条确认。单条确认消息的能力为处理消费者故障提供了更好的体验。对于某些应用来说，处理一条消息可能需要很长时间或者非常昂贵，防止重新传送已经确认的消息非常重要。</p>
<p><strong>这个管理Ack的专门的数据结构–游标（Cursor），由Broker来管理，利用BookKeeper的Ledger提供存储，在后面的文章中我们会介绍更多的关于游标（Cursor）的细节。</strong></p>
<p>Apache Pulsar提供了灵活的消息消费订阅类型和消息确认方法，通过简单的统一的API，就可以支持各种消息和流的使用场景。</p>
<h2 id="Pulsar的消息保留（Retention）"><a href="#Pulsar的消息保留（Retention）" class="headerlink" title="Pulsar的消息保留（Retention）"></a>Pulsar的消息保留（Retention）</h2><p>在消息被确认后，Pulsar的Broker会更新对应的游标。当Topic里面中的一条消息，被所有的订阅都确认ack后，才能删除这条消息。Pulsar还允许通过设置保留时间，将消息保留更长时间，即使所有订阅已经确认消费了它们。</p>
<p><strong>如果没有设置保留时间，那么所有的订阅者ack后，消息就会被删除。特殊的，如果一个订阅者都没有，那么pulsar会将消息直接扔起。</strong></p>
<p>下图说明了如何在有2个订阅的主题中保留消息。订阅A在M6和订阅B已经消耗了M10之前的所有消息之前已经消耗了所有消息。这意味着M6之前的所有消息（灰色框中）都可以安全删除。订阅A仍未使用M6和M9之间的消息，无法删除它们。如果主题配置了消息保留期，则消息M0到M5将在配置的时间段内保持不变，即使A和B已经确认消费了它们。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/s4kD2j"><img src="https://s3.ax1x.com/2021/01/21/s4kD2j.md.png" alt="s4kD2j.md.png"></a></p>
<p>在消息保留策略中，Pulsar还支持消息生存时间（TTL）。如果消息未在配置的TTL时间段内被任何消费者使用，则消息将自动标记为已确认。 消息保留期消息TTL之间的区别在于：消息保留期作用于标记为已确认并设置为已删除的消息，而TTL作用于未ack的消息。 上面的图例中说明了Pulsar中的TTL。 例如，如果订阅B没有活动消费者，则在配置的TTL时间段过后，消息M10将自动标记为已确认，即使没有消费者实际读取该消息。</p>
<h2 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h2><h3 id="模型概念"><a href="#模型概念" class="headerlink" title="模型概念"></a>模型概念</h3><p>Kafka： Producer - topic - consumer group - consumer；</p>
<p>Pulsar：Producer - topic - subscription - consumer。 </p>
<h3 id="消费模式"><a href="#消费模式" class="headerlink" title="消费模式"></a>消费模式</h3><p>Kafka： 主要集中在流（Stream）模式，对单个 partition 是独占消费，没有共享（Queue）的消费模式；</p>
<p>Pulsar：提供了统一的消息模型和 API。流（Stream）模式——独占和故障切换订阅方式；队列（Queue）模式——共享订阅的方式。</p>
<h3 id="消息确认（Ack）"><a href="#消息确认（Ack）" class="headerlink" title="消息确认（Ack）"></a>消息确认（Ack）</h3><p>Kafka： 使用偏移 Offset；</p>
<p>Pulsar：使用专门的 Cursor 管理。累积确认和 Kafka 效果一样；提供单条或选择性确认。</p>
<h3 id="消息保留"><a href="#消息保留" class="headerlink" title="消息保留"></a>消息保留</h3><p>Kafka：根据设置的保留期来删除消息。有可能消息没被消费，过期后被删除。 不支持 TTL。</p>
<p>Pulsar：消息只有被所有订阅消费后才会删除，不会丢失数据。也允许设置保留期，保留被消费的数据。支持 TTL。</p>
<h3 id="消息路径"><a href="#消息路径" class="headerlink" title="消息路径"></a>消息路径</h3><p>zk 都记录了 topic （或分区topic）被分配到了 哪个 broker，生产者和消费者都依此来将消息发送到指定的broker。在发送消息时，可以指定消息发送到指定的分区topic，或者指定key和哈希策略。</p>
<p>kafka： 在 producer 端，一条消息会通过生产者的运算，指定发送到 topic 的一个分区，一个分区对应着一个 broker。在 broker 端，消息日志存储在分区中。在消息端，一个消费组，对于 topic 的一个 分区的 offset 是被记录了的。一个消费组中的多个消息者负载均衡地消费多个分区的消息，体现为一个消费者消费一个或多个分区的消息。在kafka中，消费组中参与消费的消费者的个数上限是分区的个数。</p>
<p>pulsar：在 producer 端，一条消息会通过运算，指定发送到 topic 的一个分区。一个分区对应着一个 broker（由 broker 集群来负载均衡，并由 zk 来记录元数据）。在 broker 端，一个分区的消息被存放在多个 bookie 中（数据镜像）。一个分区的数据被存在哪些 bookie 中，有 zk 来记录。一个订阅名（且在shared模式）中的多个消费者负载均衡地消费一个 topic 的数据。在pulsar中，订阅名中参与消费的消费者的个数没有上限。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/XJ3vj9xeDpdqZr-um8wBug">Pulsar VS. Kafka（1）: 统一的消息消费模型（Queue + Stream）</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/05/message%20queue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%8A%95%E9%80%92%E8%AF%AD%E4%B9%89%E5%92%8C%E6%B6%88%E8%B4%B9%E8%AF%AD%E4%B9%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/05/message%20queue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%8A%95%E9%80%92%E8%AF%AD%E4%B9%89%E5%92%8C%E6%B6%88%E8%B4%B9%E8%AF%AD%E4%B9%89/" class="post-title-link" itemprop="url">消息队列之消息队列的消费语义和投递语义</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-05 19:40:37" itemprop="dateCreated datePublished" datetime="2020-11-05T19:40:37+08:00">2020-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="三种语义保证"><a href="#三种语义保证" class="headerlink" title="三种语义保证"></a>三种语义保证</h3><h4 id="At-most-once"><a href="#At-most-once" class="headerlink" title="At most once"></a>At most once</h4><p>消息可能会丢，但是绝对不会重复传递。</p>
<h4 id="At-least-once"><a href="#At-least-once" class="headerlink" title="At least once"></a>At least once</h4><p>消息绝对不会丢，但是可能重复传递。</p>
<h4 id="Exactly-once"><a href="#Exactly-once" class="headerlink" title="Exactly once"></a>Exactly once</h4><p>每条消息之传输一次仅被传输一次。</p>
<h3 id="消费语义与投递语义"><a href="#消费语义与投递语义" class="headerlink" title="消费语义与投递语义"></a>消费语义与投递语义</h3><p>所谓的消费语义，指的就是如下三种情况</p>
<ul>
<li>如何保证消息最多消费一次</li>
<li>如何保证消息至少消费一次</li>
<li>如何保证消息恰好消费一次</li>
</ul>
<p>其实类似还有一个投递语义</p>
<ul>
<li>如何保证消息最多投递一次</li>
<li>如何保证消息至少投递一次</li>
<li>如何保证消息恰好投递一次</li>
</ul>
<h2 id="投递语义"><a href="#投递语义" class="headerlink" title="投递语义"></a>投递语义</h2><p>我们先做如下约定</p>
<ul>
<li><code>Producer</code>代表生产者</li>
<li><code>Consumer</code>代表消费者</li>
<li><code>Message Queue</code>代表消息队列</li>
</ul>
<p>我们先从投递语义开始讲起，因为要先把这个概念讲明白了，才能讲消费语义。恰巧，<code>kafka</code>实现了这三种语义，我们以<code>kafka</code>来说明。</p>
<h3 id="如何保证消息最多投递一次"><a href="#如何保证消息最多投递一次" class="headerlink" title="如何保证消息最多投递一次?"></a>如何保证消息最多投递一次?</h3><p>简单，就是我已经投出去了，收没收到不管了，会存在消息丢失。</p>
<p>我们在初始化<code>Producer</code>时可以通过配置<code>request.required.acks</code>不同的值,来实现不同的发送模式。这里将<code>request.required.acks</code>设为0，意思就是<code>Producer</code>不等待Leader确认，只管发出即可；最可能丢失消息。如果丢了消息，就是投递0次。如果没丢，就是投递1次。符合最多投递一次的含义。</p>
<h3 id="如何保证消息至少投递一次"><a href="#如何保证消息至少投递一次" class="headerlink" title="如何保证消息至少投递一次?"></a>如何保证消息至少投递一次?</h3><p>这里将<code>request.required.acks</code>设为-1。<code>Producer</code>往<code>kafka</code>的<code>Leader（主）</code>节点发送消息后，会等<code>follower(从)</code>节点同步完数据以后，再给<code>Producer</code>返回ACK确认消息。但是这里是有几率出现重复消费的问题的。</p>
<p>例如，<code>kafka</code>保存消息后，发送ACK前宕机，<code>Producer</code>认为消息未发送成功并重试，造成数据重复！<br>那么，在这种情况下，就会出现大于1次的投递情况，符合至少投递一次的含义。</p>
<h3 id="如何保证消息恰好投递一次"><a href="#如何保证消息恰好投递一次" class="headerlink" title="如何保证消息恰好投递一次?"></a>如何保证消息恰好投递一次?</h3><p><code>kafka</code>在0.11.0.0版本之后支持恰好投递一次的语义。我们将<code>enable.idempotence</code>设置为ture,此时就会默认把<code>request.required.acks</code>设为-1，可以达到恰好投递一次的语义。</p>
<p>为了实现<code>Producer</code>的幂等语义，Kafka引入了Producer ID（即PID）和Sequence Number。<code>kafka</code>为每个<code>Producer</code>分配一个pid，作为该<code>Producer</code>的唯一标识。<code>Producer</code>会为每一个&lt;topic,partition&gt;维护一个单调递增的seq。类似的，<code>Message Queue</code>也会为每个**&lt;pid,topic,partition&gt;记录下最新的seq**。当req_seq &#x3D;&#x3D; message_seq+1时，<code>Message Queue</code>才会接受该消息。因为：</p>
<ul>
<li>(1)消息的seq比<code>Message Queue</code>的seq大一以上，说明中间有数据还没写入，即乱序了。</li>
<li>(2)消息的seq比<code>Message Queue</code>的seq小，那么说明该消息已被保存。</li>
</ul>
<p><strong>这里参考了 tcp seq number 的设计，用来保证顺序和去重。</strong></p>
<p>这里的幂等性需要客户端的支持，即客户端需要每次都带上自己的自增的 sequence number.</p>
<h2 id="消费语义"><a href="#消费语义" class="headerlink" title="消费语义"></a>消费语义</h2><p>这里我们还是做一个定义如下所示</p>
<ul>
<li><code>consumer.poll()</code>表示消费者获取消息内容</li>
<li><code>processMsg(message)</code>表示下游系统进行消费消息</li>
<li><code>consumer.commit()</code>表示消费者往消息队列提交确认信息，消息队列接到确认消息，删除该消息。</li>
</ul>
<p>注意了，我是以<code>processMsg</code>函数，即处理消息的过程，定义为消费消息。</p>
<h3 id="如何保证消息最多消费一次"><a href="#如何保证消息最多消费一次" class="headerlink" title="如何保证消息最多消费一次?"></a>如何保证消息最多消费一次?</h3><p><code>Producer</code>:满足最多投递一次的语义即可，即只管发消息，不需要等待消息队列返回确认消息。</p>
<p><code>Message Queue</code>:接到消息后往内存中一放就行，不用持久化存储。</p>
<p><code>Consumer</code>：拉取到消息以后，直接给消息队列返回确认消息即可。至于后续消费消息成功与否，无所谓的。即按照以下顺序执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">consumer.poll();</span><br><span class="line">consumer.commit();</span><br><span class="line">processMsg(message);</span><br></pre></td></tr></table></figure>

<h3 id="如何保证消息至少消费一次"><a href="#如何保证消息至少消费一次" class="headerlink" title="如何保证消息至少消费一次?"></a>如何保证消息至少消费一次?</h3><p><code>Producer</code>:满足至少投递一次语义即可，即发送消息后，需要等待消息队列返回确认消息。如果超时没收到确认消息，则重发。</p>
<p><code>Message Queue</code>:接到消息后，进行持久化存储，而后返回生产者确认消息。</p>
<p><code>Consumer</code>：拉取到消息后，进行消费，消费成功后，再返回确认消息。即按照如下顺序执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">consumer.poll();</span><br><span class="line">processMsg(message);</span><br><span class="line">consumer.commit();</span><br></pre></td></tr></table></figure>

<p>由于这里<code>Producer</code>满足的是至少投递一次语义，因此消息队列中是有重复消息的。所以我们的<code>Consumer</code>会出现重复消费的情形！</p>
<h3 id="如何保证消息恰好消费一次"><a href="#如何保证消息恰好消费一次" class="headerlink" title="如何保证消息恰好消费一次?"></a>如何保证消息恰好消费一次?</h3><p>在保证至少消费一次的基础上，<code>processMsg</code>满足幂等性操作即可。</p>
<h2 id="如何保证函数幂等性"><a href="#如何保证函数幂等性" class="headerlink" title="如何保证函数幂等性"></a>如何保证函数幂等性</h2><p>doc: blog&#x2F;learn&#x2F;幂等性</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/rjzheng/p/11050673.html">【原创】消息队列的消费语义和投递语义</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/72328153">https://zhuanlan.zhihu.com/p/72328153</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/04/algorithm/%E7%AE%97%E6%B3%95%E4%B9%8Bgo-zero%20%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/04/algorithm/%E7%AE%97%E6%B3%95%E4%B9%8Bgo-zero%20%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">算法之go-zero 一致性哈希的实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-04 16:02:37" itemprop="dateCreated datePublished" datetime="2020-11-04T16:02:37+08:00">2020-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ConsistentHash <span class="keyword">struct</span> &#123;</span><br><span class="line">	hashFunc HashFunc</span><br><span class="line">	replicas <span class="type">int</span></span><br><span class="line">	<span class="comment">// keys 里面记录所有的 hash 值</span></span><br><span class="line">	<span class="comment">// hash 值 = (nodeRepr + i) 的结果做哈希运算</span></span><br><span class="line">	keys     []<span class="type">uint64</span></span><br><span class="line">	<span class="comment">// 记录一个 hash 值对应的 多个node, key 是 hash 值， val 是 node 数组</span></span><br><span class="line">	<span class="comment">// 这里使用开链法解决哈希冲突 (实际是数组)</span></span><br><span class="line">	ring     <span class="keyword">map</span>[<span class="type">uint64</span>][]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 记录 node 是否在一致性 hash 中, key 是 nodeRepr</span></span><br><span class="line">	nodes    <span class="keyword">map</span>[<span class="type">string</span>]lang.PlaceholderType</span><br><span class="line">	lock     sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="新建一致性hash环"><a href="#新建一致性hash环" class="headerlink" title="新建一致性hash环"></a>新建一致性hash环</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCustomConsistentHash</span><span class="params">(replicas <span class="type">int</span>, fn HashFunc)</span></span> *ConsistentHash &#123;</span><br><span class="line">    <span class="comment">// 规定最小副本 为 100</span></span><br><span class="line">	<span class="keyword">if</span> replicas &lt; minReplicas &#123;</span><br><span class="line">		replicas = minReplicas</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> fn == <span class="literal">nil</span> &#123;</span><br><span class="line">		fn = Hash</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;ConsistentHash&#123;</span><br><span class="line">		hashFunc: fn,</span><br><span class="line">		replicas: replicas,</span><br><span class="line">		ring:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">uint64</span>][]<span class="keyword">interface</span>&#123;&#125;),</span><br><span class="line">		nodes:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]lang.PlaceholderType),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ConsistentHash)</span></span> AddWithReplicas(node <span class="keyword">interface</span>&#123;&#125;, replicas <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">// 先删除节点， 避免重复添加相同的节点</span></span><br><span class="line">	h.Remove(node)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> replicas &gt; h.replicas &#123;</span><br><span class="line">		replicas = h.replicas</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 计算节点的一个算术字符串</span></span><br><span class="line">	nodeRepr := repr(node)</span><br><span class="line">	h.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> h.lock.Unlock()</span><br><span class="line">	<span class="comment">// 标记这个节点在 一致性hash环中</span></span><br><span class="line">	h.addNode(nodeRepr)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向 一致性hash环中添加 replicas 个虚拟节点</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; replicas; i++ &#123;</span><br><span class="line">		hash := h.hashFunc([]<span class="type">byte</span>(nodeRepr + strconv.Itoa(i)))</span><br><span class="line">		h.keys = <span class="built_in">append</span>(h.keys, hash)</span><br><span class="line">		h.ring[hash] = <span class="built_in">append</span>(h.ring[hash], node)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 排序，方便后面二分查找</span></span><br><span class="line">	sort.Slice(h.keys, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> h.keys[i] &lt; h.keys[j]</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ConsistentHash)</span></span> Remove(node <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	nodeRepr := repr(node)</span><br><span class="line"></span><br><span class="line">	h.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> h.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 节点不存在，直接 return</span></span><br><span class="line">	<span class="keyword">if</span> !h.containsNode(nodeRepr) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除节点的每一个虚拟节点</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; h.replicas; i++ &#123;</span><br><span class="line">		hash := h.hashFunc([]<span class="type">byte</span>(nodeRepr + strconv.Itoa(i)))</span><br><span class="line">		<span class="comment">// 找到 &gt;= 当前 hash 值的第一个 h.keys 的下标</span></span><br><span class="line">		index := sort.Search(<span class="built_in">len</span>(h.keys), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> h.keys[i] &gt;= hash</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="comment">// 删除 keys 中值， 使用切片操作</span></span><br><span class="line">		<span class="keyword">if</span> index &lt; <span class="built_in">len</span>(h.keys) &#123;</span><br><span class="line">			h.keys = <span class="built_in">append</span>(h.keys[:index], h.keys[index+<span class="number">1</span>:]...)</span><br><span class="line">		&#125;</span><br><span class="line">		h.removeRingNode(hash, nodeRepr)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除节点的 存在判断标志</span></span><br><span class="line">	h.removeNode(nodeRepr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除 哈希环 中的虚拟节点，考虑 hash 冲突的问题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ConsistentHash)</span></span> removeRingNode(hash <span class="type">uint64</span>, nodeRepr <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> nodes, ok := h.ring[hash]; ok &#123;</span><br><span class="line">		newNodes := nodes[:<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">for</span> _, x := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">			<span class="keyword">if</span> repr(x) != nodeRepr &#123;</span><br><span class="line">				newNodes = <span class="built_in">append</span>(newNodes, x)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(newNodes) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			h.ring[hash] = newNodes</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">delete</span>(h.ring, hash)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用一致性-hash-空间，负载请求"><a href="#使用一致性-hash-空间，负载请求" class="headerlink" title="使用一致性 hash 空间，负载请求"></a>使用一致性 hash 空间，负载请求</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	v 实际上就是一个 key， 更具体的，例如这是一个 redis 多个单节点，通过这个一致性 hash 算法来负载的情况，</span></span><br><span class="line"><span class="comment">	这里的 v 就是 redis 的那个 key， 这将让 对同一个 key 的 操作始终被负载到同一个 redis node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ConsistentHash)</span></span> Get(v <span class="keyword">interface</span>&#123;&#125;) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;</span><br><span class="line">	h.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> h.lock.RUnlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(h.ring) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hash := h.hashFunc([]<span class="type">byte</span>(repr(v)))</span><br><span class="line">	index := sort.Search(<span class="built_in">len</span>(h.keys), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> h.keys[i] &gt;= hash</span><br><span class="line">	&#125;) % <span class="built_in">len</span>(h.keys)</span><br><span class="line"></span><br><span class="line">	nodes := h.ring[h.keys[index]]</span><br><span class="line">	<span class="keyword">switch</span> <span class="built_in">len</span>(nodes) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> nodes[<span class="number">0</span>], <span class="literal">true</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// 有 hash 冲突，从  inner 数组中 选一个</span></span><br><span class="line">		innerIndex := h.hashFunc([]<span class="type">byte</span>(innerRepr(v)))</span><br><span class="line">		pos := <span class="type">int</span>(innerIndex % <span class="type">uint64</span>(<span class="built_in">len</span>(nodes)))</span><br><span class="line">		<span class="keyword">return</span> nodes[pos], <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用分析"><a href="#使用分析" class="headerlink" title="使用分析"></a>使用分析</h2><h3 id="多个-单点-redis-使用一致性-hash-负载"><a href="#多个-单点-redis-使用一致性-hash-负载" class="headerlink" title="多个 单点 redis 使用一致性 hash 负载"></a>多个 单点 redis 使用一致性 hash 负载</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> clusterStore <span class="keyword">struct</span> &#123;</span><br><span class="line">		dispatcher *hash.ConsistentHash</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStore</span><span class="params">(c KvConf)</span></span> Store &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(c) == <span class="number">0</span> || cache.TotalWeights(c) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;no cache nodes&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// even if only one node, we chose to use consistent hash,</span></span><br><span class="line">	<span class="comment">// because Store and redis.Redis has different methods.</span></span><br><span class="line">	dispatcher := hash.NewConsistentHash()</span><br><span class="line">	<span class="keyword">for</span> _, node := <span class="keyword">range</span> c &#123;</span><br><span class="line">		cn := node.NewRedis()</span><br><span class="line">		dispatcher.AddWithWeight(cn, node.Weight)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> clusterStore&#123;</span><br><span class="line">		dispatcher: dispatcher,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缓存操作的例子"><a href="#缓存操作的例子" class="headerlink" title="缓存操作的例子"></a>缓存操作的例子</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 缓存操作中的 SetCache为例子</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc cacheCluster)</span></span> SetCache(key <span class="type">string</span>, v <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 从 哈希环中，以key为 hash 计算的值， 得到当前应该访问的节点</span></span><br><span class="line">	c, ok := cc.dispatcher.Get(key)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> cc.errNotFound</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c.(Cache).SetCache(key, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/03/algorithm/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/03/algorithm/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">算法之延迟队列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-03 20:53:33" itemprop="dateCreated datePublished" datetime="2020-11-03T20:53:33+08:00">2020-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-08 19:55:34" itemprop="dateModified" datetime="2023-02-08T19:55:34+08:00">2023-02-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>延时队列相比于普通队列最大的区别就体现在其延时的属性上，普通队列的元素是先进先出，按入队顺序进行处理，而延时队列中的元素在入队时会指定一个延迟时间，表示其希望能够在经过该指定时间后处理。从某种意义上来讲，延迟队列的结构并不像一个队列，而更像是一种以时间为权重的有序堆结构。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>延迟队列的应用场景非常的广泛，比如说以下的场景：</p>
<ul>
<li>新建的订单，如果用户在15分钟内未支付，则自动取消。</li>
<li>公司的会议预定系统，在会议预定成功后，会在会议开始前半小时通知所有预定该会议的用户。</li>
<li>安全工单超过24小时未处理，则自动拉企业微信群提醒相关责任人。</li>
<li>用户下单外卖以后，距离超时时间还有10分钟时提醒外卖小哥即将超时。</li>
<li>买家收到订单后， 一天内没有评价，向买家发消息，要求评价</li>
</ul>
<p>总体来说就是，一个事件后，一段时间内没有发什么 A 事件，那么就需要发什么 B 事件。</p>
<h2 id="几种实现方式"><a href="#几种实现方式" class="headerlink" title="几种实现方式"></a>几种实现方式</h2><h3 id="redis-zset"><a href="#redis-zset" class="headerlink" title="redis zset"></a>redis zset</h3><p>那么我们可以通过以下这几个操作使用Redis的ZSet来实现一个延迟队列：</p>
<ul>
<li>入队操作：ZADD KEY timestamp task, 我们将需要处理的任务，按其需要延迟处理时间作为Score加入到ZSet中。Redis的ZAdd的时间复杂度是O(logN)，N是ZSet中元素个数，因此我们能相对比较高效的进行入队操作。</li>
<li>起一个进程定时（比如每隔一秒）通过ZREANGEBYSCORE方法查询ZSet中Score最小的元素，具体操作为：ZRANGEBYSCORE KEY -inf +inf limit 0 1 WITHSCORES。查询结果有两种情况：</li>
<li>查询出的分数小于等于当前时间戳，说明到这个任务需要执行的时间了，则去异步处理该任务；</li>
<li>查询出的分数大于当前时间戳，由于刚刚的查询操作取出来的是分数最小的元素，所以说明ZSet中所有的任务都还没有到需要执行的时间，则休眠一秒后继续查询；</li>
</ul>
<p>同样的，ZRANGEBYSCORE操作的时间复杂度为O(logN + M)，其中N为ZSet中元素个数，M为查询的元素个数，因此我们定时查询操作也是比较高效的。</p>
<h3 id="rabitmq-死信队列"><a href="#rabitmq-死信队列" class="headerlink" title="rabitmq 死信队列"></a>rabitmq 死信队列</h3><p>RabbitMQ本身并不直接提供对延迟队列的支持，我们依靠RabbitMQ的TTL以及死信队列功能，来实现延迟队列的效果。那就让我们首先来了解一下，RabbitMQ的死信队列以及TTL功能。</p>
<p>死信队列实际上是一种RabbitMQ的消息处理机制，当RabbmitMQ在生产和消费消息的时候，消息遇到如下的情况，就会变成“死信”：</p>
<ul>
<li>消息被拒绝basic.reject&#x2F; basic.nack 并且不再重新投递 requeue&#x3D;false</li>
<li>消息超时未消费，也就是TTL过期了</li>
<li>消息队列到达最大长度</li>
</ul>
<p>消息一旦变成一条死信，便会被重新投递到死信交换机（Dead-Letter-Exchange），然后死信交换机根据绑定规则转发到对应的死信队列上，监听该队列就可以让消息被重新消费。</p>
<h3 id="时间轮算法（TimeWheel）"><a href="#时间轮算法（TimeWheel）" class="headerlink" title="时间轮算法（TimeWheel）"></a>时间轮算法（TimeWheel）</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/F03VdOKPlCkFpeHEvjwK0kibWiaibXdc9UFiaCD1iakiatg0uf919YAVW3s9rT99jWShYiaPMSKwEMYYQj1jkwZZ7axkg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p>
<p>如上图所示，时间轮是一个存储延迟消息的环形队列，其底层采用数组实现，可以高效循环遍历。这个环形队列中的每个元素对应一个延迟任务列表，这个列表是一个双向环形链表，链表中每一项都代表一个需要执行的延迟任务。</p>
<p>时间轮会有表盘指针，表示时间轮当前所指时间，随着时间推移，该指针会不断前进，并处理对应位置上的延迟任务列表。</p>
<h4 id="多层时间轮"><a href="#多层时间轮" class="headerlink" title="多层时间轮"></a>多层时间轮</h4><p>到现在为止一切都非常棒，但是细心的同学可能发现了，上面的时间轮的大小是固定的，只有12秒。如果此时我们有一个需要延迟200秒的任务，我们应该怎么处理呢？直接扩充整个时间轮的大小吗？这显然不可取，因为这样做的话我们就需要维护一个非常非常大的时间轮，内存是不可接受的，而且底层数组大了之后寻址效率也会降低，影响性能。</p>
<p>为此，Kafka引入了多层时间轮的概念。其实多层时间轮的概念和我们的机械表上时针、分针、秒针的概念非常类似，当仅使用秒针无法表示当前时间时，就使用分针结合秒针一起表示。同样的，当任务的到期时间超过了当前时间轮所表示的时间范围时，就会尝试添加到上层时间轮中。</p>
<h4 id="go-zero-中的堆多层时间轮算法的实现"><a href="#go-zero-中的堆多层时间轮算法的实现" class="headerlink" title="go-zero 中的堆多层时间轮算法的实现"></a>go-zero 中的堆多层时间轮算法的实现</h4><h5 id="时间轮结构"><a href="#时间轮结构" class="headerlink" title="时间轮结构"></a>时间轮结构</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TimingWheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    interval      time.Duration</span><br><span class="line">    ticker        timex.Ticker</span><br><span class="line">    slots         []*list.List <span class="comment">// 时间轮，每一个slot里是一个任务双向链表</span></span><br><span class="line">    timers        *SafeMap</span><br><span class="line">    tickedPos     <span class="type">int</span></span><br><span class="line">    numSlots      <span class="type">int</span></span><br><span class="line">    execute       Execute</span><br><span class="line">    setChannel    <span class="keyword">chan</span> timingEntry</span><br><span class="line">    moveChannel   <span class="keyword">chan</span> baseEntry</span><br><span class="line">    removeChannel <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    drainChannel  <span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line">    stopChannel   <span class="keyword">chan</span> lang.PlaceholderType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="设置延迟任务"><a href="#设置延迟任务" class="headerlink" title="设置延迟任务"></a>设置延迟任务</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算在 slots 中的位置，以及需要转几圈（使用圈层下降的方法来实现多层时间轮）</span></span><br><span class="line">pos, circle := tw.getPositionAndCircle(task.delay)</span><br><span class="line"></span><br><span class="line">newItem := &amp;timingEntry&#123;</span><br><span class="line">    baseEntry: task,</span><br><span class="line">    value:     timer.item.value,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">timer.item.circle = circle</span><br><span class="line">newItem := &amp;timingEntry&#123;</span><br><span class="line">baseEntry: task,</span><br><span class="line">    value:     timer.item.value,</span><br><span class="line">&#125;</span><br><span class="line">tw.slots[pos].PushBack(newItem)</span><br><span class="line"><span class="comment">//  向时间轮中设置 task</span></span><br><span class="line">tw.setTimerPosition(pos, newItem)</span><br></pre></td></tr></table></figure>

<h5 id="时间推动"><a href="#时间推动" class="headerlink" title="时间推动"></a>时间推动</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTicker</span><span class="params">(d time.Duration)</span></span> Ticker &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;realTicker&#123;</span><br><span class="line">        Ticker: time.NewTicker(d),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 golang 的 Ticker 来实现时间推动， 移动时间轮上的 slots 的 index</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rt *realTicker)</span></span> Chan() &lt;-<span class="keyword">chan</span> time.Time &#123;</span><br><span class="line">    <span class="keyword">return</span> rt.C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="遍历当前时间-index-的-slot"><a href="#遍历当前时间-index-的-slot" class="headerlink" title="遍历当前时间(index) 的 slot"></a>遍历当前时间(index) 的 slot</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span></span> scanAndRunTasks(l *list.List) &#123;</span><br><span class="line">    <span class="keyword">var</span> tasks []timingTask</span><br><span class="line">    <span class="comment">// task 双向链表</span></span><br><span class="line">    <span class="keyword">for</span> e := l.Front(); e != <span class="literal">nil</span>; &#123;</span><br><span class="line">        task := e.Value.(*timingEntry)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造 tasks 列表</span></span><br><span class="line">        tasks = <span class="built_in">append</span>(tasks, timingTask&#123;</span><br><span class="line">            key:   task.key,</span><br><span class="line">            value: task.value,</span><br><span class="line">        &#125;)</span><br><span class="line">        next := e.Next()</span><br><span class="line">        l.Remove(e)</span><br><span class="line">        tw.timers.Del(task.key)</span><br><span class="line">        e = next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行所有的到期任务</span></span><br><span class="line">    tw.runTasks(tasks)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimingWheel)</span></span> runTasks(tasks []timingTask) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(tasks) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">            <span class="comment">// 通过 时间轮注册的执行方法来执行 task</span></span><br><span class="line">            threading.RunSafe(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                tw.execute(tasks[i].key, tasks[i].value)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="beanstalkd-延迟队列"><a href="#beanstalkd-延迟队列" class="headerlink" title="beanstalkd 延迟队列"></a>beanstalkd 延迟队列</h3><p>Beanstalkd 的特性</p>
<ul>
<li>支持优先级(支持任务插队)</li>
<li>延迟(实现定时任务)</li>
<li>持久化(定时把内存中的数据刷到binlog日志)</li>
<li>预留(把任务设置成预留，消费者无法取出任务，等某个合适时机再拿出来处理)</li>
<li>任务超时重发(消费者必须在指定时间内处理任务，如果没有则认为任务失败，重新进入队列)</li>
</ul>
<p>Beanstalkd 的客户端在将一个任务放入到 Beanstalkd 的队列时，可以指定延迟的时间时间， Beanstalkd 的 server 在收到这个带延迟时间的任务时， 会先将等待延迟时间这么长的时间，然后将任务放入队列中。</p>
<h4 id="golang-简单使用"><a href="#golang-简单使用" class="headerlink" title="golang 简单使用"></a>golang 简单使用</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">put</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c, err := beanstalk.Dial(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 告诉 server 延迟 10分钟</span></span><br><span class="line">    id, err := c.Put([]<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>), <span class="number">1</span>, <span class="number">10</span> * time.Minute, <span class="number">1</span>*time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;put&quot;</span>, id, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(name <span class="type">string</span>, deleteFn <span class="keyword">func</span>(*beanstalk.Conn, <span class="type">uint64</span>)</span></span>, isReturn <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        c, err := beanstalk.Dial(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        id, body, err := c.Reserve(<span class="number">3</span> * time.Second)</span><br><span class="line">        fmt.Println(<span class="string">&quot;get&quot;</span>, name, id, <span class="type">string</span>(body), err)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 消费后删除</span></span><br><span class="line">            deleteFn(c, id)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> isReturn &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="go-queue-中的封装"><a href="#go-queue-中的封装" class="headerlink" title="go-queue 中的封装"></a>go-queue 中的封装</h4><p>可以参考 example : <a target="_blank" rel="noopener" href="https://github.com/tal-tech/go-queue">https://github.com/tal-tech/go-queue</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/A85ievNNzHDrQv67yBkbtA">主要的参考：你真的知道怎么实现一个延迟队列吗？</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.youzan.com/queuing_delay/">有赞延迟队列的设计</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/tkm9nYcyUxE2vUbplSO-pA">Go-Zero如何应对海量定时&#x2F;延迟任务</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/tal-tech/go-queue">go-queue的代码</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/02/redis/redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/02/redis/redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">redis的内存淘汰机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-02 14:30:59" itemprop="dateCreated datePublished" datetime="2020-11-02T14:30:59+08:00">2020-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><p>Redis在使用内存达到某个阈值（通过maxmemory配置)的时候，就会触发内存淘汰机制，选取一些key来删除。内存淘汰有许多策略，下面分别介绍这几种不同的策略。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">maxmemory &lt;bytes&gt; 配置内存阈值</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">maxmemory-policy noeviction</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。<strong>默认策略</strong></li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间（server.db[i].dict）中，移除最近最少使用的key。</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li>
<li>allkeys-lfu： 对所有key使用LFU算法进行删除。</li>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（server.db[i].expires）中，移除最近最少使用的key。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li>
<li>volatile-lfu： 对所有设置了过期时间的key使用LFU算法进行删除</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li>
</ul>
<h3 id="如何选择淘汰机制"><a href="#如何选择淘汰机制" class="headerlink" title="如何选择淘汰机制"></a>如何选择淘汰机制</h3><ul>
<li>在Redis中，数据有一部分访问频率较高，其余部分访问频率较低，或者无法预测数据的使用频率时，设置allkeys-lru是比较合适的。</li>
<li>如果所有数据访问概率大致相等时，可以选择allkeys-random。</li>
<li>如果研发者需要通过设置不同的ttl来判断数据过期的先后顺序，此时可以选择volatile-ttl策略。</li>
<li>如果希望一些数据能长期被保存，而一些数据可以被淘汰掉时，选择volatile-lru或volatile-random都是比较不错的。</li>
<li>由于设置expire会消耗额外的内存，如果计划避免Redis内存在此项上的浪费，可以选用allkeys-lru 策略，这样就可以不再设置过期时间，高效利用内存了。</li>
</ul>
<h3 id="淘汰机制分类"><a href="#淘汰机制分类" class="headerlink" title="淘汰机制分类"></a>淘汰机制分类</h3><h4 id="lru"><a href="#lru" class="headerlink" title="lru"></a>lru</h4><p>LRU(Least recently used，最近最少使用)算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p>
<h4 id="lfu"><a href="#lfu" class="headerlink" title="lfu"></a>lfu</h4><p>LFU， 最近最少使用淘汰</p>
<h4 id="random"><a href="#random" class="headerlink" title="random"></a>random</h4><p>在随机淘汰的场景下获取待删除的键值对，随机找hash桶再次hash指定位置的dictEntry即可。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="内存淘汰主逻辑"><a href="#内存淘汰主逻辑" class="headerlink" title="内存淘汰主逻辑"></a>内存淘汰主逻辑</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">performEvictions</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 算出需要释放多少内存 mem_tofree</span></span><br><span class="line">    <span class="keyword">if</span> (getMaxmemoryState(&amp;mem_reported,<span class="literal">NULL</span>,&amp;mem_tofree,<span class="literal">NULL</span>) == C_OK) &#123;</span><br><span class="line">    	<span class="keyword">return</span> EVICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">while</span> (mem_freed &lt; (<span class="type">long</span> <span class="type">long</span>)mem_tofree) &#123;</span><br><span class="line">         <span class="comment">// 先判断是否是 lru, lfu, ttl 策略</span></span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU) ||</span><br><span class="line">            server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">/* We don&#x27;t want to make local-db choices when expiring keys,</span></span><br><span class="line"><span class="comment">                 * so to start populate the eviction pool sampling keys from</span></span><br><span class="line"><span class="comment">                 * every DB. */</span></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">                    db = server.db+i;</span><br><span class="line">                    dict = (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) ?</span><br><span class="line">                            db-&gt;dict : db-&gt;expires;</span><br><span class="line">                    <span class="keyword">if</span> ((keys = dictSize(dict)) != <span class="number">0</span>) &#123;</span><br><span class="line">                        evictionPoolPopulate(i, dict, db-&gt;dict, pool);</span><br><span class="line">                        total_keys += keys;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            	<span class="comment">// 根据策略计算出每一个样本的idle值，值越高，可以理解为匹配度越高，优先删除</span></span><br><span class="line">            	<span class="comment">// 倒序查， 数组后面的更适合被删除</span></span><br><span class="line">                <span class="comment">/* Go backward from best to worst element to evict. */</span></span><br><span class="line">                <span class="keyword">for</span> (k = EVPOOL_SIZE<span class="number">-1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pool[k].key == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* If the key exists, is our pick. Otherwise it is</span></span><br><span class="line"><span class="comment">                     * a ghost and we need to try the next element. */</span></span><br><span class="line">                    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">                        bestkey = dictGetKey(de);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">/* Ghost... Iterate again. */</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;        </span><br><span class="line">         <span class="comment">/* volatile-random and allkeys-random policy */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM ||</span><br><span class="line">                 server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// random 就比较简答了</span></span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/* Finally remove the selected key. */</span></span><br><span class="line">        <span class="keyword">if</span> (bestkey) &#123;</span><br><span class="line">            <span class="comment">// 删除</span></span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="采样并计算-idle-score"><a href="#采样并计算-idle-score" class="headerlink" title="采样并计算 idle (score)"></a>采样并计算 idle (score)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">evictionPoolPopulate</span><span class="params">(<span class="type">int</span> dbid, dict *sampledict, dict *keydict, <span class="keyword">struct</span> evictionPoolEntry *pool)</span> &#123;</span><br><span class="line">    <span class="comment">// 采样，代码分析见下面</span></span><br><span class="line">    count = dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">    	<span class="comment">// 在这里根据策略来计算得分 </span></span><br><span class="line">    <span class="comment">/* Calculate the idle time according to the policy. This is called</span></span><br><span class="line"><span class="comment"> 		* idle just because the code initially handled LRU, but is in fact</span></span><br><span class="line"><span class="comment"> 		* just a score where an higher score means better candidate. */</span></span><br><span class="line">        pool[k].idle = idle;</span><br><span class="line">				pool[k].dbid = dbid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function samples the dictionary to return a few keys from random</span></span><br><span class="line"><span class="comment"> * locations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It does not guarantee to return all the keys specified in &#x27;count&#x27;, nor</span></span><br><span class="line"><span class="comment"> * it does guarantee to return non-duplicated elements, however it will make</span></span><br><span class="line"><span class="comment"> * some effort to do both things.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returned pointers to hash table entries are stored into &#x27;des&#x27; that</span></span><br><span class="line"><span class="comment"> * points to an array of dictEntry pointers. The array must have room for</span></span><br><span class="line"><span class="comment"> * at least &#x27;count&#x27; elements, that is the argument we pass to the function</span></span><br><span class="line"><span class="comment"> * to tell how many random elements we need.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据被存放 des 中， des 是一个数组</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">dictGetSomeKeys</span><span class="params">(dict *d, dictEntry **des, <span class="type">unsigned</span> <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="comment">// 随机选一个 table</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> i = random() &amp; maxsizemask;</span><br><span class="line">    <span class="comment">// j 用于判断是否处于 rehash 阶段</span></span><br><span class="line">    dictEntry *he = d-&gt;ht[j].table[i];</span><br><span class="line">    <span class="comment">// 向数组中放样本数据</span></span><br><span class="line">    <span class="keyword">while</span> (he) &#123;</span><br><span class="line">        <span class="comment">/* Collect all the elements of the buckets found non</span></span><br><span class="line"><span class="comment">         * empty while iterating. */</span></span><br><span class="line">        *des = he;</span><br><span class="line">        des++;</span><br><span class="line">        <span class="comment">// hash 冲突的链表</span></span><br><span class="line">        he = he-&gt;next;</span><br><span class="line">        stored++;</span><br><span class="line">        <span class="keyword">if</span> (stored == count) <span class="keyword">return</span> stored;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回采样数量</span></span><br><span class="line">    <span class="keyword">return</span> stored;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redis-LRU-实现"><a href="#redis-LRU-实现" class="headerlink" title="redis LRU 实现"></a>redis LRU 实现</h3><h4 id="如果基于传统-LRU-算法实现-Redis-LRU-会有什么问题？"><a href="#如果基于传统-LRU-算法实现-Redis-LRU-会有什么问题？" class="headerlink" title="如果基于传统 LRU 算法实现 Redis LRU 会有什么问题？"></a>如果基于传统 LRU 算法实现 Redis LRU 会有什么问题？</h4><p>需要额外的数据结构存储，消耗内存。Redis LRU 对传统的 LRU 算法进行了改良，通过随机采样来调整算法的精度。</p>
<p>如果淘汰策略是 LRU，则根据配置的采样值 maxmemory_samples（默认是 5 个）,随机从数据库中选择 m 个 key, 淘汰其中热度最低的 key 对应的缓存数据。所以采样参数m配置的数值越大, 就越能精确的查找到待淘汰的缓存数据,但是也消耗更多的CPU计算,执行效率降低。</p>
<h4 id="如何找出热度最低的数据？"><a href="#如何找出热度最低的数据？" class="headerlink" title="如何找出热度最低的数据？"></a>如何找出热度最低的数据？</h4><p>Redis 中所有对象结构都有一个 lru 字段, 且使用了 unsigned 的低 24 位，这个字段用来记录对象的热度。<strong>对象被创建时会记录 lru 值。在被访问的时候也会更新 lru 的值</strong>。但不是获取系统当前的时间戳，而是设置为全局变量server.lruclock 的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象在被读写时，会更新 lru 时间</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<h5 id="问题：server-lruclock-的值怎么来的？"><a href="#问题：server-lruclock-的值怎么来的？" class="headerlink" title="问题：server.lruclock 的值怎么来的？"></a>问题：server.lruclock 的值怎么来的？</h5><p>Redis中有个定时处理的函数serverCron，默认每100毫秒调用函数。 updateCachedTime 更新一次全局变量的server.lruclock的值，它记录的是当前unix时间戳。</p>
<h5 id="问题：为什么不获取精确的时间而是放在全局变量中？不会有延迟的问题吗？"><a href="#问题：为什么不获取精确的时间而是放在全局变量中？不会有延迟的问题吗？" class="headerlink" title="问题：为什么不获取精确的时间而是放在全局变量中？不会有延迟的问题吗？"></a>问题：为什么不获取精确的时间而是放在全局变量中？不会有延迟的问题吗？</h5><p>这样函数 lookupKey 中更新数据的 lru 热度值时,就不用每次调用系统函数 time，可以提高执行效率。</p>
<p>OK，当对象里面已经有了 LRU 字段的值，就可以评估对象的热度了。  函数 estimateObjectIdleTime 评估指定对象的 lru 热度，<strong>思想就是对象的 lru 值和全局的 server.lruclock 的差值越大（越久没有得到更新）， 该对象热度越低。</strong></p>
<h5 id="为什么不用常规的哈希表-双向链表的方式实现？"><a href="#为什么不用常规的哈希表-双向链表的方式实现？" class="headerlink" title="为什么不用常规的哈希表+双向链表的方式实现？"></a>为什么不用常规的哈希表+双向链表的方式实现？</h5><p>需要额外的数据结构，消耗资源。而 Redis LRU 算法在 sample 为 10 的情况下，已经能接近传统 LRU 算法了。</p>
<p>假设 A 在 10 秒内被访问了 5 次，而 B 在 10 秒内被访问了 3 次。因为 B 最后一次被访问的时间比 A 要晚，在同等的情况下，A 反而先被回收。</p>
<h3 id="redis-LFU-实现"><a href="#redis-LFU-实现" class="headerlink" title="redis LFU 实现"></a>redis LFU 实现</h3><p>当这 24 bits 用作 LFU 时，其被分为两部分：</p>
<ul>
<li>高 16 位用来记录访问时间（单位为分钟，ldt，last decrement time）</li>
<li>低 8 位用来记录访问频率，简称 counter（logc，logistic counter）</li>
</ul>
<p>counter 是用基于概率的对数计数器实现的，8 位可以表示百万次的访问频率。对象被读写的时候，lfu 的值会被更新。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Update LFU when an object is accessed.</span></span><br><span class="line"><span class="comment"> * Firstly, decrement the counter if the decrement time is reached.</span></span><br><span class="line"><span class="comment"> * Then logarithmically increment the counter, and update the access time. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">updateLFU</span><span class="params">(robj *val)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> counter = LFUDecrAndReturn(val);</span><br><span class="line">    counter = LFULogIncr(counter);</span><br><span class="line">    val-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果计数器只会递增不会递减，也不能体现对象的热度。没有被访问的时候，计数器怎么递减呢？</p>
<p>减少的值由衰减因子 lfu-decay-time（分钟）来控制，如果值是 1 的话，N 分钟没有访问就要减少 N。  redis.conf 配置文件<code># lfu-decay-time 1</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">LFUDecrAndReturn</span><span class="params">(robj *o)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ldt = o-&gt;lru &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> counter = o-&gt;lru &amp; <span class="number">255</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> num_periods = server.lfu_decay_time ? LFUTimeElapsed(ldt) / server.lfu_decay_time : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num_periods)</span><br><span class="line">        counter = (num_periods &gt; counter) ? <span class="number">0</span> : counter - num_periods;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1692189">Redis内存回收知多少</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904120533401607">Redis内存淘汰策略源码分析以及LFU&#x2F;LRU实现</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/02/redis/redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/02/redis/redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">redis的数据类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-02 14:30:59" itemprop="dateCreated datePublished" datetime="2020-11-02T14:30:59+08:00">2020-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>总体来说，用户侧的数据结构有 <code>string</code>, <code>hash</code>, <code>list</code>,  <code>set</code>,  <code>zset</code>。</p>
<p>实现测的数据结构有 <code>sds</code>,  <code>dict</code>, <code>linkedlist</code>,  <code>skiplist</code>, <code>ziplist</code>, <code>quicklist</code>, <code>intset</code></p>
<h2 id="用户侧的数据结构"><a href="#用户侧的数据结构" class="headerlink" title="用户侧的数据结构"></a>用户侧的数据结构</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>通过 key-value pair 的方式，存储字符串、整数、浮点数等对象。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">string指令</span></span><br><span class="line">set string_demo percy</span><br><span class="line">set string_demo 100</span><br><span class="line">set string_demo 3.14159</span><br><span class="line">get string_demo</span><br><span class="line">strlen string_demo</span><br><span class="line">type string_demo</span><br><span class="line">object encoding string_demo</span><br></pre></td></tr></table></figure>

<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>存储的是一系列 key-value 对。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">hash</span>指令</span></span><br><span class="line">hset hash_demo name percy</span><br><span class="line">hmset hash_demo age 12 school swjtu</span><br><span class="line">hget hash_demo school</span><br><span class="line">hlen hash_demo</span><br><span class="line">type hash_demo</span><br><span class="line">object encoding hash_demo</span><br></pre></td></tr></table></figure>

<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>List 对象概念上可以理解为 Python 中的 list、Java 中的 List、Golang 中的 slice 等。之所以说概念上，是因为这几者底层实现上其实并不相同，只是都是对一组数据的集合的抽象。<strong>Redis 中 list 对象可以插入数据到 list 头或尾上，由于其底层实现是一个双向链表（某些场景下不是），所以插入两端都是 O(1) 的。</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">list指令</span></span><br><span class="line">rpush list_demo 2</span><br><span class="line">rpush list_demo 3</span><br><span class="line">lpush list_demo 1</span><br><span class="line">lrange list_demo 0 -1</span><br><span class="line">llen list_demo </span><br><span class="line">type list_demo</span><br><span class="line">object encoding list_demo</span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>Set 对象有点像是 Python 里的 set，其存储的是多个互不相同的元素。由于 set 底层使用 hash table 存储（同上，某些场景下不是），所以其大部分操作都是 O(1) 的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">set</span>指令</span></span><br><span class="line">sadd set_demo 1</span><br><span class="line">sadd set_demo 2, 3</span><br><span class="line">smembers set_demo</span><br><span class="line">scard set_demo</span><br><span class="line">type set_demo</span><br><span class="line">object encoding set_demo</span><br></pre></td></tr></table></figure>

<h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p>zset 是有序集合，同 set 相似的是，其内部存储的元素也是不允许重复的。不同的是，set 中存储的元素是无序的，但是 zset 存储的元素是有序的。通过为 zset 中每个元素设置一个 score，zset 根据元素的 score 排序。ZRANGE key start stop [WITHSCORES]。其中成员的位置按 <code>score</code> 值递增(从小到大)来排序。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">zset指令</span></span><br><span class="line">zadd zset_demo 2 b</span><br><span class="line">zadd zset_demo 3 c</span><br><span class="line">zadd zset_demo 1 a</span><br><span class="line">zrange zset_demo 0 -1 withscores</span><br><span class="line">zcard zset_demo</span><br><span class="line">type zset_demo</span><br><span class="line">object encoding zset_demo</span><br></pre></td></tr></table></figure>

<h2 id="实现侧的数据结构"><a href="#实现侧的数据结构" class="headerlink" title="实现侧的数据结构"></a>实现侧的数据结构</h2><p>Redis 是通过 C 语言实现的，由于 C 语言的朴素，Redis 并没有直接实现上面提到的数据结构，而是通过构件了一系列基础的数据结构，经过对象系统对下层结构的封装，来实现上层面向用户的各种结构。</p>
<h3 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h3><p>SDS 是「 simple dynamic string 」的缩写，是对 C 字符串的抽象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录buf数组中已使用字节的数量， 等于 SDS 保存字符串的长度</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相比 C char array，sds 有以下优点：</p>
<ul>
<li>获取字符串长度效率更优。C 字符串只是一个 ‘\0’ 结尾的 char 数组，如果需要获取字符串长度，需要遍历整个数组，遍历操作时间复杂度为 O(N)。而 sds len 属性记录了本身的长度，获取长度只需要 O(1) 复杂度。</li>
<li>避免数组长度溢出。</li>
<li>减少内存分配次数。sds 会通过预申请内存，在连接字符串等操作时，减少对内存的申请操作。</li>
</ul>
<h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>在 Redis 中，dict 通过一个 dict 结构实现，底层通过一个 hashtable 存储数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表元素, dictEntry 是每个 key-value 对存储的结构，其 next 指针用于在 hash 冲突时，将多个 entry 连接一起</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;       <span class="comment">// hash table 实际存储的位置</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;      <span class="comment">// table 的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;      <span class="comment">// 已经使用的长度</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表类型，用于实现多态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">// 计算哈希值</span></span><br><span class="line">    <span class="type">uint64_t</span> (*hashFunction)(<span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制 key</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制 value</span></span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="comment">// 比较 key</span></span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="comment">// 销毁 key</span></span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">// 销毁 value</span></span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dict 的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type; <span class="comment">// 哈希表类型</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>]; <span class="comment">// 两个哈希表，用于渐进式扩容</span></span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<ol>
<li>dictType 是一个包含一组针对不同类型 entry 特定操作函数的结构体。不同类型的 entry 通过不一样的实现，来达到多态的目的。</li>
<li>prevdata 保存了需要传给 dictType 里的函数的特定参数（如上函数签名的 prevdata 指针）</li>
<li>ht 是包含两个 dictht 对象的数组，ht[0] 存储数据，ht[1] 在 rehash 的时候会用到（这里只提一下，dict rehash 过程下次单写）</li>
<li>rehashidx 记录 rehash 进度，这里不做过多介绍。</li>
</ol>
<h3 id="linkedlist"><a href="#linkedlist" class="headerlink" title="linkedlist"></a>linkedlist</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="type">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p>list 结构通过 head、tail 记录了链表头尾指针，配合每个节点的 next、prev（双向链表），方便从头或者从尾遍历等操作。</p>
<h3 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h3><p>kiplist（跳跃表） 是一种有序的结构，通过在每个节点中维护多个指向其他节点的指针来实现快速访问节点的目的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span>  <span class="comment">// 头、尾指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;                 <span class="comment">// 长度</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<h3 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h3><p>ziplist是一个经过特殊<strong>编码的双向链表</strong>，它的设计目标就是为了提高存储效率（<strong>ziplist由于是一整块连续内存，所以存储效率很高。</strong>）。ziplist可以用于存储字符串或整数，其中整数是按真正的二进制表示进行编码的，而不是编码成字符串序列。它能以O(1)的时间复杂度在表的两端提供push和pop操作。 ziplist 没有结构体定义，下面只是描述下 ziplist 的内存结构</p>
<p><zlbytes><zltail><zllen><entry>…<entry><zlend></p>
<p><img src="https://image-static.segmentfault.com/312/003/3120031942-5cef4094c634c_articlex"></p>
<p>各个部分在内存上是前后相邻的，它们分别的含义如下：</p>
<ul>
<li><zllen>: 16bit， 表示ziplist中数据项（entry）的个数。</li>
<li><entry>: 表示真正存放数据的数据项，长度不定。一个数据项（entry）也有它自己的内部结构，这个稍后再解释。</li>
</ul>
<p>entry的构成，<prevrawlen><len><data></p>
<ul>
<li><code>&lt;prevrawlen&gt;</code>: 表示前一个数据项占用的总字节数。这个字段的用处是为了让ziplist能够从后向前遍历（从后一项的位置，只需向前偏移prevrawlen个字节，就找到了前一项）。这个字段采用变长编码。</li>
<li><code>&lt;len&gt;</code>: 表示当前数据项的数据长度（即<code>&lt;data&gt;</code>部分的长度）。也采用变长编码。</li>
</ul>
<h3 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h3><p>A doubly linked list of ziplists。 quicklist 是一个双向链表，而且是一个ziplist的双向链表。我们知道，双向链表是由多个节点（Node）组成的。这个描述的意思是：quicklist的每个节点都是一个ziplist。</p>
<p>quicklist的结构为什么这样设计呢？总结起来，大概又是一个空间和时间的折中：</p>
<ul>
<li>双向链表便于在表的两端进行push和pop操作，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。</li>
<li>ziplist由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的realloc。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。</li>
</ul>
<p>于是，结合了双向链表和ziplist的优点，quicklist就应运而生了。</p>
<p>不过，这也带来了一个新问题：到底一个quicklist节点包含多长的ziplist合适呢？比如，<strong>同样是存储12个数据项，既可以是一个quicklist包含3个节点，而每个节点的ziplist又包含4个数据项，也可以是一个quicklist包含6个节点，而每个节点的ziplist又包含2个数据项。</strong></p>
<h3 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h3><p>当 set 中只包含整数元素时且元素不多时，底层的数据结构便是 intset。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>其中 contents 数组用于存储数据，intset 按照存储数字的大小有序排列在 contents 数组中。length 属性记录集合中元素的个数。encoding 记录 contents 数组中存储的元素的类型：</p>
<ul>
<li><code>INTSET_ENC_INT16</code> 存储 int16 类型整数</li>
<li><code>INTSET_ENC_INT32</code> 存储 int32 类型整数</li>
<li><code>INTSET_ENC_INT64</code> 存储 int64 类型整数</li>
</ul>
<p>当新增元素到 intset 中时，如果新元素比现有元素类型长时，比如向 INTSET_ENC_INT16 编码的 intset 插入一个 32 位整数时，intset 需要先升级（upgrade），才能添加元素。所谓 upgrade 是将此 intset 的 enconding 更新为更长 bit 的编码格式上。当 intset 升级后不会降级，哪怕删除长 bit 元素后剩下全是短 bit 元素。</p>
<h2 id="Redis-是如何通过底层结构构建上层数据类型的"><a href="#Redis-是如何通过底层结构构建上层数据类型的" class="headerlink" title="Redis 是如何通过底层结构构建上层数据类型的"></a>Redis 是如何通过底层结构构建上层数据类型的</h2><p>Redis 不直接实现上层的数据类型，是为了方便在不同场景下可以替换下层合适的数据结构，同时对上层使用屏蔽下层实现细节。在不同场景下，面对性能和内存占用不同而使用不同的下层结构支持同一个上层对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;       <span class="comment">// 类型</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;   <span class="comment">// 编码</span></span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;             <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>如上结构，<code>type</code> 属性记录了对象的类型，对应上层面向用户的那些数据类型（string&#x2F;list&#x2F;hash 等）。对应的类型，可以通过在 redis-cli 中调用 <code>TYPE key</code> 查看每个 key 对应的类型。</p>
<p>而 encoding 则对应着这个 redisObject 下层使用的数据类型（如上 sds&#x2F;ziplist&#x2F;dict 等），对应的下层结构，可以通过在 redis-cli 中调用 <code>OBJECT ENCODING key</code> 查看每个 key 对应的底层实现的数据结构。</p>
<h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>redis 优先会选择最优的数据结构来存储数据，但是当存储的数据不满足对应的条件时。</p>
<h3 id="string-–-gt-int-x2F-raw-x2F-embstr"><a href="#string-–-gt-int-x2F-raw-x2F-embstr" class="headerlink" title="string –&gt; int&#x2F;raw&#x2F;embstr"></a>string –&gt; int&#x2F;raw&#x2F;embstr</h3><p>string 类型在不同场景下，下层分别由 int&#x2F;raw&#x2F;embstr 编码方式来实现（ embstr 是经过优化的用于保存短字符串的编码方式）。</p>
<ol>
<li>如果 value 是一个整数，且整数长度在 8 bytes 以内，则 string 对象的编码类型为 int，redisObject 的 ptr 指针将指向一个 long 型对象。</li>
<li>如果 value 是一个字符串值，且长度大于 32 字节，则 string 对象编码类型为 raw，对应 redisObject 的 ptr 指针将指向一个 sds 对象。</li>
<li>如果 value 是一个字符串值，且长度小于等于 32 字节，则会通过 embstr 编码保存。</li>
</ol>
<h3 id="list-–-gt-ziplist-quicklist-x2F-linkedlist-x2F"><a href="#list-–-gt-ziplist-quicklist-x2F-linkedlist-x2F" class="headerlink" title="list –&gt; ziplist(quicklist)&#x2F;linkedlist&#x2F;"></a>list –&gt; ziplist(quicklist)&#x2F;linkedlist&#x2F;</h3><ol>
<li>当 list 中所有元素长度都小于 <code>list-max-ziplist-value</code> 字节，且元素数量少于 <code>list-max-ziplist-entries</code> 时，底层会选择使用 ziplist。</li>
<li>否则，使用 linkedlist。</li>
</ol>
<h3 id="hash-–-gt-ziplist-x2F-hashtable-dict"><a href="#hash-–-gt-ziplist-x2F-hashtable-dict" class="headerlink" title="hash –&gt; ziplist&#x2F;hashtable(dict)"></a>hash –&gt; ziplist&#x2F;hashtable(dict)</h3><ol>
<li>当 hash 对象所有 key-value pair 长度都小于 <code>hash-max-ziplist-value</code>，且 key-value pair 数量小于 <code>hash-max-ziplist-entries</code> 时，底层会使用 ziplist 保存 hash 对象。</li>
<li>否则，使用 hashtable。</li>
</ol>
<h3 id="set-–-gt-intset-x2F-hashtable-dict"><a href="#set-–-gt-intset-x2F-hashtable-dict" class="headerlink" title="set –&gt; intset&#x2F;hashtable(dict)"></a>set –&gt; intset&#x2F;hashtable(dict)</h3><ol>
<li>当 set 所有元素都是整数对象，且元素数量小于 <code>set-max-intset-entries</code> 时，使用 intset 作为底层编码方式。</li>
<li>否则，使用 hashtable。</li>
</ol>
<h3 id="zset-–-gt-ziplist-x2F-skiplist"><a href="#zset-–-gt-ziplist-x2F-skiplist" class="headerlink" title="zset –&gt; ziplist&#x2F;skiplist"></a>zset –&gt; ziplist&#x2F;skiplist</h3><p>当 zset 保存的元素小于 zset-max-ziplist-entries 个，且所有元素长度都小于 zset-max-ziplist-value 字节时，zset 底层通过 ziplist 存储。<br>否则，使用 skiplist 存储。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>简单总结了下 Redis 用户端常用的数据结构，以及底层抽象的各种数据结构，以及二者是如何组合起来的。</p>
<p>Redis 面向用户侧的各种数据结构，并不直接实现，而是通过对象系统，在特定的条件下选择特定的底层结构，以在效率和存储空间之间平衡。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://xlzd.me/2018/09/01/redis-data-structure-overview/">大部分的参考</a></p>
<p><a target="_blank" rel="noopener" href="http://zhangtielei.com/posts/server.html">详细分析redis数据结构</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/02/redis/redis%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/02/redis/redis%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">redis的过期策略及源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-02 11:48:35" itemprop="dateCreated datePublished" datetime="2020-11-02T11:48:35+08:00">2020-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="设置过期时间的常见方式"><a href="#设置过期时间的常见方式" class="headerlink" title="设置过期时间的常见方式"></a>设置过期时间的常见方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">expire key ttl</span><br><span class="line">expireat key unix_timestamp</span><br><span class="line"></span><br><span class="line">pexpire key ttl</span><br><span class="line">pexpireat key unix_timestamp</span><br><span class="line"></span><br><span class="line">SETEX key seconds value</span><br><span class="line">PSETEX key milliseconds value</span><br><span class="line">SET key value [EX seconds] [PX milliseconds] [NX|XX]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 redis 的实现中，expire, expireat, pexpire 这三种最终都是使用 pexpireat 来实现的</span></span><br></pre></td></tr></table></figure>

<h2 id="过期键值对的删除有三种策略"><a href="#过期键值对的删除有三种策略" class="headerlink" title="过期键值对的删除有三种策略"></a>过期键值对的删除有三种策略</h2><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><p>设置一个定时器和回调函数，时间一到就调用回调函数删除键值对。优点是及时删除，缺点是需要为每个键值对都设置定时器，比较麻烦(其实可以用timer_fd的，参考muduo定时任务的实现)</p>
<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>只有当再次访问该键时才判断是否过期，如果过期将其删除。优点是不需要为每个键值对进行时间监听，缺点是如果这个键值对一直不被访问，那么即使过期也会一直残留在数据库中，占用不必要的内存</p>
<h3 id="周期删除"><a href="#周期删除" class="headerlink" title="周期删除"></a>周期删除</h3><p>每隔一段时间执行一次删除过期键值对的操作。优点是既不需要监听每个键值对导致占用CPU，也不会一直不删除导致占用内存，缺点是不容易确定删除操作的执行时长和频率<br>Redis采用惰性删除和周期删除两种策略，通过配合使用，服务器可以很好的合理使用CPU时间和避免内不能空间的浪费</p>
<h2 id="redis-过期策略的实现"><a href="#redis-过期策略的实现" class="headerlink" title="redis 过期策略的实现"></a>redis 过期策略的实现</h2><h3 id="redis-expire-api"><a href="#redis-expire-api" class="headerlink" title="redis expire api"></a>redis expire api</h3><p>Redis是如何实现定时删除的，在数据库结构redisDb中，可以发现除了上篇提到的用于保存键值对的dict字典外，另有一个字典变量expires，实际上正是它保存着键和其过期时间(绝对时间)。当执行完SET命令后，两个字典的数据分布为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* The keyspace for this DB */</span></span><br><span class="line">    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<h4 id="设置键的过期时间，setExpire"><a href="#设置键的过期时间，setExpire" class="headerlink" title="设置键的过期时间，setExpire"></a>设置键的过期时间，setExpire</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setExpire</span><span class="params">(client *c, redisDb *db, robj *key, <span class="type">long</span> <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    dictEntry *kde, *de;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reuse the sds from the main dict in the expire dict */</span></span><br><span class="line">     <span class="comment">/* 从数据字典中寻找键节点， kde 中包含 key */</span></span><br><span class="line">    kde = dictFind(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,key,kde != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 从时间字典中寻找键节点，如果不存在则创建一个 */</span></span><br><span class="line">    de = dictAddOrFind(db-&gt;expires,dictGetKey(kde));</span><br><span class="line">    <span class="comment">/* 设置键节点的值，值为过期时间(绝对时间) */</span></span><br><span class="line">    dictSetSignedIntegerVal(de,when);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dictSetSignedIntegerVal是宏定义，设置键节点de的值为when。因为哈希节点中的值结构是联合，可以存储不同大小的数字，也可以通过void*指针存储其它类型，这里过期时间是long long类型，所以可以存在int64_t类型上。</p>
<h4 id="获取键的过期时间，getExpire"><a href="#获取键的过期时间，getExpire" class="headerlink" title="获取键的过期时间，getExpire"></a>获取键的过期时间，getExpire</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">getExpire</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* No expire? return ASAP */</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) == <span class="number">0</span> ||</span><br><span class="line">       (de = dictFind(db-&gt;expires,key-&gt;ptr)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The entry was found in the expire dict, this means it should also</span></span><br><span class="line"><span class="comment">     * be present in the main dict (safety check). */</span></span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,key,dictFind(db-&gt;dict,key-&gt;ptr) != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> dictGetSignedIntegerVal(de);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除键的过期时间，removeExpire"><a href="#删除键的过期时间，removeExpire" class="headerlink" title="删除键的过期时间，removeExpire"></a>删除键的过期时间，removeExpire</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeExpire</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    <span class="comment">/* An expire may only be removed if there is a corresponding entry in the</span></span><br><span class="line"><span class="comment">     * main dict. Otherwise, the key will never be freed. */</span></span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,key,dictFind(db-&gt;dict,key-&gt;ptr) != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> dictDelete(db-&gt;expires,key-&gt;ptr) == DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redis-过期删除的实现"><a href="#redis-过期删除的实现" class="headerlink" title="redis 过期删除的实现"></a>redis 过期删除的实现</h3><p><strong>Redis 采用惰性删除和周期删除两种策略</strong>，通过配合使用，服务器可以很好的合理使用CPU时间和避免内不能空间的浪费。</p>
<h4 id="惰性删除-1"><a href="#惰性删除-1" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>惰性删除是指在对每一个键进行读写操作时，先判断一下这个键是否已经过期，如果过期则将其删除。该操作由expireIfNeeded函数完成。</p>
<h5 id="get-操作的流程"><a href="#get-操作的流程" class="headerlink" title="get 操作的流程"></a>get 操作的流程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getGenericCommand</span><span class="params">(client *c)</span></span><br><span class="line">    </span><br><span class="line">robj *<span class="title function_">lookupKeyReadOrReply</span><span class="params">(client *c, robj *key, robj *reply)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">robj *<span class="title function_">lookupKeyRead</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lookupKeyReadWithFlags(db,key,LOOKUP_NONE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入这个函数会调用  (expireIfNeeded(db,key)， 判断 key 是否过期</span></span><br><span class="line">robj *<span class="title function_">lookupKeyReadWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="type">int</span> flags)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lookup 最终寻找 key 对应的 val。 在redis中，所有的键值对都会用内置的哈希表保存在内存里，因此，在lookupKey的实现里，先使用dictFind函数查找传进来的key是否存在哈希表中，如果找到，则调用dictGetVal获取哈希节点对象的value属性，否则，返回NULL，函数的时间复杂度是O(1)。</span></span><br><span class="line">robj *<span class="title function_">lookupKey</span><span class="params">(redisDb *db, robj *key, <span class="type">int</span> flags)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="主从实现惰性删除的方法"><a href="#主从实现惰性删除的方法" class="headerlink" title="主从实现惰性删除的方法"></a>主从实现惰性删除的方法</h5><ul>
<li>如果当前请求是在 master 节点上，且当前的 key 已经过期，那么直接删除过期的 key。</li>
<li>如果当前请求是在 slave 节点上，且当前 key 已经过期， 直接返回 null，不做删除。（删除操作只能由 master 执行并同步给 slave 节点）</li>
</ul>
<h4 id="周期删除-1"><a href="#周期删除-1" class="headerlink" title="周期删除"></a>周期删除</h4><p>Redis服务器会周期性地执行server.c&#x2F;serverCron函数，在这个函数中执行的databasesCron函数会调用activeExpireCycle函数，这个函数在时间字典(expires)中随机选择若干键节点，判断其是否过期，如果过期则将其删除。</p>
<h5 id="循环函数"><a href="#循环函数" class="headerlink" title="循环函数"></a>循环函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">activeExpireCycle</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">    <span class="comment">// 循环次数和时间：dbs_per_call：上一次执行越就久，dbs_per_call越大， timelimit_exit：最多执行这么多时间</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call &amp;&amp; timelimit_exit == <span class="number">0</span>; j++) &#123;</span><br><span class="line">         <span class="comment">// 循环 db：当前 db 过期的多才重复执行</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (sampled &lt; num &amp;&amp; checked_buckets &lt; max_buckets) &#123;</span><br><span class="line">                <span class="comment">/* Get the next entry now since this entry may get deleted. */</span></span><br><span class="line">                 <span class="keyword">while</span>(de) &#123;</span><br><span class="line">                        dictEntry *e = de;</span><br><span class="line">                        de = de-&gt;next;</span><br><span class="line"></span><br><span class="line">                        ttl = dictGetSignedIntegerVal(e)-now;</span><br><span class="line">                        <span class="keyword">if</span> (activeExpireCycleTryExpire(db,e,now)) expired++;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125; (sampled == <span class="number">0</span> || (expired*<span class="number">100</span>/sampled) &gt; config_cycle_acceptable_stale);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="真正删除的代码"><a href="#真正删除的代码" class="headerlink" title="真正删除的代码"></a>真正删除的代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正删除一个 key， Helper function for the activeExpireCycle() function.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">activeExpireCycleTryExpire</span><span class="params">(redisDb *db, dictEntry *de, <span class="type">long</span> <span class="type">long</span> now)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Redis 采用惰性删除和周期删除两种策略</strong>，通过配合使用，服务器可以很好的合理使用CPU时间和避免内不能空间的浪费。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903618890432526">redis 指令的执行过程</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/asdfsadfasdfsa/article/details/88339060">redis源码–key的过期策略</a>： 这个源码有点老了，可以看最新的源码。</p>
<p>ASAP: as sonn as possible</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Percy"
      src="https://ivalue2333.github.io/percy/images/percy.jpg">
  <p class="site-author-name" itemprop="name">Percy</p>
  <div class="site-description" itemprop="description">IOT2014</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">156</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">194</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Percy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
