<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="IOT2014">
<meta property="og:type" content="website">
<meta property="og:title" content="blog | percy">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="blog | percy">
<meta property="og:description" content="IOT2014">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Percy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>blog | percy</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blog | percy</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/25/blog/think%20in/logic/base/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/25/blog/think%20in/logic/base/" class="post-title-link" itemprop="url">你是如何思考的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-25 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-25T00:00:00+08:00">2021-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/logic/" itemprop="url" rel="index"><span itemprop="name">logic</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/22/blog/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/22/blog/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB/" class="post-title-link" itemprop="url">redis为什么快</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-22 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-22T00:00:00+08:00">2021-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="redis-为什么快"><a href="#redis-为什么快" class="headerlink" title="redis 为什么快"></a>redis 为什么快</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/6oiCxU"><img src="https://z3.ax1x.com/2021/03/22/6oiCxU.png" alt="6oiCxU.png"></a></p>
<h3 id="基于内存的实现"><a href="#基于内存的实现" class="headerlink" title="基于内存的实现"></a>基于内存的实现</h3><p>内存是很快的，和传统的数据库作比较，内存比磁盘是要快2-3个数量级的。</p>
<h3 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h3><p>redis的大多数指令都是在单线程中运行的，这能减少不必要的上线文切换，避免加锁，并且可以保证操作的原子性。</p>
<h3 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h3><p>IO 多路复用是一种高效的 IO 编程模型。</p>
<h3 id="高效的数据结构"><a href="#高效的数据结构" class="headerlink" title="高效的数据结构"></a>高效的数据结构</h3><p>redis 根据实际的数据类型和数据量大小选择合适的数据结构。例如在底层，redis有动态字符串，双向链表，压缩列表，跳跃表，hash表等数据结构。</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>redis 全局就是一个大的 hash 表，他的操作时间复杂度是 O(1)，并且配合渐进式的  rehash 过程，redis 也不会出现内存拷贝导致阻塞的问题。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/58m0ZjZOSeElYmggAZhznA">redis 快的原因</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/22/blog/operation%20system/linux%20cpu%20cache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/22/blog/operation%20system/linux%20cpu%20cache/" class="post-title-link" itemprop="url">linux cpu cache</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-22 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-22T00:00:00+08:00">2021-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Cache ：即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器。<strong>在金字塔式存储体系中它位于自顶向下的第二层，仅次于CPU寄存器</strong>。其容量远小于内存，但速度却可以接近处理器的频率。由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用,这样就减少了CPU的等待时间,提高了系统的效率。Cache又分为一级Cache(L1 Cache)和二级Cache(L2 Cache)，L1 Cache集成在CPU内部，L2 Cache早期一般是焊在主板上,现在也都集成在CPU内部，常见的容量有256KB或512KB L2 Cache。当处理器发出内存访问请求时，会先查看缓存内是否有请求数据。如果存在（命中），则不经访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器。缓存之所以有效，主要是因为程序运行时对内存的访问呈现局部性（Locality）特征。这种局部性既包括空间局部性（Spatial Locality），也包括时间局部性（Temporal Locality）。有效利用这种局部性，缓存可以达到极高的命中率。（百度百科解释）。</p>
<h3 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h3><p>随着科技发展，热点数据的体积越来越大，单纯的增加一级缓存大小的性价比已经很低了。因此，就慢慢出现了在一级缓存(L1 Cache)和内存之间又增加一层访问速度和成本都介于两者之间的二级缓存(L2 Cache)。此外，又由于程序指令和程序数据的行为和热点分布差异很大，因此L1 Cache也被划分成L1i (i for instruction)和L1d (d for data)两种专门用途的缓存。</p>
<h2 id="cache-line"><a href="#cache-line" class="headerlink" title="cache line"></a>cache line</h2><p>Cache Line可以简单的理解为CPU Cache中的最小缓存单位。目前主流的CPU Cache的Cache Line大小都是64Bytes。假设我们有一个512字节的一级缓存，那么按照64B的缓存单位大小来算，这个一级缓存所能存放的缓存个数就是512&#x2F;64 &#x3D; 8个</p>
<p>数组访问实验：当数组小于64Bytes时数组极有可能落在一条Cache Line内，而一个元素的访问就会使得整条Cache Line被填充，因而值得后面的若干个元素受益于缓存带来的加速。而当数组大于64Bytes时，必然至少需要两条Cache Line，继而在循环访问时会出现两次Cache Line的填充，由于缓存填充的时间远高于数据访问的响应时间，因此多一次缓存填充对于总执行的影响会被放大</p>
<p>下面第一段代码在C语言中总是比第二段代码的执行速度要快。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按行读取</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="type">int</span> num;    </span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">        arr[i][j] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按列读取</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="type">int</span> num;    </span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">        arr[j][i] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="按行读取为什么快"><a href="#按行读取为什么快" class="headerlink" title="按行读取为什么快"></a>按行读取为什么快</h3><p>二维数组的内存地址是连续的，当前行的尾与下一行的头相邻</p>
<p><strong>缓存从内存中抓取一般都是整个数据块，所以它的物理内存是连续的，几乎都是同行不同列的，而如果内循环以列的方式进行遍历的话，将会使整个缓存块无法被利用，而不得不从内存中读取数据，而从内存读取速度是远远小于从缓存中读取数据的。</strong>随着数组元素越来越多，按列读取速度也会越来越慢。</p>
<h2 id="cache存放策略"><a href="#cache存放策略" class="headerlink" title="cache存放策略"></a>cache存放策略</h2><p>省略</p>
<h2 id="cache淘汰策略"><a href="#cache淘汰策略" class="headerlink" title="cache淘汰策略"></a>cache淘汰策略</h2><p>在文章的最后我们顺带提一下CPU Cache的淘汰策略。常见的淘汰策略主要有LRU和Random两种。通常意义下LRU对于Cache的命中率会比Random更好，所以CPU Cache的淘汰策略选择的是LRU。当然也有些实验显示在Cache Size较大的时候Random策略会有更高的命中率</p>
<h2 id="计算机存储体系"><a href="#计算机存储体系" class="headerlink" title="计算机存储体系"></a>计算机存储体系</h2><p><img src="https://z3.ax1x.com/2021/03/23/67eout.png" alt="67eout.png"></p>
<h3 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h3><p>寄存器是CPU的内部组成单元,是CPU运算时取指令和数据的地方，速度很快，寄存器可以用来暂存指令、数据和地址。在CPU中，通常有通用寄存器，如指令寄存器IR；特殊功能寄存器，如程序计数器PC、sp等。</p>
<h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>缓存即就是用于暂时存放内存中的数据，若果寄存器要取内存中的一部分数据时，可直接从缓存中取到，这样可以调高速度。高速缓存是内存的部分拷贝。</p>
<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>内存的工作方式就要复杂得多：</p>
<ul>
<li>找到数据的指针。（指针可能存放在寄存器内，所以这一步就已经包括寄存器的全部工作了。）</li>
<li>将指针送往内存管理单元（MMU），由MMU将虚拟的内存地址翻译成实际的物理地址。</li>
<li>将物理地址送往内存控制器（memory controller），由内存控制器找出该地址在哪一根内存插槽（bank）上。</li>
<li>确定数据在哪一个内存块（chunk）上，从该块读取数据。</li>
<li>数据先送回内存控制器，再送回CPU，然后开始使用。</li>
</ul>
<p>内存的工作流程比寄存器多出许多步。每一步都会产生延迟，累积起来就使得内存比寄存器慢得多。</p>
<h3 id="disk"><a href="#disk" class="headerlink" title="disk"></a>disk</h3><p>磁盘是计算机主要的存储介质，可以存储大量的二进制数据，并且断电后也能保持数据不丢失。早期计算机使用的磁盘是软磁盘（Floppy Disk，简称软盘），如今常用的磁盘是硬磁盘（Hard disk，简称硬盘）。硬盘有机械硬盘(HDD)和固态硬盘(SSD)之分。</p>
<p>机械硬盘即是传统普通硬盘，主要由：盘片，磁头，盘片转轴及控制电机。</p>
<p>固态硬盘是用固态电子存储芯片阵列制成的硬盘。</p>
<h2 id="主频"><a href="#主频" class="headerlink" title="主频"></a>主频</h2><h3 id="CPU主频"><a href="#CPU主频" class="headerlink" title="CPU主频"></a>CPU主频</h3><p>主频即CPU的时钟频率，计算机的操作在时钟信号的控制下分步执行，每个时钟信号周期完成一步操作，时钟频率的高低在很大程度上反映了CPU速度的快慢。<strong>主频不要理解成计算机执行指令的频率了，一个指令是在几个时钟周期完成和很多因素有关。</strong></p>
<p>对于上面的内存取数据的执行过程中，每个操作都需要占用一个时钟周期，对于一个操作内存的加法，就需要5个时钟周期，换句话说，500Mhz主频的CPU，最多执行100MHz条指令。对于CPU来说读&#x2F;写寄存器是不需要时间的，或者说如果只是操作寄存器（比如类似mov BX,AX之类的操作），那么一秒钟执行的指令个数理论上说就等于主频，因为寄存器是CPU的一部分。<strong>所以一个操作需要几条时钟周期也会影响执行速度。</strong></p>
<h3 id="内存访问速度"><a href="#内存访问速度" class="headerlink" title="内存访问速度"></a>内存访问速度</h3><ul>
<li><strong>内存本身更慢：</strong>内存的主频现在主流是1333左右吧？或者1600，单位是MHz，这比CPU的速度要低的多，所以内存的速度起点就更低。</li>
<li><strong>内存忙碌：</strong>内存不仅仅要跟CPU通信，还要通过DMA控制器与其它硬件通信，CPU要发起一次内存请求，先要给一个信号说“我要访问数据了，你忙不忙？”如果此时内存忙，则通信需要等待，不忙的时候，通信才能正常。并且，这个请求信号的时间代价，就是够执行几个汇编指令了，所以，这是内存慢的一个原因。</li>
<li><strong>内存总线：</strong>内存跟CPU之间通信的通道也是有限的，就是所谓的“总线带宽”，但，要记住这个带宽不仅仅是留给内存的，还包括显存之类的各种通信都要走这条路，并且由于路是共享的，所以任何请求发起之间都要先抢占，抢占带宽需要时间，带宽不够等待的话也需要时间。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="http://cenalulu.github.io/linux/all-about-cpu-cache/">cpu缓存：</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hellojoy/article/details/54744231">计算机中内存、cache和寄存器之间的关系及区别</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/19/blog/message%20queue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8Bkafka%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84%E4%BF%9D%E8%AF%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/19/blog/message%20queue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8Bkafka%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84%E4%BF%9D%E8%AF%81/" class="post-title-link" itemprop="url">消息队列之kafka可靠性的保证</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-19 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-19T00:00:00+08:00">2021-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>kafka 的可靠性保证和 tcp 的可靠性保证有一致的地方，就是都是基于消息的确认和重传来实现的。当然 tcp 还有滑动窗口，拥塞避免等特性。</p>
<p>为保证 producer 发送的数据，能可靠的发送到指定的 topic，topic 的每个 partition 收到。producer 发送的数据后，broker 都需要向 producer 发送 ack（acknowledgement 确认收到），如果 producer 收到 ack，就会进行下一轮的发送，否则重新发送数据。</p>
<h2 id="常见的两种保证"><a href="#常见的两种保证" class="headerlink" title="常见的两种保证"></a>常见的两种保证</h2><p>副本数据同步策略</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>半数以上完成同步，broker 发送 ack</td>
<td>延迟低</td>
<td>选举新的leader时，如果要容忍 n 个节点的故障，那么系统需要 2n + 1个节点</td>
</tr>
<tr>
<td>全部完成同步，broker 发送 ack</td>
<td>选举新的leader节点时，容忍 n 台节点的故障，需要 n+1 个副本</td>
<td>延迟高</td>
</tr>
</tbody></table>
<p>kafka 选择了第二种方案，原因如下</p>
<ul>
<li>第二种做数据镜像时，同样的容错下，第二种方案需要的节点更少。而kafka的每一个节点都存储这大量的数据，第一种方案会造成大量的数据冗余</li>
<li>第二种的劣势是网络延迟高，但是网络延迟对kafka的影响较小</li>
</ul>
<h2 id="kakfa-的优化（ISR-同步副本列表）"><a href="#kakfa-的优化（ISR-同步副本列表）" class="headerlink" title="kakfa 的优化（ISR 同步副本列表）"></a>kakfa 的优化（ISR 同步副本列表）</h2><h3 id="第二种存在的单节点问题"><a href="#第二种存在的单节点问题" class="headerlink" title="第二种存在的单节点问题"></a>第二种存在的单节点问题</h3><p>采用第二种方案之后, 设想以下场景: leader 收到数据, 所有follower 都开始同步数据,但有一个follower ,因为某种故障,迟迟不能与leader进行同步,<strong>那leader就要一直等下去,直到它完成同步,才能发送ack</strong>。那么一个节点的性能，就会影响整个数据镜像集群的性能了。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>Leader 维护了一个动态的in-sync replica set(ISR 同步副本列表) ,意为和leader保持同步的follower 集合. 当ISR 中的 follower 完成数据的同步之后, Leader就会给follower 发送ack如果 follower 长时间未向 leader 同步数据,则该follower 将被 提出ISR 。</p>
<h2 id="ack-机制"><a href="#ack-机制" class="headerlink" title="ack 机制"></a>ack 机制</h2><p>对于某些不太重要的数据,对数据的可靠性要求不要很高,能够容忍数据的少量丢失.所以没必要等ISR 中的follower 全部接受成功</p>
<p>所以Kafka 为用户提高了三种可靠性级别,当producer向leader发送数据时，可以通过request.required.acks参数来设置数据可靠性的级别：</p>
<h3 id="request-required-acks-x3D-1（默认）"><a href="#request-required-acks-x3D-1（默认）" class="headerlink" title="request.required.acks &#x3D; 1（默认）"></a>request.required.acks &#x3D; 1（默认）</h3><p>这意味着producer在ISR中的leader已成功收到的数据并得到确认后发送下一条message。如果leader宕机了（因为只有 ISR 中的leader 确认了消息），则会丢失数据。</p>
<p>producer发送数据到leader，leader写本地日志成功，返回客户端成功；此时ISR中的副本还没有来得及拉取该消息，leader就宕机了，那么此次发送的消息就会丢失。</p>
<h3 id="request-required-acks-x3D-0"><a href="#request-required-acks-x3D-0" class="headerlink" title="request.required.acks &#x3D; 0"></a>request.required.acks &#x3D; 0</h3><p>这意味着producer无需等待来自broker的确认而继续发送下一批消息。这种情况下数据传输效率最高，但是数据可靠性确是最低的。</p>
<h3 id="request-required-acks-x3D-1"><a href="#request-required-acks-x3D-1" class="headerlink" title="request.required.acks &#x3D; -1"></a>request.required.acks &#x3D; -1</h3><p>producer需要等待ISR中的所有follower都确认接收到数据后才算一次发送完成，可靠性最高。但是这样也不能保证数据不丢失，比如当ISR中只有leader时（前面ISR那一节讲到，ISR中的成员由于某些情况会增加也会减少，最少就只剩一个leader），这样就变成了acks&#x3D;1的情况。</p>
<p>acks&#x3D;-1的情况下，数据发送到leader后 ，部分ISR的副本同步，leader此时挂掉。比如follower1h和follower2都有可能变成新的leader, producer端会得到返回异常，producer端会重新发送数据，数据可能会重复。</p>
<h2 id="复制原理和同步方式"><a href="#复制原理和同步方式" class="headerlink" title="复制原理和同步方式"></a>复制原理和同步方式</h2><p>Kafka中topic的每个partition有一个预写式的日志文件，虽然partition可以继续细分为若干个segment文件，但是对于上层应用来说可以将partition看成最小的存储单元（一个有多个segment文件拼接的“巨型”文件），每个partition都由一些列有序的、不可变的消息组成，这些消息被连续的追加到partition中。</p>
<p>Kafka通过多副本机制实现故障自动转移，当Kafka集群中一个broker失效情况下仍然保证服务可用。在Kafka中发生复制时确保partition的日志能有序地写到其他节点上，N个replicas中，其中一个replica为leader，其他都为follower, <strong>leader处理partition的所有读写请求，与此同时，follower会被动定期地去复制leader上的数据。</strong></p>
<h3 id="LEO-amp-HW"><a href="#LEO-amp-HW" class="headerlink" title="LEO &amp; HW"></a>LEO &amp; HW</h3><p>LEO: 指的是每个副本最大的offset ;</p>
<p>HW: 指的是消费者能见到的最大的offset .ISR 队列中最小的LEO;</p>
<h3 id="follower-故障"><a href="#follower-故障" class="headerlink" title="follower 故障"></a>follower 故障</h3><p>follower 发生故障后会被临时提出ISR ,待该follower恢复后,follower会读取本地磁盘记录的上次的HW , 并将log文件高于HW的部分截掉,.从HW开始向leader进行同步,等该follower的LEO大于等于该Partition的HW,即follower 追上leader之后,就可以重新加入ISR 了。</p>
<h3 id="leader-故障"><a href="#leader-故障" class="headerlink" title="leader 故障"></a>leader 故障</h3><p>leader 发生故障之后,会从ISR 中选出一个新的leader ,之后,为保证多个副本之间的数据一致性,其余的follower会先将各自的log文件高于HW的部分截掉,然后从新的leader同步数据。</p>
<h2 id="可靠性的保证"><a href="#可靠性的保证" class="headerlink" title="可靠性的保证"></a>可靠性的保证</h2><h3 id="消息传输保障"><a href="#消息传输保障" class="headerlink" title="消息传输保障"></a>消息传输保障</h3><p>接下来讨论的是Kafka如何确保消息在producer和consumer之间传输。有以下三种可能的传输保障（delivery guarantee）:</p>
<ul>
<li>At most once: 消息可能会丢，但绝不会重复传输</li>
<li>At least once：消息绝不会丢，但可能会重复传输</li>
<li>Exactly once：每条消息肯定会被传输一次且仅传输一次</li>
</ul>
<h4 id="broker-的保证"><a href="#broker-的保证" class="headerlink" title="broker 的保证"></a>broker 的保证</h4><p>Kafka的消息传输保障机制非常直观。当producer向broker发送消息时，一旦这条消息被commit，由于副本机制（replication）的存在，它就不会丢失。但是如果producer发送数据给broker后，遇到的网络问题而造成通信中断，那producer就无法判断该条消息是否已经提交（commit）。<strong>虽然Kafka无法确定网络故障期间发生了什么，但是producer可以retry多次，确保消息已经正确传输到broker中，所以目前Kafka实现的是at least once。</strong></p>
<h4 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h4><p>consumer 最好的方法就是，在引入去重机制后，实现 at least once 的消费方式，即先取数据，然后做业务逻辑，最后commit。</p>
<h3 id="消息去重"><a href="#消息去重" class="headerlink" title="消息去重"></a>消息去重</h3><p>如上一节所述，Kafka在producer端和consumer端都会出现消息的重复，这就需要去重处理。</p>
<p>Kafka文档中提及GUID(Globally Unique Identifier)的概念，通过客户端生成算法得到每个消息的unique id，同时可映射至broker上存储的地址，即通过GUID便可查询提取消息内容，也便于发送方的幂等性保证，需要在broker上提供此去重处理模块，目前版本尚不支持。</p>
<p>针对GUID, 如果从客户端的角度去重，那么需要引入集中式缓存，必然会增加依赖复杂度，另外缓存的大小难以界定。</p>
<p>不只是Kafka, 类似RabbitMQ以及RocketMQ这类商业级中间件也只保障at least once, 且也无法从自身去进行消息去重。所以我们建议业务方根据自身的业务特点进行去重，比如业务消息本身具备幂等性，或者借助Redis等其他产品进行去重处理。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/91043276">KafKa 数据可靠性保证!</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1031803">Kafka 数据可靠性深度解读</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/17/blog/http/tcp%E4%B9%8B%E4%B8%8Daccept/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/17/blog/http/tcp%E4%B9%8B%E4%B8%8Daccept/" class="post-title-link" itemprop="url">tcp之不accept</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-17 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-17T00:00:00+08:00">2021-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>其实如果 tcp server 端不 accept 就和线上因为 server 端阻塞，没有 accept 是一样的。</p>
<p>结论是连接能够建立，但是没有accept函数调用，那么所有的已建立好的连接都会堵塞在全连接队列里，当队列满了以后，就会拒绝建立连接了。</p>
<h2 id="accept-函数调用"><a href="#accept-函数调用" class="headerlink" title="accept 函数调用"></a>accept 函数调用</h2><p>The accept() system call is used with connection-based socket types (SOCK_STREAM, SOCK_SEQPACKET).  It extracts the first connection request on the queue of pending connections for the listen‐ing socket, sockfd, creates a new connected socket, and returns a new file descriptor referring to that socket.  The newly created socket is not in the listening state.   The  original  socket sockfd is unaffected by this call.</p>
<p>accept函数的作用是从”pending connections”队列中取出第一个连接，并生成一个新的连接套接字返回给应用程序，用于进行读写操作，并且不会影响原有的监听套接字；</p>
<h2 id="两种状态的连接"><a href="#两种状态的连接" class="headerlink" title="两种状态的连接"></a>两种状态的连接</h2><p>具体来说，在协议栈的实现中，根据连接的状态划分出了两种类型：</p>
<ul>
<li>incomplete connection （半开连接，处于SYN_RECV状态，还没有收到最后一个ACK）</li>
<li>completely established socket （已完成连接，处于ESTABLISHED状态）</li>
</ul>
<p>而listen函数的backlog参数指定的是已完成连接队列的最大长度。</p>
<h2 id="连接满了怎么办"><a href="#连接满了怎么办" class="headerlink" title="连接满了怎么办"></a>连接满了怎么办</h2><p>当全连接队列已经满了，继续尝试建立连接。可以看到，之后的连接都停留在SYN_RECV状态，抓包可以看到，server端收到了client的最后一个ACK，但仍然会重传SYN&#x2F;ACK，通过查看协议栈代码可知，此时的行为与sysctl_tcp_abort_on_overflow（&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_abort_on_overflow）的值有关：</p>
<ul>
<li>当sysctl_tcp_abort_on_overflow为0时（default）：compeletly established queue满了之后服务器会丢掉第三个ACK；</li>
<li>否则，直接发RST；</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://my.oschina.net/u/2310891/blog/374985">由“socket程序listen之后不accept“说起</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/01/blog/concurrent%20and%20gc/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%8F%8A%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/01/blog/concurrent%20and%20gc/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%8F%8A%E9%94%81/" class="post-title-link" itemprop="url">并发基础及锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-01 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-01T00:00:00+08:00">2021-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>当并发的访问某个类或者方法时，主调代码中不需要额外的同步或协同，类或者方法都能表现出正确的行为，这就是线程安全的。<strong>并发安全必须保证以下三要素</strong>。</p>
<h3 id="并发编程的三要素（并发安全性）"><a href="#并发编程的三要素（并发安全性）" class="headerlink" title="并发编程的三要素（并发安全性）"></a>并发编程的三要素（并发安全性）</h3><ul>
<li>原子性： 一系列操作要么全部执行要么失败（一些cpu指令全部执行成功，或全部失败。最好就是只有一条cpu指令）或者也叫互斥性，互斥性有两种实现方式，<strong>锁或原子操作</strong>。</li>
<li>有序性  程序按照代码的顺序先后执行 避免指令重排列。</li>
<li>可见性 当多线程访问同一个变量 其中一个线程修改了 其他线程也要读新的值（这其实）。</li>
</ul>
<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><h3 id="互斥锁与自旋锁"><a href="#互斥锁与自旋锁" class="headerlink" title="互斥锁与自旋锁"></a>互斥锁与自旋锁</h3><p>最底层的两种就是会「互斥锁和自旋锁」，有很多高级的锁都是基于它们实现的，你可以认为它们是各种锁的地基，所以我们必须清楚它俩之间的区别和应用。</p>
<ul>
<li><strong>互斥锁</strong>加锁失败后，线程会<strong>释放 CPU</strong> ，给其他线程；</li>
<li><strong>自旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁；</li>
</ul>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，<strong>既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞</strong>。</p>
<h5 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h5><p>互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。</p>
<p>那这个开销成本是什么呢？会有<strong>两次线程上下文切换的成本</strong>：</p>
<ul>
<li>当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；</li>
<li>接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。</li>
</ul>
<p>线程的上下文切换的是什么？当两个线程是属于同一个进程，<strong>因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</strong></p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p><strong>自旋锁是通过 CPU 提供的 <code>CAS</code> 函数（Compare And Swap）来实现的</strong>，在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。</p>
<p>一般加锁的过程，包含两个步骤：</p>
<ul>
<li>第一步，查看锁的状态，如果锁是空闲的，则执行第二步；</li>
<li>第二步，将锁设置为当前线程持有；</li>
</ul>
<p>CAS 函数就把这两个步骤合并成一条硬件级指令，形成<strong>原子指令</strong>，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。</p>
<p>使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 <code>while</code> 循环等待实现，不过最好是使用 CPU 提供的 <code>PAUSE</code> 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。</p>
<p>自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。<strong>需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。</strong></p>
<p>自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式，但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系，我们需要清楚的知道这一点。</p>
<p>自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：<strong>当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对</strong>。</p>
<p>它俩是锁的最基本处理方式，更高级的锁都会选择其中一个来实现，比如读写锁既可以选择互斥锁实现，也可以基于自旋锁实现。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁的工作原理是：</p>
<ul>
<li>当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。</li>
<li>但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。</li>
</ul>
<h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><ul>
<li>悲观锁做事比较悲观，它认为<strong>多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁</strong>。</li>
<li>乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：<strong>先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作</strong>。</li>
</ul>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁的实现：</p>
<ul>
<li>CAS 实现：Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。</li>
<li>版本号控制：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会+1。当线程A要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</li>
</ul>
<h4 id="MySQL-乐观锁-（CAS）"><a href="#MySQL-乐观锁-（CAS）" class="headerlink" title="MySQL 乐观锁 （CAS）"></a>MySQL 乐观锁 （CAS）</h4><p>扣减库存问题，通过乐观锁可以实现如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询商品库存信息， quantity查出来为<span class="number">3</span></span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 修改商品库存为 <span class="number">2</span></span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity <span class="operator">=</span> <span class="number">2</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> quantity <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>在更新之前，先查询一下库存表中当前库存数(quantity)，然后在做 update 的时候，以库存数作为一个修改条件。当提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据。</p>
<h4 id="基于版本号解决-ABA-问题"><a href="#基于版本号解决-ABA-问题" class="headerlink" title="基于版本号解决 ABA 问题"></a>基于版本号解决 ABA 问题</h4><p>通过一个单独的可以顺序递增的 version 字段，解决 ABA 问题。</p>
<p>乐观锁每次在执行数据修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行 +1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题。除了 version 以外，还可以使用时间戳，因为时间戳天然具有顺序递增性。</p>
<h4 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h4><p>以上 SQL 其实还是有一定的问题的，就是一旦遇上高并发的时候，就只有一个线程可以修改成功，那么就会存在大量的失败。对于像淘宝这样的电商网站，高并发是常有的事，总让用户感知到失败显然是不合理的。所以，还是要想办法减少乐观锁的粒度。一个比较好的建议，就是减小乐观锁力度，最大程度的提升吞吐率，提高并发能力！</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 修改商品库存为 <span class="number">2</span></span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity <span class="operator">=</span> <span class="number">2</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> quantity <span class="operator">-</span> <span class="number">1</span> <span class="operator">&gt;</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>以上 SQL 语句中，如果用户下单数为 1，则通过<code>quantity - 1 &gt; 0</code>的方式进行乐观锁控制。在执行过程中，会在一次原子操作中查询一遍 quantity 的值，并将其扣减掉 1。</p>
<h2 id="Golang-实现"><a href="#Golang-实现" class="headerlink" title="Golang 实现"></a>Golang 实现</h2><h3 id="互斥锁-1"><a href="#互斥锁-1" class="headerlink" title="互斥锁"></a>互斥锁</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gTotal <span class="type">int32</span> = <span class="number">10000</span></span><br><span class="line"><span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sellerSafe</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line">	gTotal--</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数之所以线程不安全，是因为没有支持 可见性，即在一个协程中的修改在另一个协程中不可见（不可见意味了另一个协程还在使用更新前的数据）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sellerUnSafe</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	gTotal--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// 正确 9000</span></span><br><span class="line">			<span class="comment">//sellerSafe(i)</span></span><br><span class="line">			<span class="comment">// 不正确 != 9000</span></span><br><span class="line">			sellerUnSafe(i)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;gTotal: &quot;</span>, gTotal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cas实现的乐观锁"><a href="#cas实现的乐观锁" class="headerlink" title="cas实现的乐观锁"></a>cas实现的乐观锁</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> valueCas <span class="type">int32</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;======old valueCas=======&quot;</span>)</span><br><span class="line">	fmt.Println(valueCas)</span><br><span class="line">	fmt.Println(<span class="string">&quot;======CAS valueCas=======&quot;</span>)</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(tmp <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">			addValue(<span class="number">1</span>)</span><br><span class="line">			<span class="comment">//addValueBad(int32(tmp))</span></span><br><span class="line">			<span class="comment">//addValueBadSwap(1)</span></span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(valueCas)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</span></span><br><span class="line"><span class="comment">		1. 调用函数后，会先判断参数addr指向的被操作值与参数old的值是否相等</span></span><br><span class="line"><span class="comment">			（这是 cas 操作的精髓所在， 这能保证 只有在old值没有被修改时，才会做交换操作。所以将 old 从地址中取出来，并使用old参与其他的，这都是多线程安全的）。</span></span><br><span class="line"><span class="comment">		2. 只有判断到是相等时（说明其他线程没有修改old），才会用参数new代表的新值替换掉原先的旧值，否则操作就会被忽略。</span></span><br><span class="line"><span class="comment">		3. 因此, 需要用for循环不断进行尝试,直到成功为止。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">cas: 以下几个操作，一般情况下是对应多条指令， 但是在 cas 操作中可以理解为为了一条cpu指令，包括从 addr中取址， 和old比较，赋值等</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	if *addr == old &#123;</span></span><br><span class="line"><span class="comment">	*addr = new</span></span><br><span class="line"><span class="comment">	return true</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	return false</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">swap:</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	old = *addr</span></span><br><span class="line"><span class="comment">	*addr = new</span></span><br><span class="line"><span class="comment">	return old</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cas</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addValue</span><span class="params">(delta <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 这里直接读数据就可以了，因为 cas 会将 v 和 地址中的值做比较</span></span><br><span class="line">		old := valueCas</span><br><span class="line">		new_ := old + delta</span><br><span class="line">		<span class="comment">// 1. 如果 v 和 valueCas 地址中的值不一致，不会 swap</span></span><br><span class="line">		<span class="comment">// 2. v 和 valueCas 地址中的值不一致, swap</span></span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;valueCas, old, new_) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// hits 这里触发了， 说明发生了 race</span></span><br><span class="line">		<span class="comment">//fmt.Println(&quot;hits&quot;)</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个数据是错误的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addValueBad</span><span class="params">(delta <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">	valueCas += delta</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// swap 也是不能保证的， 因为 v + delta 不是原子的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addValueBadSwap</span><span class="params">(delta <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">	v := atomic.LoadInt32(&amp;valueCas)</span><br><span class="line">	atomic.SwapInt32(&amp;valueCas, v+delta)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="CAS-的问题"><a href="#CAS-的问题" class="headerlink" title="CAS 的问题"></a>CAS 的问题</h3><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</p>
<h4 id="开销大"><a href="#开销大" class="headerlink" title="开销大"></a>开销大</h4><p>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p>
<h4 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h4><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。</p>
<h3 id="CAS-总结"><a href="#CAS-总结" class="headerlink" title="CAS 总结"></a>CAS 总结</h3><p>可以用CAS在无锁的情况下实现原子操作，但要明确应用场合，<strong>非常简单的操作且又不想引入锁</strong>可以考虑使用CAS操作，当想要非阻塞地完成某一操作也可以考虑CAS。不推荐在复杂操作中引入CAS，会使程序可读性变差，且难以测试，同时会出现ABA问题。</p>
<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><ul>
<li>并行性是指两个或多个事件在<strong>同一时刻</strong>发生</li>
<li>并发性是指两个或多个事件在<strong>同一时间间隔内</strong>发生<ul>
<li>并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中每一时刻却仅能有一道程序执行，<strong>故在一个处理器上，微观上这些程序只能是分时地交替执行</strong>。倘若在计算机系统中有多个处理机，则这些可以并发执行的程序便可被分配到多个处理机上，实现并行执行，即<strong>利用每个处理机来处理一个可并发执行的程序</strong>，这样，多个程序便可同时执行</li>
</ul>
</li>
</ul>
<p><strong>简单说，并发编程指的是赋予程序可以并行运行的能力。并行如上所说，指的是同时执行。</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/246114725">面试官：你说说互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015239603">并发编程—CAS（Compare And Swap）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d2ac26ca6525">什么是乐观锁，什么是悲观锁</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/24/blog/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%A0%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/24/blog/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%A0%86/" class="post-title-link" itemprop="url">数据结构之堆</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-24 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-24T00:00:00+08:00">2021-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>堆是一种特殊的树，只要满足下面两个条件，它就是一个堆：</p>
<ul>
<li>堆是一颗完全二叉树；</li>
<li>堆中某个节点的值总是不大于（或不小于）其父节点的值。</li>
</ul>
<p>其中，我们把根节点最大的堆叫做大顶堆，根节点最小的堆叫做小顶堆。</p>
<h3 id="二叉树概念"><a href="#二叉树概念" class="headerlink" title="二叉树概念"></a>二叉树概念</h3><ul>
<li>满二叉树是指所有层都达到最大节点数的二叉树。</li>
<li>完全二叉树是指除了最后一层其它层都达到最大节点数，且最后一层节点都靠左排列。</li>
</ul>
<p>我们可以看见，完全二叉树的节点都是比较紧凑的，且只有最后一层是不满的，所以使用数组是最节省空间的。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆也是一颗完全二叉树，但是它的元素必须满足每个节点的值都不大于（或不小于）其父节点的值。比如下面这个堆：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/yOPA3D"><img src="https://s3.ax1x.com/2021/02/24/yOPA3D.png" alt="yOPA3D.png"></a></p>
<h2 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h2><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>在完全二叉树中，插入的节点与它的父节点相比，如果比父节点小，就交换它们的位置，再往上和父节点相比，如果比父节点小，再交换位置，直到比父节点大为止。</p>
<p>在数组中，插入的节点与n&#x2F;2位置的节点相比，如果比n&#x2F;2位置的节点小，就交换它们的位置，再往前与n&#x2F;4位置的节点相比，如果比n&#x2F;4位置的节点小，再交换位置，直到比n&#x2F;(2^x)位置的节点大为止。</p>
<p>这就是插入元素时进行的<strong>堆化</strong>，也叫自下而上的堆化。</p>
<p>从插入元素的过程，我们知道每次与n&#x2F;(2^x)的位置进行比较，所以，插入元素的时间复杂度为O(log n)。</p>
<h3 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h3><p><strong>只能删除堆顶元素，不能删除其他位置的元素，其他位置实际上都是乱序的，只有堆顶能保证是最大或者最小</strong></p>
<h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>假定给定一组乱序的数组，我们该怎么建堆呢？</p>
<p>如下图所示，我们模拟依次往堆中添加元素。</p>
<p>（1）插入6这个元素，只有一个，不需要比较；</p>
<p>（2）插入8这个元素，比6大，不需要交换；</p>
<p>（3）插入3这个元素，比下标3&#x2F;2&#x3D;1的位置上的元素6小，交换位置；</p>
<p>（4）插入2这个元素，比下标4&#x2F;2&#x3D;2的位置上的元素8小，交换位置，比下标2&#x2F;2&#x3D;1的位置上的元素3小，交换位置；</p>
<p>（5）…</p>
<p>（10）最后，全部插入完成，即完成了建堆的过程。</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>我们直接把堆顶的元素与第n个元素交换位置，再把前(n-1)个元素堆化，再把堆顶元素与第(n-1)个元素交换位置，<br>再把前(n-2)个元素堆化，..，，进行下去，最后，数组中的元素就整个变成倒序的了，也就排序完了。</p>
<h2 id="堆使用"><a href="#堆使用" class="headerlink" title="堆使用"></a>堆使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  默认小顶堆（最小堆）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>():</span><br><span class="line">    <span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">    q = []</span><br><span class="line"></span><br><span class="line">    heapq.heappush(q, (<span class="number">2</span>, <span class="string">&#x27;code&#x27;</span>))</span><br><span class="line">    heapq.heappush(q, (<span class="number">1</span>, <span class="string">&#x27;eat&#x27;</span>))</span><br><span class="line">    heapq.heappush(q, (<span class="number">3</span>, <span class="string">&#x27;sleep&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        next_item = heapq.heappop(q)</span><br><span class="line">        <span class="built_in">print</span>(next_item)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">minHeap</span>():</span><br><span class="line">    arr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        heapq.heappush(arr, i)</span><br><span class="line">    <span class="built_in">print</span>(arr[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maxHeap</span>():</span><br><span class="line">    arr = []</span><br><span class="line">    N = <span class="number">20</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        heapq.heappush(arr, -i)</span><br><span class="line">    <span class="built_in">print</span>(-arr[<span class="number">0</span>] == N)</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/63089552">拜托，面试别再问我堆（排序）了！</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/circle/article/bNtb4J/">https://leetcode-cn.com/circle/article/bNtb4J/</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1163053">https://cloud.tencent.com/developer/article/1163053</a></p>
<p><a target="_blank" rel="noopener" href="https://studygolang.com/articles/24288">https://studygolang.com/articles/24288</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/22/blog/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSortedList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/22/blog/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSortedList/" class="post-title-link" itemprop="url">数据结构之SortedList</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-22 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-22T00:00:00+08:00">2021-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SortedList 可以在对数时间内增加或删除一个元素，并且，能在常数时间内获取最大值和最小值，并且其遍历是有序的。</p>
<p>他的实现是使用了分段数组。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sortedListDemo</span>():</span><br><span class="line">    <span class="comment"># 可以看到是有序的</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    SortedList 可以在对数时间内增加或删除一个元素，并且，能在常数时间内获取最大值和最小值，并且其遍历是有序的。</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">10</span>, <span class="string">&quot;SortedList&quot;</span>)</span><br><span class="line">    sl = sortedcontainers.SortedList([<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;g&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(sl)</span><br><span class="line">    <span class="built_in">print</span>(sl[<span class="number">1</span>])</span><br><span class="line">    sl.add(<span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(sl)</span><br><span class="line">    slice1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    slice1.insert(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(slice1)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> sl:</span><br><span class="line">        <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>

<h3 id="1438-绝对差不超过限制的最长连续子数组"><a href="#1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="1438. 绝对差不超过限制的最长连续子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. 绝对差不超过限制的最长连续子数组</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestSubarray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], limit: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">import</span> sortedcontainers</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        难点：对于任意区间，怎样在logK时间知道最大值和最小值的差值呢！</span></span><br><span class="line"><span class="string">        选用合适的数据结构 SortedList</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        window = sortedcontainers.SortedList()</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> right &lt; N:</span><br><span class="line">            window.add(nums[right])</span><br><span class="line">            <span class="keyword">while</span> window[-<span class="number">1</span>] - window[<span class="number">0</span>] &gt; limit:</span><br><span class="line">                window.remove(nums[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, right-left+<span class="number">1</span>)</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://github.com/grantjenks/python-sortedcontainers">github</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/21/blog/http/http%E4%B9%8Bgrpc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/21/blog/http/http%E4%B9%8Bgrpc/" class="post-title-link" itemprop="url">http之grpc</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-21 08:29:29" itemprop="dateCreated datePublished" datetime="2021-02-21T08:29:29+08:00">2021-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index"><span itemprop="name">http</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>gRPC 是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP&#x2F;2 设计。目前提供 C、Java 和 Go 语言版本，分别是：grpc, grpc-java, grpc-go. 其中 C 版本支持 C, C++, Node.js, Python, Ruby, Objective-C, PHP 和 C# 支持。</p>
<p><strong>gRPC 基于 HTTP&#x2F;2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特性。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。</strong></p>
<p>gGRPC把元数据放到HTTP&#x2F;2 Headers里，请求参数序列化之后放到 DATA frame里。</p>
<h2 id="调用模型"><a href="#调用模型" class="headerlink" title="调用模型"></a>调用模型</h2><p>1、客户端（gRPC Stub）调用 A 方法，发起 RPC 调用。</p>
<p>2、对请求信息使用 Protobuf 进行对象序列化压缩（IDL）。</p>
<p>3、服务端（gRPC Server）接收到请求后，解码请求体，进行业务逻辑处理并返回。</p>
<p>4、对响应结果使用 Protobuf 进行对象序列化压缩（IDL）。</p>
<p>5、客户端接受到服务端响应，解码请求体。回调被调用的 A 方法，唤醒正在等待响应（阻塞）的客户端调用并返回响应结果。</p>
<h2 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h2><ul>
<li>Unary RPC：一元 RPC</li>
<li>Server-side streaming RPC：服务端流式 RPC</li>
<li>Client-side streaming RPC：客户端流式 RPC</li>
<li>Bidirectional streaming RPC：双向流式 RPC</li>
</ul>
<h2 id="客户端与服务端是如何交互的"><a href="#客户端与服务端是如何交互的" class="headerlink" title="客户端与服务端是如何交互的"></a>客户端与服务端是如何交互的</h2><h3 id="行为分析"><a href="#行为分析" class="headerlink" title="行为分析"></a>行为分析</h3><h4 id="Magic"><a href="#Magic" class="headerlink" title="Magic"></a>Magic</h4><p>Magic 帧的主要作用是建立 HTTP&#x2F;2 请求的前言。在 HTTP&#x2F;2 中，要求两端都要发送一个连接前言，作为对所使用协议的最终确认，并确定 HTTP&#x2F;2 连接的初始设置，客户端和服务端各自发送不同的连接前言。</p>
<h4 id="SETTINGS"><a href="#SETTINGS" class="headerlink" title="SETTINGS"></a>SETTINGS</h4><p>SETTINGS 帧的主要作用是设置这一个连接的参数，作用域是整个连接而并非单一的流。</p>
<p>而上图的 SETTINGS 帧都是空 SETTINGS 帧，图一是客户端连接的前言（Magic 和 SETTINGS 帧分别组成连接前言）。图二是服务端的。另外我们从图中可以看到多个 SETTINGS 帧，这是为什么呢？是因为发送完连接前言后，客户端和服务端还需要有一步互动确认的动作。对应的就是带有 ACK 标识 SETTINGS 帧。</p>
<h4 id="HEADERS"><a href="#HEADERS" class="headerlink" title="HEADERS"></a>HEADERS</h4><p>HEADERS 帧的主要作用是存储和传播 HTTP 的标头信息。我们关注到 HEADERS 里有一些眼熟的信息，分别如下， <strong>主要是HTTP2的标头压缩</strong>：</p>
<ul>
<li>method：POST</li>
<li>scheme：http</li>
<li>path：&#x2F;proto.SearchService&#x2F;Search</li>
<li>authority：:10001</li>
<li>content-type：application&#x2F;grpc</li>
<li>user-agent：grpc-go&#x2F;1.20.0-dev</li>
</ul>
<p>你会发现这些东西非常眼熟，其实都是 gRPC 的基础属性，实际上远远不止这些，只是设置了多少展示多少。例如像平时常见的 <code>grpc-timeout</code>、<code>grpc-encoding</code> 也是在这里设置的。</p>
<h4 id="DATA"><a href="#DATA" class="headerlink" title="DATA"></a>DATA</h4><p>DATA 帧的主要作用是装填主体信息，是数据帧。而在上图中，可以很明显看到我们的请求参数 gRPC 存储在里面。只需要了解到这一点就可以了。</p>
<h4 id="PING-x2F-PONG"><a href="#PING-x2F-PONG" class="headerlink" title="PING&#x2F;PONG"></a>PING&#x2F;PONG</h4><p>主要作用是判断当前连接是否仍然可用，也常用于计算往返时间。其实也就是 PING&#x2F;PONG，大家对此应该很熟。</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>参考<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/o-K7G9ywCdmW7et6Q4WMeA">万字长文 | 从实践到原理，带你参透 gRPC</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/o-K7G9ywCdmW7et6Q4WMeA">万字长文 | 从实践到原理，带你参透 gRPC</a></p>
<p><a target="_blank" rel="noopener" href="http://hengyunabc.github.io/thinking-about-grpc-http2/">http://hengyunabc.github.io/thinking-about-grpc-http2/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/21/blog/http/http%E4%B9%8Bgrpc%E4%B9%8Bzrpc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/21/blog/http/http%E4%B9%8Bgrpc%E4%B9%8Bzrpc/" class="post-title-link" itemprop="url">http之grpc之zrpc</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-21 08:29:29" itemprop="dateCreated datePublished" datetime="2021-02-21T08:29:29+08:00">2021-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index"><span itemprop="name">http</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>zRPC 主要有以下几个模块组成：</p>
<ul>
<li>discov: 服务发现模块，基于 etcd 实现服务发现功能</li>
<li>resolver: 服务注册模块，实现了 gRPC 的 resolver.Builder 接口并注册到 gRPC</li>
<li>interceptor: 拦截器，对请求和响应进行拦截处理</li>
<li>balancer: 负载均衡模块，实现了 p2c 负载均衡算法，并注册到 gRPC</li>
<li>client: zRPC 客户端，负责发起请求</li>
<li>server: zRPC 服务端，负责处理请求</li>
</ul>
<p>其中 resolver 和 balancer 模块实现了 gRPC 开放的接口，实现了自定义的 resolver 和 balancer，拦截器模块是整个 zRPC 的功能重点。</p>
<h2 id="resolver-模块"><a href="#resolver-模块" class="headerlink" title="resolver 模块"></a>resolver 模块</h2><p>zRPC 中自定义了 resolver 模块，用来实现服务的注册功能。zRPC 底层依赖 gRPC，在 gRPC 中要想自定义 resolver 需要实现 resolver.Builder 接口：</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>当我们启动我们的 zRPC Server 的时候，调用 Start 方法，会向 etcd 中注册对应的服务地址：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ags keepAliveServer)</span></span> Start(fn RegisterFn) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// 注册服务地址</span></span><br><span class="line">    <span class="keyword">if</span> err := ags.registerEtcd(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    <span class="keyword">return</span> ags.Server.Start(fn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="put-key-value-to-etcd"><a href="#put-key-value-to-etcd" class="headerlink" title="put key value to etcd"></a>put key value to etcd</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// value 是当前服务的地址</span></span><br><span class="line">_, err = client.Put(client.Ctx(), p.fullKey, p.value, clientv3.WithLease(lease))</span><br></pre></td></tr></table></figure>

<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><p>在 grpc.DialContext 函数中会调用 newCCResolverWrapper 函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newCCResolverWrapper uses the resolver.Builder to build a Resolver and</span></span><br><span class="line"><span class="comment">// returns a ccResolverWrapper object which wraps the newly built resolver.</span></span><br><span class="line"><span class="comment">// rb 和 scheme 有关</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCCResolverWrapper</span><span class="params">(cc *ClientConn, rb resolver.Builder)</span></span> (*ccResolverWrapper, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="comment">// build</span></span><br><span class="line">	ccr.resolver, err = rb.Build(cc.parsedTarget, ccr, rbo)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ccr, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="build-接口"><a href="#build-接口" class="headerlink" title="build 接口"></a>build 接口</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Builder creates a resolver that will be used to watch name resolution updates.</span></span><br><span class="line"><span class="keyword">type</span> Builder <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Build creates a new resolver for the given target.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// gRPC dial calls Build synchronously, and fails if the returned error is</span></span><br><span class="line">	<span class="comment">// not nil.</span></span><br><span class="line">	Build(target Target, cc ClientConn, opts BuildOptions) (Resolver, <span class="type">error</span>)</span><br><span class="line">	<span class="comment">// Scheme returns the scheme supported by this resolver.</span></span><br><span class="line">	<span class="comment">// Scheme is defined at https://github.com/grpc/grpc/blob/master/doc/naming.md.</span></span><br><span class="line">	Scheme() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="resolver-接口"><a href="#resolver-接口" class="headerlink" title="resolver 接口"></a>resolver 接口</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Resolver watches for the updates on the specified target.</span></span><br><span class="line"><span class="comment">// Updates include address updates and service config updates.</span></span><br><span class="line"><span class="keyword">type</span> Resolver <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// ResolveNow will be called by gRPC to try to resolve the target name</span></span><br><span class="line">	<span class="comment">// again. It&#x27;s just a hint, resolver can ignore this if it&#x27;s not necessary.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// It could be called multiple times concurrently.</span></span><br><span class="line">	ResolveNow(ResolveNowOptions)</span><br><span class="line">	<span class="comment">// Close closes the resolver.</span></span><br><span class="line">	Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><p>当我们启动 zRPC 客户端的时候，在 gRPC 内部会调用我们自定义 resolver 的 Build 方法，zRPC 通过在 Build 方法内调用执行了 resolver.ClientConn 的 UpdateState 方法，该方法会把服务地址注册到 gRPC 客户端内部：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *discovBuilder)</span></span> Build(target resolver.Target, cc resolver.ClientConn, opts resolver.BuildOptions) (</span><br><span class="line">    resolver.Resolver, <span class="type">error</span>) &#123;</span><br><span class="line">    hosts := strings.FieldsFunc(target.Authority, <span class="function"><span class="keyword">func</span><span class="params">(r <span class="type">rune</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r == EndpointSepChar</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="comment">// 服务发现</span></span><br><span class="line">    sub, err := discov.NewSubscriber(hosts, target.Endpoint)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    update := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> addrs []resolver.Address</span><br><span class="line">        <span class="keyword">for</span> _, val := <span class="keyword">range</span> subset(sub.Values(), subsetSize) &#123;</span><br><span class="line">            addrs = <span class="built_in">append</span>(addrs, resolver.Address&#123;</span><br><span class="line">                Addr: val,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 向gRPC注册服务地址</span></span><br><span class="line">        cc.UpdateState(resolver.State&#123;</span><br><span class="line">            Addresses: addrs,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 监听</span></span><br><span class="line">    sub.AddListener(update)</span><br><span class="line">    update()</span><br><span class="line">    <span class="comment">// 返回自定义的resolver.Resolver</span></span><br><span class="line">    <span class="keyword">return</span> &amp;nopResolver&#123;cc: cc&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 discov 中，通过调用 load 方法从 etcd 中获取指定服务的所有地址：</p>
<p>并通过 watch 监听服务地址的变化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cluster)</span></span> watch(cli EtcdClient, key <span class="type">string</span>) &#123;</span><br><span class="line">    rch := cli.Watch(clientv3.WithRequireLeader(c.context(cli)), makeKeyPrefix(key), clientv3.WithPrefix())</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> wresp, ok := &lt;-rch:</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                logx.Error(<span class="string">&quot;etcd monitor chan has been closed&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> wresp.Canceled &#123;</span><br><span class="line">                logx.Error(<span class="string">&quot;etcd monitor chan has been canceled&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> wresp.Err() != <span class="literal">nil</span> &#123;</span><br><span class="line">                logx.Error(fmt.Sprintf(<span class="string">&quot;etcd monitor chan error: %v&quot;</span>, wresp.Err()))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 监听变化通知更新</span></span><br><span class="line">            c.handleWatchEvents(key, wresp.Events)</span><br><span class="line">        <span class="keyword">case</span> &lt;-c.done:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分主要介绍了 zRPC 中是如何自定义的 resolver，以及基于 etcd 的服务发现原理，通过这部分的介绍大家可以了解到 zRPC 内部服务注册发现的原理，源代码比较多只是粗略的从整个流程上进行了分析，如果大家对 zRPC 的源码比较感兴趣可以自行进行学习</p>
<h2 id="balancer-模块"><a href="#balancer-模块" class="headerlink" title="balancer 模块"></a>balancer 模块</h2><p>避免过载是负载均衡策略的一个重要指标，好的负载均衡算法能很好的平衡服务端资源。常用的负载均衡算法有轮训、随机、Hash、加权轮训等。但为了应对各种复杂的场景，简单的负载均衡算法往往表现的不够好，比如轮训算法当服务响应时间变长就很容易导致负载不再平衡， 因此 zRPC 中自定义了默认负载均衡算法 P2C(Power of Two Choices)，和 resolver 类似，要想自定义 balancer 也需要实现 gRPC 定义的 balancer.Builder 接口，由于和 resolver 类似这里不再带大家一起分析如何自定义 balancer，感兴趣的朋友可以查看 gRPC 相关的文档来进行学习</p>
<p>注意，zRPC 是在客户端进行负载均衡，常见的还有通过 nginx 中间代理的方式</p>
<p>zRPC 框架中默认的负载均衡算法为 P2C，该算法的主要思想是：</p>
<ol>
<li>从可用节点列表中做两次随机选择操作，得到节点 A、B</li>
<li>比较 A、B 两个节点，选出负载最低的节点作为被选中的节点</li>
</ol>
<h4 id="client-1"><a href="#client-1" class="headerlink" title="client"></a>client</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(target <span class="type">string</span>, opts ...ClientOption)</span></span> (*client, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> cli client</span><br><span class="line">    <span class="comment">// WithBalancerName 指定 p2c.Name</span></span><br><span class="line">	opts = <span class="built_in">append</span>([]ClientOption&#123;WithDialOption(grpc.WithBalancerName(p2c.Name))&#125;, opts...)</span><br><span class="line">	<span class="keyword">if</span> err := cli.dial(target, opts...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;cli, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pick"><a href="#pick" class="headerlink" title="pick"></a>pick</h4><p>主要算法逻辑在 Pick 方法中实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *p2cPicker)</span></span> Pick(ctx context.Context, info balancer.PickInfo) (</span><br><span class="line">	conn balancer.SubConn, done <span class="function"><span class="keyword">func</span><span class="params">(balancer.DoneInfo)</span></span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	p.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> chosen *subConn</span><br><span class="line">	<span class="keyword">switch</span> <span class="built_in">len</span>(p.conns) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, balancer.ErrNoSubConnAvailable</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		chosen = p.choose(p.conns[<span class="number">0</span>], <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		chosen = p.choose(p.conns[<span class="number">0</span>], p.conns[<span class="number">1</span>])</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">var</span> node1, node2 *subConn</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; pickTimes; i++ &#123;</span><br><span class="line">			a := p.r.Intn(<span class="built_in">len</span>(p.conns))</span><br><span class="line">			b := p.r.Intn(<span class="built_in">len</span>(p.conns) - <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">if</span> b &gt;= a &#123;</span><br><span class="line">				b++</span><br><span class="line">			&#125;</span><br><span class="line">			node1 = p.conns[a]</span><br><span class="line">			node2 = p.conns[b]</span><br><span class="line">			<span class="keyword">if</span> node1.healthy() &amp;&amp; node2.healthy() &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		chosen = p.choose(node1, node2)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	atomic.AddInt64(&amp;chosen.inflight, <span class="number">1</span>)</span><br><span class="line">	atomic.AddInt64(&amp;chosen.requests, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> chosen.conn, p.buildDoneFunc(chosen), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>choose 方法对随机选择出来的节点进行负载比较从而最终确定选择哪个节点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *p2cPicker)</span></span> choose(c1, c2 *subConn) *subConn &#123;</span><br><span class="line">	start := <span class="type">int64</span>(timex.Now())</span><br><span class="line">	<span class="keyword">if</span> c2 == <span class="literal">nil</span> &#123;</span><br><span class="line">		atomic.StoreInt64(&amp;c1.pick, start)</span><br><span class="line">		<span class="keyword">return</span> c1</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c1.load() &gt; c2.load() &#123;</span><br><span class="line">		c1, c2 = c2, c1</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pick := atomic.LoadInt64(&amp;c2.pick)</span><br><span class="line">	<span class="keyword">if</span> start-pick &gt; forcePick &amp;&amp; atomic.CompareAndSwapInt64(&amp;c2.pick, pick, start) &#123;</span><br><span class="line">		<span class="keyword">return</span> c2</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		atomic.StoreInt64(&amp;c1.pick, start)</span><br><span class="line">		<span class="keyword">return</span> c1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Jd0gGjiCVDFbvnXkRc6CHw">企业级 RPC 框架 zRPC</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Percy"
      src="https://ivalue2333.github.io/percy/images/percy.jpg">
  <p class="site-author-name" itemprop="name">Percy</p>
  <div class="site-description" itemprop="description">IOT2014</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">157</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">194</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Percy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
