<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="IOT2014">
<meta property="og:type" content="website">
<meta property="og:title" content="blog | percy">
<meta property="og:url" content="http://example.com/page/11/index.html">
<meta property="og:site_name" content="blog | percy">
<meta property="og:description" content="IOT2014">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Percy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>blog | percy</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blog | percy</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/10/concurrent%20and%20gc/%E5%B9%B6%E5%8F%91%E4%B9%8B%E8%87%AA%E6%97%8B%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/10/concurrent%20and%20gc/%E5%B9%B6%E5%8F%91%E4%B9%8B%E8%87%AA%E6%97%8B%E9%94%81/" class="post-title-link" itemprop="url">【并发】并发基础及锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-10 00:00:00" itemprop="dateCreated datePublished" datetime="2020-06-10T00:00:00+08:00">2020-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1169074">https://cloud.tencent.com/developer/article/1169074</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/06/http/tcp%E4%B9%8Btcp%E7%9A%84%E7%8A%B6%E6%80%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/06/http/tcp%E4%B9%8Btcp%E7%9A%84%E7%8A%B6%E6%80%81/" class="post-title-link" itemprop="url">tcp之tcp的状态</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-06 21:05:19" itemprop="dateCreated datePublished" datetime="2020-06-06T21:05:19+08:00">2020-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="tcp-的状态枚举"><a href="#tcp-的状态枚举" class="headerlink" title="tcp 的状态枚举"></a>tcp 的状态枚举</h2><p>客户端和服务端在建立和使用连接时，tcp的状态值也会随之改变。下表为TCP状态码列表，以S指代服务器，C指代客户端，S&amp;C表示两者，S&#x2F;C表示两者之一。</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>解释</th>
<th>所属端</th>
</tr>
</thead>
<tbody><tr>
<td>LISTEN</td>
<td>服务器等待从任意远程TCP端口的连接请求。侦听状态。</td>
<td>S</td>
</tr>
<tr>
<td>SYN-SENT</td>
<td>客户在发送连接请求后等待匹配的连接请求。通过connect()函数向服务器发出一个同步（SYNC）信号后进入此状态。</td>
<td>C</td>
</tr>
<tr>
<td>SYN-RECEIVED</td>
<td>服务器已经收到并发送同步（SYNC）信号之后等待确认（ACK）请求。</td>
<td>S</td>
</tr>
<tr>
<td>ESTABLISHED</td>
<td>服务器与客户的连接已经打开，收到的数据可以发送给用户。数据传输步骤的正常情况。此时连接两端是平等的。这称作全连接。</td>
<td>S&amp;C</td>
</tr>
<tr>
<td>FIN-WAIT-1</td>
<td>服务器或客户）主动关闭端调用close（）函数发出FIN请求包，表示本方的数据发送全部结束，等待TCP连接另一端的ACK确认包或FIN&amp;ACK请求包。</td>
<td>S&amp;C</td>
</tr>
<tr>
<td>FIN-WAIT-2</td>
<td>主动关闭端在FIN-WAIT-1状态下收到ACK确认包，进入等待远程TCP的连接终止请求的半关闭状态。这时可以接收数据，但不再发送数据。</td>
<td>S&amp;C</td>
</tr>
<tr>
<td>CLOSE-WAIT</td>
<td>被动关闭端接到FIN后，就发出ACK以回应FIN请求，并进入等待本地用户的连接终止请求的半关闭状态。这时可以发送数据，但不再接收数据。</td>
<td>S&amp;C</td>
</tr>
<tr>
<td>LAST-ACK</td>
<td>被动关闭端全部数据发送完成之后，向主动关闭端发送FIN，进入等待确认包的状态。</td>
<td>S&amp;C</td>
</tr>
<tr>
<td>TIME-WAIT</td>
<td>主动关闭端接收到FIN后，就发送ACK包，等待足够时间以确保被动关闭端收到了终止请求的确认包。(<code>按照RFC 793，一个连接可以在TIME-WAIT保证最大四分钟，即[最大分段寿命])（maximum segment lifetime）的2倍</code>)</td>
<td>S&#x2F;C</td>
</tr>
<tr>
<td>CLOSED</td>
<td>完全没有连接。</td>
<td>S&amp;C</td>
</tr>
<tr>
<td>CLOSING</td>
<td>在发出FIN后，又收到对方发来的FIN后，进入等待对方对己方的连接终止（FIN）的确认（ACK）的状态。少见。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="time-wait"><a href="#time-wait" class="headerlink" title="time-wait"></a>time-wait</h2><ul>
<li>TCP 连接建立后，「主动关闭连接」的一端，收到对方的 FIN 请求后，发送 ACK 响应，会处于 time_wait 状态；</li>
<li>time_wait 状态，存在的必要性<ul>
<li>防止具有相同「四元组」的「旧」数据包被收到；<ul>
<li>如上图黄色框框服务端在关闭连接之前发送的 <code>SEQ = 301</code> 报文，被网络延迟了。</li>
<li>这时有相同端口的 TCP 连接被复用后（已经是新的客户端了），被延迟的 <code>SEQ = 301</code> 抵达了客户端，那么客户端是有可能正常接收这个过期的报文，这就会产生数据错乱等严重的问题。</li>
</ul>
</li>
<li>保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭；</li>
</ul>
</li>
</ul>
<h4 id="为什么是-2MSL"><a href="#为什么是-2MSL" class="headerlink" title="为什么是 2MSL"></a>为什么是 2MSL</h4><ul>
<li>第一点是至少要大于 MSL， 让上个连接服务端发出的所有报文都能被处理，这个时间最大是 MSL</li>
<li>然后考虑在 4次挥手中主动方最后一次 ack 报文可能在经过了一个MSL 后没有到达 被动方，然后被动方重发 Fin 报文，这个 Fin 报文的最长时间又是 MSL， 所以至少要等待 2MSL，确保如果被动方重发 Fin 报文，主动方一定可以处理。这还只是挥手的过程，如果挥手和上一次请求的时间非常近，那么这也是能处理所有的上个连接的请求。这其实是相当于<strong>至少允许报文丢失一次</strong>。</li>
</ul>
<p><strong>一个小思路，如果你的服务处理了一个请求后，这个请求对应的连接立刻进入了time-wait状态，那么很显然你的连接是个短连接，因为长连接会等一段时间后才会由服务端主动释放连接。如果你的服务器上看到这个连接很快进入time-wait，那么就是你的服务端发起了关闭连接的挥手会话（这可能是因为你的客户端进程已经退出了，也可能是你的客户端的请求中http 头部 connection 参数，可能设置为 close）。</strong></p>
<p><img src="https://pic2.zhimg.com/v2-5e3336e73d8b924381f347d0ebab1b71_r.jpg"></p>
<h3 id="time-wait的危害"><a href="#time-wait的危害" class="headerlink" title="time-wait的危害"></a>time-wait的危害</h3><ul>
<li>占用连接资源<ul>
<li>TIME_WAIT占用的1分钟时间内，相同四元组(源地址，源端口，目标地址，目标端口)的连接无法创建，通常一个ip可以开启的端口为net.ipv4.ip_local_port_range指定的32768-61000，如果TIME_WAIT状态过多，会导致无法创建新连接。</li>
</ul>
</li>
</ul>
<h3 id="危害的解决方法之一：net-ipv4-tcp-tw-reuse"><a href="#危害的解决方法之一：net-ipv4-tcp-tw-reuse" class="headerlink" title="危害的解决方法之一：net.ipv4.tcp_tw_reuse"></a>危害的解决方法之一：net.ipv4.tcp_tw_reuse</h3><p>将处于TIME_WAIT状态的socket用于新的TCP连接，影响连出的连接。</p>
<p>kernel sysctl 官方指南中是这么写的</p>
<p><code>Allow to reuse TIME-WAIT sockets for new connections when it is safe from protocol viewpoint. Default value is 0.It should not be changed without advice/request of technical experts.</code></p>
<p>条件</p>
<ul>
<li>只适用于客户端(连接发起方)</li>
<li>TIME_WAIT创建时间超过1秒才可以被复用</li>
</ul>
<p>满足以上两个条件才会被认为是”safe from protocol viewpoint”的状况。启用net.ipv4.tcp_tw_reuse后，如果新的时间戳比之前存储的时间戳更大，那么Linux将会从TIME-WAIT状态的存活连接中选取一个，重新分配给新的连接出去的的TCP连接，这种情况下，TIME-WAIT的连接相当于只需要1秒就可以被复用了。</p>
<h3 id="危害的解决办法之二：net-ipv4-tcp-tw-recycl（已不推荐）"><a href="#危害的解决办法之二：net-ipv4-tcp-tw-recycl（已不推荐）" class="headerlink" title="危害的解决办法之二：net.ipv4.tcp_tw_recycl（已不推荐）"></a>危害的解决办法之二：net.ipv4.tcp_tw_recycl（已不推荐）</h3><p>简单来说就是，Linux会丢弃所有来自远端的timestramp时间戳小于上次记录的时间戳(由同一个远端发送的)的任何数据包。也就是说要使用该选项，则必须保证数据包的时间戳是单调递增的。</p>
<p>tcp_tw_recycle 选项在4.10内核之前还只是不适用于NAT&#x2F;LB的情况(其他情况下，我们也非常不推荐开启该选项)，但4.10内核后彻底没有了用武之地，并且在4.12内核中被移除.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">wiki</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qingergege/p/6603488.html">比较详细的讲解，我没怎么看了</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&mid=2651487620&idx=1&sn=13ff9b4943187f890b2a68184122d2e7&chksm=bd2511fb8a5298ed9e1b089e654555a28022c6058088506759ac5805fde09ce513a225623f71&mpshare=1&scene=1&srcid=06010Nn1z5ZtBZMW5FLjYxz0&sharer_sharetime=1590997122672&sharer_shareid=2728d3a0eb6a32c660939921ae4b72ce&key=14e356dd93ee9f3f4866b0f5d91842a01dbc281eca4277b6533506152934637993f66fd367b53220236d3ea3e12ae9f9d0117ee571049040931c9a0921ae76e3376fb7f6a89b63a85afe833d7528f634&ascene=1&uin=MjQ3MzQ1MDUyNQ==&devicetype=Windows+10+x64&version=62090070&lang=zh_CN&exportkey=AzfwsRpPc/zDPykk9RUBptU=&pass_ticket=YQvWTIF+MsWhYHMT3jdobfPbWSmGmW4ICpEieOWcBb+sZMZ1Y3k1VEjQASgUq4f7">启发我思考这个问题的</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5c0642e65188251a82662912">小米time-wait的理解（实际上是翻译）</a></p>
<p><a target="_blank" rel="noopener" href="https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux">小米翻译的原文</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/06/http/http%E4%B9%8Bcookie&&session/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/06/http/http%E4%B9%8Bcookie&&session/" class="post-title-link" itemprop="url">http之cookie&&session</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-06 20:37:37" itemprop="dateCreated datePublished" datetime="2020-06-06T20:37:37+08:00">2020-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-02 10:26:17" itemprop="dateModified" datetime="2021-08-02T10:26:17+08:00">2021-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index"><span itemprop="name">http</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>早期的 Web 应用面临的最大问题之一就是如何维持状态。简言之，服务器无法知道两个请求是否来自于同一个浏览器。当时，最简单的办法就是在请求的页面中插入一个 token，然后在下次请求时将这个 token 返回至服务器。后面就衍生出来cookie。简单地说，cookie 就是浏览器储存在用户电脑上的一小段文本文件。cookie 是纯文本格式，不包含任何可执行的代码。一个 Web 页面或服务器告知浏览器按照一定规范来储存这些信息，并在随后的请求中将这些信息发送至服务器，Web 服务器就可以使用这些信息来识别不同的用户。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="创建cookie"><a href="#创建cookie" class="headerlink" title="创建cookie"></a>创建cookie</h3><p>Web 服务器通过发送一个称为 Set-Cookie 的 HTTP 消息头来创建一个 cookie，Set-Cookie消息头是一个字符串，其格式如下（中括号中的部分是可选的）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]</span><br></pre></td></tr></table></figure>

<p>服务器端框架通常包含解析 cookie 的方法，可以通过编程的方式获取 cookie 的值。</p>
<h3 id="cookie过期时间"><a href="#cookie过期时间" class="headerlink" title="cookie过期时间"></a>cookie过期时间</h3><p>紧跟 cookie 值后面的每个选项都以分号和空格分开，每个选择都指定了 cookie 在什么情况下应该被发送至服务器。第一个选项是过期时间（expires），指定了 cookie 何时不会再被发送至服务器，随后浏览器将删除该 cookie。该选项的值是一个 <code>Wdy, DD-Mon-YYYY HH:MM:SS GMT</code>日期格式的值，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: name=Nicholas; expires=Sat, 02 May 2009 23:38:25 GMT</span><br></pre></td></tr></table></figure>

<p>没有设置 expires 选项时，cookie 的生命周期仅限于当前会话中（<strong>会话cookie</strong>），关闭浏览器意味着这次会话的结束，所以会话 cookie 仅存在于浏览器打开状态之下。这就是为什么为什么当你登录一个 Web 应用时经常会看到一个复选框，询问你是否记住登录信息：如果你勾选了复选框，那么一个 expires 选项会被附加到登录 cookie 中（<strong>持久化cookie</strong>）。如果 expires 设置了一个过去的时间点，那么这个 cookie 会被立即删掉。</p>
<h3 id="secure选项"><a href="#secure选项" class="headerlink" title="secure选项"></a>secure选项</h3><p>最后一个选项是 secure。不像其它选项，该选项只是一个标记而没有值。只有当一个请求通过 SSL 或 HTTPS 创建时，包含 secure 选项的 cookie 才能被发送至服务器。这种 cookie 的内容具有很高的价值，如果以纯文本形式传递很有可能被篡改，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: name=Nicholas; secure</span><br></pre></td></tr></table></figure>

<p>事实上，机密且敏感的信息绝不应该在 cookie 中存储或传输，因为 cookie 的整个机制原本都是不安全的。默认情况下，在 HTTPS 链接上传输的 cookie 都会被自动添加上 secure 选项。</p>
<h3 id="cookie-属性"><a href="#cookie-属性" class="headerlink" title="cookie 属性"></a>cookie 属性</h3><h4 id="expires-属性"><a href="#expires-属性" class="headerlink" title="expires 属性"></a>expires 属性</h4><p>Cookie 的expires 属性指定浏览器可发送Cookie 的有效期。当省略expires 属性时，Cookie仅在浏览器关闭之前有效。<br>另外，一旦Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除Cookie 的方法。但可通过覆盖已过期的Cookie，实现对客户端Cookie 的实质性删除操作。</p>
<h4 id="path-属性"><a href="#path-属性" class="headerlink" title="path 属性"></a>path 属性</h4><p>Cookie 的path 属性可用于限制指定Cookie 的发送范围的文件目录。不过另有办法可避开这项限制，看来对其作为安全机制的效果不能抱有期待。</p>
<h4 id="domain-属性"><a href="#domain-属性" class="headerlink" title="domain 属性"></a>domain 属性</h4><p>通过Cookie 的domain 属性指定的域名可做到与结尾匹配一致。比如， 当指定<a href="http://example.com/">http://example.com</a> 后， 除<a href="http://example.com/">http://example.com</a> 以外，okr.example.com 或 www2.example.com 等都可以发送Cookie。因此，除了针对具体指定的多个域名发送Cookie 之外，不指定domain 属性显得更安全。</p>
<h4 id="secure-属性"><a href="#secure-属性" class="headerlink" title="secure 属性"></a>secure 属性</h4><p>Cookie 的secure 属性用于限制Web 页面仅在HTTPS 安全连接时，才可以发送Cookie。发送Cookie 时，指定secure 属性的方法如下所示。<br>Set-Cookie: name&#x3D;value; secure<br>以上例子仅当在https ：&#x2F;&#x2F;Example Domain（HTTPS）安全连接的情况下才会进行Cookie 的回收。也就是说，即使域名相同时http : &#x2F;&#x2F;Example Domain（HTTP） 也不会发生Cookie 回收行为。当省略secure 属性时，不论HTTP 还是HTTPS，都会对Cookie 进行回收。</p>
<h4 id="HttpOnly-属性"><a href="#HttpOnly-属性" class="headerlink" title="HttpOnly 属性"></a>HttpOnly 属性</h4><p>Cookie 的HttpOnly 属性是Cookie 的扩展功能，它使JavaScript 脚本无法获得Cookie。其主要目的为防止跨站脚本攻击（Cross-sitescripting，XSS）对Cookie 的信息窃取。<br>发送指定HttpOnly 属性的Cookie 的方法如下所示。<br>Set-Cookie: name&#x3D;value; HttpOnly<br>通过上述设置，通常从Web 页面内还可以对Cookie 进行读取操作。但使用JavaScript 的document.cookie 就无法读取附加HttpOnly 属性后的Cookie 的内容了。因此，也就无法在XSS 中利用JavaScript 劫持Cookie 了。<br>虽然是独立的扩展功能，但Internet Explorer 6 SP1 以上版本等当下的主流浏览器都已经支持该扩展了。另外顺带一提，该扩展并非是为了防止XSS 而开发的。</p>
<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>cookie 虽然很方便，但是使用 cookie 有一个很大的弊端，cookie 中的所有数据在客户端就可以被修改，数据非常容易被伪造，那么一些重要的数据就不能存放在 cookie 中了，而且如果 cookie 中数据字段太多会影响传输效率。为了解决这些问题，就产生了 session，session 中的数据是保留在服务器端的。Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p>
<h3 id="session运作"><a href="#session运作" class="headerlink" title="session运作"></a>session运作</h3><p>session 的运作通过一个 session_id 来进行。session_id 通常是存放在客户端的 cookie 中。session可以存放在任何位置，一般是放内存或者缓存中。</p>
<h3 id="session-cookie"><a href="#session-cookie" class="headerlink" title="session-cookie"></a>session-cookie</h3><p>初学者容易犯的一个错误是，忘记了 session_id 在 cookie 中的存储方式是 session cookie。即，当用户一关闭浏览器，浏览器 cookie 中的 session_id 字段就会消失。常见的场景就是在开发用户登陆状态保持时。假如用户在之前登陆了你的网站，你在他对应的 session 中存了信息，当他关闭浏览器再次访问时，你还是不懂他是谁。所以我们要在 cookie 中，也保存一份关于用户身份的信息。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一、基于Session实现会话保持</p>
<p>基于Session实现会话保持的原理是：在会话的开始（即客户端第一次向服务器发送HTTP请求时），服务器会将会话状态保存起来（一般保存在本机内存，当然也可以保存在其他存储系统），然后分配一个会话标识（也叫SessionId）给客户端，这个会话标识一般保存在浏览Cookie里，以后每次浏览器发送HTTP请求的时候，都会带上这个会话标识到服务器，服务器拿到这个会话标识之后就可以把之前存储在服务端的状态信息与该会话联系起来，因此也就实现了会话保持。当然如果遇到浏览器禁用了Cookie的情况，则可以通过url重写的方式将会话标识放在url的参数里，这样也可以实现会话保持。</p>
<p>二、基于Cookie实现会话保持</p>
<p>基于Cookie实现会话保持与上述基于Session实现会话保持的最主要区别是前者完全将会话状态信息存储在浏览器Cookie中，这样一来每次浏览器发送HTTP请求的时候都会带上状态信息，因此也就可以实现状态保持。以上述购物车应用为例，服务端可以将商品信息加密（也可以不加密，但为了安全性，一般会此对状态信息进行加密处理）后保存在浏览器的Cookie中，这样一来服务端就能知道你在浏览的过程中添加了哪些商品到购物车中了。</p>
<p>三、两者的优缺点</p>
<p>基于Session的会话保持的优点是具有安全性，因为状态信息是保存在服务端的，缺点是不便于服务器的水平扩展。大型网站的后台一般都不止一台服务器，可能几台甚至上百台，浏览器发送的HTTP请求一般要先通过负载均衡器才能到达具体的后台服务器，这就会导致每次HTTP请求可能落到不同的服务器上，比如说第一次HTTP请求落到server1上，第二次HTTP请求落到server2上。而Session默认是存储在服务器本机内存的，当多次请求落到不同的服务器上时，上述方案就不能实现会话保持了。</p>
<p>基于Cookie的会话保持的优点是服务器不用保存状态信息，减轻服务端存储压力，也便于服务端做水平扩展。缺点是不够安全，因为状态信息是存储在客户端的，这意味着不能在会话中保存机密数据，另一个缺点是每次HTTP请求都需要发送额外的Cookie到服务端，会消耗更多带宽。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>通过这篇文章，你会知道。</p>
<ul>
<li>cookie 是什么。</li>
<li>cookie 怎么使用</li>
<li>session</li>
<li>session怎么使用</li>
<li>一般来说，都是cookie中存储 session_id&#x3D;”xxx”，请求服务端时，服务端拿到xxx中的信息后，去内存，或者缓存中拿存储的数据，所以不存在说水平扩展的问题，上面人的说法只是在特定的模式下成立。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>看云：<a target="_blank" rel="noopener" href="https://www.kancloud.cn/kancloud/http-cookies-explained%EF%BC%88%E5%85%A8%E6%96%87%E6%91%98%E5%BD%95%EF%BC%89">https://www.kancloud.cn/kancloud/http-cookies-explained（全文摘录）</a></p>
<p>看云：<a target="_blank" rel="noopener" href="https://www.kancloud.cn/codepan/cookie-session">https://www.kancloud.cn/codepan/cookie-session</a></p>
<p>微信：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/y-o87DhpZAvceRruDMF4QA">谈谈http的状态</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/06/http/http%E4%B9%8B%E5%9F%9F%E5%90%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/06/http/http%E4%B9%8B%E5%9F%9F%E5%90%8D/" class="post-title-link" itemprop="url">http之域名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-06 20:37:37" itemprop="dateCreated datePublished" datetime="2020-06-06T20:37:37+08:00">2020-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-23 11:15:09" itemprop="dateModified" datetime="2021-06-23T11:15:09+08:00">2021-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index"><span itemprop="name">http</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="顶级域"><a href="#顶级域" class="headerlink" title="顶级域"></a>顶级域</h2><p><strong>顶级域</strong>（英语：Top-level domains，缩写：TLD）是域名中最高的一级，每个域名都以顶级域结尾。</p>
<p>域名刚被设计出来时，顶级域名主要分成两类：国家及地区双字代码顶级域（国家和地区顶级域）（英语：Country Code Top-level domains，缩写：ccTLD）和通用顶级域（英语：general Top-level domains，缩写：gTLD）</p>
<p>截至2009年10月，已存在21个通用顶级域名和250个国家及地区顶级域名，但它们远远不够互联网的使用。</p>
<h2 id="子域名"><a href="#子域名" class="headerlink" title="子域名"></a>子域名</h2><p>子域名将顶级域名进一步细分。域名层次结构中，顶级域名下面是二级域名，它位于顶级域名的左侧。例如，在zh.wikipedia.org中，wikipedia是二级域名。w3.org中，w3也是二级域名，与前例中的wikipedia属于一个层面。</p>
<p>二级域名下面是三级域名，它位于二级域名的左侧。例如，在zh.wikipedia.org中，zh是三级域名；zh-classical.wikipedia.org（文言文维基大典的域名）中，zh-classical也是三级域名，与前例中的zh属于一个层面。从右侧到左侧，隔一个点依次下降一层。[2]</p>
<p>通常情况下，人们基于公司、产品或服务的名称来创建二级域名或更低级别的域名，以方便其他人识别和记忆。[4]</p>
<p>完整域名的所有字符加起来不得超过253个ASCII字符的总长度。因此，当每一级都使用单个字符时，限制为127个级别：127个字符加上126个点的总长度为253。但实际上，某些域名可能具有其他限制；也没有只有一个字符的域名后缀。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D">wiki</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/06/http/http%E4%B9%8B%E9%95%BF%E8%BF%9E%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/06/http/http%E4%B9%8B%E9%95%BF%E8%BF%9E%E6%8E%A5/" class="post-title-link" itemprop="url">http之长连接</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-06 20:37:37" itemprop="dateCreated datePublished" datetime="2020-06-06T20:37:37+08:00">2020-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index"><span itemprop="name">http</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是长连接"><a href="#什么是长连接" class="headerlink" title="什么是长连接"></a>什么是长连接</h2><p>其实这个问题啊，网上挺多人在说的，感觉都是对的，又感觉差点什么。先来说我可以确定的HTTP&#x2F;1.1协议中，从rfc2616的定义来看，定义了http的连接为<strong>Persistent Connections</strong>，按字面翻译过来就是持久连接了，这其实就是常说的长连接，一个意思。持久连接有什么特性呢，最长说的就是<strong>客户端请求了服务端，当这个请求结束后，他们刚建立的 tcp 连接不会关闭，后面在一定时间内，客户端又来请求这个服务端的时候，复用这个连接，达到减少 tcp 三次握手和 tcp 四次挥手的作用。</strong></p>
<p>持久化连接详细的优点如下</p>
<ul>
<li>通过打开和关闭较少的TCP连接，可以节省CPU时间在路由器和主机（客户端，服务器，代理，网关，隧道或缓存）以及用于TCP协议控制的内存块可以保存在主机中。</li>
<li>HTTP请求和响应可以在连接上通过<strong>管道传递</strong>。流水线允许客户端发出多个请求而无需等待每个响应，从而允许单个TCP连接被使用得效率更高，耗时更少。</li>
<li>通过减少由TCP打开引起的数据包数量，并允许TCP有足够的时间来确定网络的拥塞状态，可以减少网络拥塞。</li>
<li>由于没有时间花费在TCP连接打开握手上，因此减少了后续请求的延迟。</li>
<li>HTTP可以更优雅地发展，因为可以报告错误，而不会关闭TCP连接。 使用将来版本的HTTP的客户端可能会乐观地尝试一项新功能，但是如果与旧服务器进行通信，则在报告错误后使用旧语义重试。</li>
</ul>
<p>再来说个网上通用的说法，就是说http&#x2F;1.0的时候，默认的短连接，短连接就很好理解了，就是一次http的请求和响应结束后就关闭这个连接（<strong>实际的情况可能更复杂，见附录里的time_wait，但是这样理解是可以的</strong>）。然后呢HTTP&#x2F;1.0如果要能使用长连接怎么办呢，在http的请求header中设置一个值<code>Connection: keep-alive</code>，这表示客户端希望使用长连接，然后呢，服务端如果支持长连接的话，也在header中设置这个值<code>Connection: keep-alive</code>。并且，服务器可以同时设置对应的超时时间<code>Keep-Alive: timeout=120</code>，告诉客户端我这个长连接<strong>大概</strong>会保留多久。</p>
<p><strong>所以，基本上说长连接，就是在说持久连接，他们都想达到</strong></p>
<p><strong>短连接很简单，都是客户端主动关闭连接。长连接一般都是服务器主动关闭连接</strong></p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。例如：</p>
<ul>
<li>数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。 </li>
<li>网站的静态文件资源，会对静态文件服务器频繁请求。</li>
</ul>
<p>短连接适用请求不频繁的情况。WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p>
<h2 id="长连接在nginx中的配置项"><a href="#长连接在nginx中的配置项" class="headerlink" title="长连接在nginx中的配置项"></a>长连接在nginx中的配置项</h2><h3 id="keepalive-timeout"><a href="#keepalive-timeout" class="headerlink" title="keepalive_timeout"></a>keepalive_timeout</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">keepalive_timeout</span> timeout [header_timeout];</span><br><span class="line">Default:    <span class="attribute">keepalive_timeout</span> <span class="number">75s</span>;</span><br><span class="line">Context:    http, server, <span class="section">location</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The first parameter sets a timeout during which a keep-alive client connection will stay open on the server side. The zero value disables keep-alive client connections. The optional second parameter sets a value in the “Keep-Alive: timeout=time” response header field. Two parameters may differ</span></span><br></pre></td></tr></table></figure>

<h3 id="keepalive-requests"><a href="#keepalive-requests" class="headerlink" title="keepalive_requests"></a>keepalive_requests</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">keepalive_requests</span> number;</span><br><span class="line">Default:    <span class="attribute">keepalive_requests</span> <span class="number">100</span>;</span><br><span class="line">Context:    http, server, <span class="section">location</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets the maximum number of requests that can be served through one keep-alive connection. After the maximum number of requests are made, the connection is closed</span></span><br></pre></td></tr></table></figure>

<h2 id="长连接带来的问题"><a href="#长连接带来的问题" class="headerlink" title="长连接带来的问题"></a>长连接带来的问题</h2><p>对于非持久连接（短连接），浏览器可以通过连接是否关闭来界定请求或响应实体的边界；而对于持久连接，这种方法显然不奏效。因为尽管服务器端已经发送完所有的数据，但浏览器并不知道这一点，它无法得知这个打开的连接上是否还会有新数据进来，只能一直处于等待状态。</p>
<p><strong>要解决上述的问题，我们需要有一种协商机制，用于服务器端告知客户端，已经完成了数据的传输。</strong>比如我们可以通过返回 http body 的长度来让客户端判断，是否数据已经传输完成了。</p>
<p><strong>HTTP 协议中的 Response Header ： Content-Length 用于标识 Body 的实际长度</strong>。</p>
<h3 id="Content-Length带来的问题"><a href="#Content-Length带来的问题" class="headerlink" title="Content-Length带来的问题"></a>Content-Length带来的问题</h3><p>由于 Content-Length 字段必须真实反映 HTTP Body 的实际长度，但某些场景下，实际长度无法进行计算，例如 HTTP Body 在服务器端动态的生成。这时候要想准确获取长度，只能在内核中开启一个足够大的 buffer ，等内容全部生成好再计算。<strong>但这样做一方面需要更大的内存开销，另一方面也会让客户端等更久</strong>。</p>
<p>我们在做 WEB 性能优化时，有一个重要的指标叫 TTFB（Time To First Byte），它代表的是从客户端发出请求到收到响应的第一个字节所花费的时间。比如 chrome 浏览器的 Network 面板都可以看到每一个 HTTP 请求的 TTFB，越短的 TTFB 意味着用户可以越早看到页面内容，体验越好。</p>
<h4 id="Transfer-Encoding-chunked"><a href="#Transfer-Encoding-chunked" class="headerlink" title="Transfer-Encoding: chunked"></a>Transfer-Encoding: chunked</h4><p>为了解决上述 Content-Length 的相关问题，HTTP 协议定义了一个新的 HTTP Header ： Transfer-Encoding ，其中 chunked 表示：分块编码。</p>
<p>分块编码的规则是，报文中的实体需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的 CRLF（\r\n），也不包括分块数据结尾的 CRLF 。最后一个分块长度值必须为 0，对应的分块数据没有内容，表示实体结束。</p>
<p>参考代码如下（这个人实际上是在tcp协议的基础上，自己实现了一个非常简单的http协议，并启动了服务）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>).<span class="title function_">createServer</span>(<span class="keyword">function</span>(<span class="params">sock</span>) &#123;</span><br><span class="line">    sock.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">        sock.<span class="title function_">write</span>(<span class="string">&#x27;HTTP/1.1 200 OK\r\n&#x27;</span>);</span><br><span class="line">        sock.<span class="title function_">write</span>(<span class="string">&#x27;Transfer-Encoding: chunked\r\n&#x27;</span>);</span><br><span class="line">        sock.<span class="title function_">write</span>(<span class="string">&#x27;\r\n&#x27;</span>);</span><br><span class="line">        <span class="comment">// b 是十六进制，十进制为11，恰好为&quot;01234567890&quot;的长度。</span></span><br><span class="line">        sock.<span class="title function_">write</span>(<span class="string">&#x27;b\r\n&#x27;</span>);</span><br><span class="line">        sock.<span class="title function_">write</span>(<span class="string">&#x27;01234567890\r\n&#x27;</span>);</span><br><span class="line">        <span class="comment">// 同上的规则</span></span><br><span class="line">        sock.<span class="title function_">write</span>(<span class="string">&#x27;5\r\n&#x27;</span>);</span><br><span class="line">        sock.<span class="title function_">write</span>(<span class="string">&#x27;12345\r\n&#x27;</span>);</span><br><span class="line">        <span class="comment">// 最后一个 0 长度的分块，表示数据已经被传输完</span></span><br><span class="line">        sock.<span class="title function_">write</span>(<span class="string">&#x27;0\r\n&#x27;</span>);</span><br><span class="line">        sock.<span class="title function_">write</span>(<span class="string">&#x27;\r\n&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">9090</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="TCP的keepAlive"><a href="#TCP的keepAlive" class="headerlink" title="TCP的keepAlive"></a>TCP的keepAlive</h2><p>很明显的是，http的长连接，依赖的是tcp的长连接，而tcp对长连接做了更细节的设计。</p>
<p>连接建立之后，如果客户端一直不发送数据，或者隔很长时间才发送一次数据，当连接很久没有数据报文传输时如何去确定对方还在线，到底是掉线了还是确实没有数据传输，<strong>连接还需不需要保持，这种情况在TCP协议设计中是需要考虑到的</strong>。 </p>
<p>TCP协议通过一种巧妙的方式去解决这个问题，当超过一段时间之后，TCP自动发送一个数据为空的报文（侦测包）给对方，如果对方回应了这个报文，说明对方还在线，连接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持连接。</p>
<p>tcp keep-alive是TCP的一种检测TCP连接状况的保鲜机制。tcp keep-alive保鲜定时器，支持三个系统内核配置参数： </p>
<ul>
<li>net.ipv4.tcp_keepalive_intvl &#x3D; 15 </li>
<li>net.ipv4.tcp_keepalive_probes &#x3D; 5 </li>
<li>net.ipv4.tcp_keepalive_time &#x3D; 1800</li>
</ul>
<p>keepalive是TCP保鲜定时器，当网络两端建立了TCP连接之后，闲置（双方没有任何数据流发送往来）了tcp_keepalive_time后，服务器就会尝试向客户端发送侦测包，来判断TCP连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在 tcp_keepalive_intvl后再次尝试发送侦测包，直到收到对方的ack,如果一直没有收到对方的ack,一共会尝试 tcp_keepalive_probes次，每次的间隔时间在这里分别是15s, 30s, 45s, 60s, 75s。如果尝试tcp_keepalive_probes,依然没有收到对方的ack包，则会丢弃该TCP连接。TCP连接默认闲置时间是2小时，一般设置为30分钟足够了。</p>
<p><strong>例如客户端本来说好是长连接的，但是客户端发起请求后，客户端进程就退出了，那么这个时候服务端再来使用这个保鲜定时器发送一个数据为空的tcp报文，这个时候客户端已经退出，那么服务器也会主动退出，被产生一定量的time-wait状态的tcp连接。</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>互联网工程任务组：<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2616#section-8.1">https://tools.ietf.org/html/rfc2616#section-8.1</a></p>
<p>wiki：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HTTP%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5">https://zh.wikipedia.org/wiki/HTTP%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5</a></p>
<p>CSDN：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_37672169/article/details/80283935">https://blog.csdn.net/weixin_37672169/article/details/80283935</a></p>
<p>长连接带来的问题：<a target="_blank" rel="noopener" href="https://www.zhuxiaodong.net/2018/tcp-http-keepalive/">https://www.zhuxiaodong.net/2018/tcp-http-keepalive/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/05/translation/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91%E5%9F%BA%E4%BA%8E%E5%A0%86%E6%A0%88(stack)%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/05/translation/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91%E5%9F%BA%E4%BA%8E%E5%A0%86%E6%A0%88(stack)%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" class="post-title-link" itemprop="url">【翻译】基于栈(stack)的内存分配</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-05 09:40:39" itemprop="dateCreated datePublished" datetime="2020-06-05T09:40:39+08:00">2020-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>译者注：国内很多人对这两个词语的翻译总是让人糊涂的，这里译者统一做如下翻译，stack统一翻译为栈，而heap统一翻译为堆。</code></p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>计算体系结构中的栈是内存的区域，在其中以后进先出（LIFO）的方式添加或删除数据。</p>
<p>在大多数现代计算机系统中，<strong>每个线程都有一个保留的内存区域</strong>，称为其栈。 当函数执行时，它可能会将一些状态数据添加到栈的顶部； 当函数退出时，它负责从栈中删除该数据。 至少，线程的栈用于存储函数调用的位置，以允许return语句返回到正确的位置，但是程序员可以进一步选择显式使用栈。 如果内存区域位于线程的栈上，则表示该内存已分配在栈上，即基于栈的内存分配。</p>
<p>stack会有以下信息</p>
<ul>
<li>局部变量</li>
<li>函数参数</li>
<li>返回地址</li>
</ul>
<p>由于以后进先出的方式添加和删除数据，因此基于栈的内存分配非常简单，并且通常比基于堆的内存分配（也称为动态内存分配）快。 另一个功能是，当函数退出时，栈上的内存会自动高效地回收，如果不再需要数据，这对程序员来说很方便。（如果longjmp移到了调用alloca之前的某个点，同样适用于longjmp。）但是，如果数据需要以某种形式保存，则必须在函数退出之前从栈中复制数据。 因此，基于栈的分配适用于临时数据或在创建函数退出后不再需要的数据。</p>
<p>在某些小型CPU上，线程分配的栈大小可能只有几个字节。 在栈上分配的内存多于可用内存，可能会由于栈溢出而导致崩溃。 这也是为什么通常使用alloca的函数被禁止进行内联的原因：如果将这样的函数(<code>译者注：指使用了alloca的函数</code>)内联到循环中，则调用方将遭受栈使用率意外增长的困扰，从而更有可能发生溢出（<code>译者注:stack overflow，栈溢出</code>）。</p>
<p>基于栈的分配可能还会导致较小的性能问题：它导致可变大小的栈帧，因此需要管理栈指针和帧指针（对于固定大小的栈帧，其中之一是冗余的）。 通常，这至少比调用malloc和free便宜得多（<code>译者注:这里是说基于stack的内存分配比使用malloc和free在堆上的内存分配便宜很多</code>）。</p>
<h2 id="操作的系统接口"><a href="#操作的系统接口" class="headerlink" title="操作的系统接口"></a>操作的系统接口</h2><p>许多类似Unix的系统以及Microsoft Windows都实现了一个称为<strong>alloca</strong>的功能，该功能以类似于基于堆的malloc的方式<strong>动态分配堆内存</strong>。 编译器通常将其转换为处理堆指针的内联指令，类似于如何处理可变长度数组。尽管不需要显式释放内存，但由于堆溢出，存在未定义行为的风险。 该功能早在Unix系统上就已存在于32 &#x2F; V（1978），但它不是标准C或任何POSIX标准的一部分。</p>
<p>原文地址：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Stack-based_memory_allocation">https://en.wikipedia.org/wiki/Stack-based_memory_allocation</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/04/translation/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91stack%E5%92%8Cheap%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/04/translation/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91stack%E5%92%8Cheap%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">【翻译】stack和heap的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-04 20:25:47" itemprop="dateCreated datePublished" datetime="2020-06-04T20:25:47+08:00">2020-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Stack-and-a-Heap"><a href="#Stack-and-a-Heap" class="headerlink" title="Stack and a Heap ?"></a>Stack and a Heap ?</h2><p><code>译者注：国内很多人对这两个词语的翻译总是让人糊涂的，这里译者统一做如下翻译，stack统一翻译为栈，而heap统一翻译为堆。</code></p>
<p>栈用于存储静态内存，堆用于动态内存分配，两者均存储在计算机的RAM中。</p>
<p>分配在栈上的变量直接存储到内存中，对该内存的访问也非常快，并且在程序编译时会处理它的分配。 当一个函数或方法调用另一个函数，然后又调用另一个函数等时，所有这些函数的执行将保持挂起状态，直到最后一个函数返回其值为止。 栈始终按LIFO顺序保留，最近保留的块始终是要释放的下一个块。 这使得跟踪栈真的非常简单，从栈中释放一个块只不过是调整一个指针而已（移动栈顶指针）。</p>
<p>在堆上分配的变量在运行时分配了内存，访问该内存的速度稍慢，但是堆大小仅受虚拟内存大小的限制。 堆的元素彼此之间没有依赖关系，并且始终可以随时随地进行随机访问。 您可以随时分配一个块，并随时释放它。 这使跟踪在任何给定时间分配或释放堆的哪些部分变得更加复杂。</p>
<p><img src="https://xdmp-new.oss-cn-hangzhou.aliyuncs.com/answer_pics/c322460e0bec484a94ff932f729c3dd0.png"></p>
<p>如果您确切知道在编译之前需要分配多少数据并且它不会太大，则可以使用栈。 如果您不知道运行时将需要多少数据，或者您知道需要分配大量数据，则可以使用堆。</p>
<p>在多线程情况下，每个线程将拥有其自己的完全独立的栈，但它们将共享堆。 栈是特定于线程的（<code>译者注：这里译者理解为线程私有</code>），而堆是特定于应用程序的（<code>译者注：这里译者理解为进程私有</code>）。 在异常处理和线程执行中，必须考虑栈。</p>
<p>原文链接：<a target="_blank" rel="noopener" href="http://net-informations.com/faq/net/stack-heap.htm">http://net-informations.com/faq/net/stack-heap.htm</a></p>
<h2 id="扩展内存分配的类型"><a href="#扩展内存分配的类型" class="headerlink" title="扩展内存分配的类型"></a>扩展内存分配的类型</h2><h3 id="静态内存分配"><a href="#静态内存分配" class="headerlink" title="静态内存分配"></a>静态内存分配</h3><p>静态分配是指在程序启动时分配变量的内存。 创建程序时大小是固定的。 它适用于全局变量，文件范围变量以及在内部函数中定义为静态的合格变量。</p>
<p>分配位置：数据段（data segment），BSS段</p>
<p>生命周期：整个程序的声明周期</p>
<h4 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h4><p>说静态内存是在编译时分配的，这有点令人困惑，尤其是如果我们开始考虑编译机和主机可能不相同，甚至可能不在同一体系结构上时。</p>
<p><strong>最好认为静态内存的分配是由编译器处理的，而不是在编译时进行分配</strong>。</p>
<p>例如，编译器可能会在已编译的二进制文件中创建一个较大的<strong>数据段（data segment）</strong>，并且当程序加载到内存中时，程序数据段内的地址将用作分配内存的位置。这具有明显的缺点，如果使用大量静态内存，则使已编译的二进制文件非常大。可以编写由不到六行代码生成的数千兆字节的二进制文件。<strong>编译器的另一种选择是在执行程序之前注入分配内存的初始化代码。该代码将根据目标平台和操作系统而有所不同。</strong>实际上，现代编译器使用启发式方法来决定使用这些选项中的哪个。您可以编写一个小的C程序来自己尝试一下，该程序为10k，1m，10m，100m，1G或10G项分配一个大型静态数组。对于许多编译器，二进制大小将随着数组的大小线性增长，并且超过一定点后，由于编译器使用另一种分配策略，二进制大小将再次缩小。</p>
<h3 id="自动内存分配"><a href="#自动内存分配" class="headerlink" title="自动内存分配"></a>自动内存分配</h3><p>自动内存分配发生在函数内部定义的（非静态）变量上，并且通常存储在栈中（尽管C标准并不要求使用栈）。 使用这些变量时，您不必保留额外的内存，但是，另一方面，对这些内存的生存期的控制也很有限。 例如：函数中的自动变量仅在函数完成之前存在。</p>
<p>分配位置：栈</p>
<p>生命周期：scope</p>
<h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><p>动态内存分配有些不同。 现在，您可以控制这些内存位置的确切大小和生存期。 如果不释放它，则会遇到内存泄漏，这可能会导致您的应用程序崩溃，因为在某些时候，系统无法分配更多的内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>* mem = <span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* mem = func(); <span class="comment">/* still accessible */</span></span><br></pre></td></tr></table></figure>

<p>在上例中，即使函数终止，分配的内存仍然有效且可访问。 内存用完后，您必须释放它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(mem);</span><br></pre></td></tr></table></figure>

<p>分配位置：堆， 栈</p>
<p>生命周期：主动释放</p>
<p>参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/8385322/difference-between-static-memory-allocation-and-dynamic-memory-allocation">https://stackoverflow.com/questions/8385322/difference-between-static-memory-allocation-and-dynamic-memory-allocation</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/03/learn/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/03/learn/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">压力测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-03 19:42:18" itemprop="dateCreated datePublished" datetime="2020-06-03T19:42:18+08:00">2020-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-07 16:08:32" itemprop="dateModified" datetime="2021-06-07T16:08:32+08:00">2021-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="压测背景"><a href="#压测背景" class="headerlink" title="压测背景"></a>压测背景</h2><p>测试分很多种，网上很多文章[1]会玩弄概念，搬出来3个名词：压力测试（Stress Testing）、性能测试（Performance Testing）、负载测试（Load Testing）。一般情况下并不需要做这么细粒度的概念区分，这3个概念我觉得是没办法完整区分各自边界的，至少在程序逻辑上难以做得到，更多差异只是来自于不同的压测策略，所以尽管忽略这几个概念的区别，都叫它压测或者性能测试即可。</p>
<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>全链路压测方案：一方面可让链路的各个系统知道自己的承压极限；另一方面可让各个系统有个明确的优化目标，了解到整个链路的瓶颈并评估资源情况。</p>
<h2 id="压测指标"><a href="#压测指标" class="headerlink" title="压测指标"></a>压测指标</h2><p>列举一些常用指标，并不一定都需要关注，根据业务考虑指标的细化粒度。</p>
<ul>
<li>QPS：Query Per Second，每秒处理的请求个数</li>
<li>TPS：Transactions Per Second，每秒处理的事务数，TPS &lt;&#x3D; QPS</li>
<li>RT： Response Time，响应时间，等价于Latency RT分平均延时，Pct延时（Percentile分位数）。平均值不能反映服务真实响应延时，实际压测中一般参考Pct90，Pct99等指标</li>
<li>CPU使用率：出于节点宕机后负载均衡的考虑，一般 CPU使用率 &lt; 75% 比较合适</li>
<li>内存使用率：内存占用情况，一般观察内存是否有尖刺或泄露</li>
<li>Load指标：CPU的负载，不是指CPU的使用率，而是在一段时间内CPU正在处理以及等待CPU处理的进程数之和的统计信息，表示CPU的负载情况，一般情况下 Load &lt; CPU的核数*2，更多参考<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html">链接1</a>和<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/02825a66e46f">链接2</a></li>
<li>缓存命中率：多少流量能命中缓存层（redis、memcached等）</li>
<li>数据库耗时：数据库就是业务的生命，很多时候业务崩掉是因为数据库挂了</li>
<li>网络带宽：带宽是否瓶颈</li>
<li>接口响应错误率 or 错误日志量</li>
</ul>
<h2 id="平均值和分位值"><a href="#平均值和分位值" class="headerlink" title="平均值和分位值"></a>平均值和分位值</h2><p>性能测试中，平均值的作用是十分有限的，平均值代表前后各有50%的量，对于一个敏感的性能指标，我们取平均值到底意味着什么？是让50%的用户对响应时间happy，但是50%的用户感知到响应延迟？还是说50%的时间系统能保证稳定，而50%的时间系统则是一个不可控状态？<strong>平均值只是一个特殊的分位值，而且这个分位值在这里意义不大。</strong></p>
<p>所以就有了 tp99, pct延迟等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/03/learn/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/03/learn/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" class="post-title-link" itemprop="url">字符编码与显示</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-03 19:42:18" itemprop="dateCreated datePublished" datetime="2020-06-03T19:42:18+08:00">2020-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><p>各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。 也就是说，它是一个信息单位，一个数字是一个字符，一个文字是一个字符，一个标点符号也是一个字符。</p>
<h3 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h3><p>字节是一个8bit的存储单元，取值范围是0x00~0xFF。 根据字符编码的不同，一个字符可以是单个字节的，也可以是多个字节的。</p>
<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>字符的集合就叫字符集。不同集合支持的字符范围自然也不一样，譬如ASCII只支持英文，GB18030支持中文等等</p>
<p>在字符集中，有一个<strong>码表</strong>的存在，每一个字符在各自的字符集中对应着一个唯一的码。但是同一个字符在不同字符集中的码是不一样的，譬如字符“中”在Unicode和GB18030中就分别对应着不同的码(<code>20013</code>与<code>54992</code>)。</p>
<h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>定义字符集中的字符如何编码为特定的二进制数，以便在计算机中存储。 字符集和字符编码一般一一对应(有例外)</p>
<p>譬如GB18030既可以代表字符集，也可以代表对应的字符编码，它为了兼容<code>ASCII码</code>，编码方式为code大于<code>255</code>的采用两位字节(或4字节)来代表一个字符，否则就是兼容模式，一个字节代表一个字符。(简单一点理解，将它认为是现在用的的中文编码就行了)</p>
<p>字符集与字符编码的一个例外就是Unicode字符集，它有多种编码实现(UTF-8,UTF-16,UTF-32等)</p>
<h2 id="字符集与字符编码的快速区分"><a href="#字符集与字符编码的快速区分" class="headerlink" title="字符集与字符编码的快速区分"></a>字符集与字符编码的快速区分</h2><ul>
<li>ASCII码是一个字符集，同时它的实现也只有一种，因此它也可以指代这个字符集对应的字符编码</li>
<li>GB18030是一个字符集，主要是中国人为了解决中文而发明制定的，由于它的实现也只有一种，所以它也可以指代这个字符集对应的字符编码</li>
<li>Unicode是一个字符集，为了解决不同字符集码表不一致而推出的，统一了所有字符对应的码，因此在这个规范下，所有字符对应的码都是一致的(统一码)，但是统一码只规定了字符与码表的一一对应关系，却没有规定该如何实现，因此这个字符集有多种实现方式(UTF-8,UTF-18,UTF-32)，因此这些实现就是对应的字符编码。 也就是说，Unicode统一约定了字符与码表直接一一对应的关系，而UTF-8是Unicode字符集的一种字符编码实现方式，它规定了字符该如何编码成二进制，存储在计算机中。</li>
</ul>
<h2 id="不同字符编码的字符是如何进行转换的"><a href="#不同字符编码的字符是如何进行转换的" class="headerlink" title="不同字符编码的字符是如何进行转换的"></a>不同字符编码的字符是如何进行转换的</h2><ul>
<li>如果是相同字符集，由于相同字符集中的码都是一样的，所以只需要针对不同的编码方式转变而已。譬如UTF-16转UTF-8，首先会取到当前需要转换的字符的Unicode码，然后将当前的编码方式由双字节(有4字节的拓展就不赘述了)，变为变长的1，2，3等字节</li>
<li>如果是不同的字符集，由于不同字符集的码是不一样的，所以需要各自的码表才能进行转换。譬如UTF-16转GBK，首先需要取到当前需要转换的字符的Unicode码，然后根据Unicode和GBK码表一一对应的关系(只有部分共同都有的字符才能在码表中查到)，找到它对应的GBK码，然后用GBK的编码方式(双字节)进行编码</li>
</ul>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><ul>
<li>Unicode：万国码，通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为0就可以</li>
<li>UTF-8：本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间。</li>
<li>对于一个操作系统或一个程序软件来说，其内部一般固定使用一种编码，如Java程序使用Unicode 字符集 UTF-16 BE 字符编码，在涉及到输入输出时就会存在一个编码转换问题，如读取文件，文件是以二进制的形式存在于硬盘上的，如何读取，必须假定一种字符编码来读取，如假定为GB2312编码，<strong>Java就会以GB2312编码的形式开始读取这个文件，转换为Java内部的编码形式 UTF-16 BE。所以并不是需要扫描多少遍，而是只需要在设计输入输出的时候转换一遍即可。</strong>读取到内存中的必然是系统内部使用的编码，想要显示这些文本，只需要根据编码换算出字符编号，然后调用字体文件信息即可。<ul>
<li>golang内部的编码形式UTF-8。python：比Unicode早出现，所以python计算机内存中最早只支持ASCII码。</li>
</ul>
</li>
</ul>
<h2 id="如何显示字符"><a href="#如何显示字符" class="headerlink" title="如何显示字符"></a>如何显示字符</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>问：我知道ascii码2c 是“，”逗号，但是计算机是怎么知道它是“逗号”的？</p>
<p><strong>简答：有时候不是会安装字体font么，里面就有对应的字型。要显卡渲染形成的。</strong><br>大体过程是：字符编码（Unicode）→字体的形索引（Glyph ID）→字形轮廓→点阵图字形</p>
<h3 id="屏幕是如何显示的"><a href="#屏幕是如何显示的" class="headerlink" title="屏幕是如何显示的"></a>屏幕是如何显示的</h3><p>可以简单理解屏幕是由极多个像素点组成的，并简单理解一个像素点是由一个<strong>发光二极管</strong>来显示的。那么问题就回到了如何控制一个发光二极管的亮暗。作为上层应用，实际上不用太关心如何控制像素点的亮暗，因为这是由显示<strong>驱动电路</strong>来控制。而显示驱动电路的控制是由<strong>显示适配器（显卡）</strong>控制。</p>
<p>显卡的职能是将要显示的图形或文本转换成可以驱动显示器的电信号，它有三个重要的组成部分：</p>
<ul>
<li>显存：存储即将显示的数据，程序员将要显示的字符或图片送到缓存，后面的就是GPU和外围电路的工作了。</li>
<li>显卡BIOS</li>
<li>GPU</li>
</ul>
<h4 id="字符显示"><a href="#字符显示" class="headerlink" title="字符显示"></a>字符显示</h4><p>图形操作系统使用自己的字符呈现引擎（rendering engine），可以支持多个不同的字符集编码，这类代码页被称作ANSI代码页。</p>
<h5 id="TrueType字体-及-FreeType软件开发库"><a href="#TrueType字体-及-FreeType软件开发库" class="headerlink" title="TrueType字体 及 FreeType软件开发库"></a>TrueType字体 及 FreeType软件开发库</h5><p><strong>TrueType字体</strong>不采用像素或其他不可缩放的方式来定义，而是一些通过数学公式(曲线的组合)。这些字形，类似于矢量图像，可以根据你需要的字体大小来生成像素图像。通过使用TrueType字体可以轻易呈现不同大小的字符符号并且没有任何质量损失。</p>
<p>FreeType是一个能够用于加载字体并将他们渲染到位图以及提供多种字体相关的操作的软件开发库。<strong>FreeType的真正吸引力在于它能够加载TrueType字体</strong>。</p>
<p>那么字体是怎么被渲染的呢？从根本上来说，（除掉点阵字体）都是一些矢量图的集合。渲染字体，只是把矢量图画出来而已——说的轻松！</p>
<h5 id="代码页CodePage"><a href="#代码页CodePage" class="headerlink" title="代码页CodePage"></a>代码页CodePage</h5><p>代码页是字符编码的别名，也称内码表，是特定语言的字符集的一张表。</p>
<h5 id="内码"><a href="#内码" class="headerlink" title="内码"></a>内码</h5><p>在计算机科学及相关领域当中，内码指的是“将信息编码后，透过某种方式存储在特定记忆设备时，设备内部的编码形式”。在不同的系统中，会有不同的内码。</p>
<p>在以往的英文系统中，内码为ASCII。 在繁体中文系统中，目前常用的内码为大五码。<strong>在简体中文系统中，内码则为国标码。</strong></p>
<h5 id="字符显示-1"><a href="#字符显示-1" class="headerlink" title="字符显示"></a>字符显示</h5><p>首先是经过字符编解码，将硬盘中存储的有对应编码的文本文件进行加载，例如Java的文件IO，变成内存中的字符串对象，也就是符合本语言字符串存储特性的数据，（当然如果你愿意，也可以当做二进制读入，然后再手段转换编码，也是可以的），绘制时则首先调用对应的CodePage进行编码的索引查找，找到对应的字体字形索引，然后根据字形索引获取到字库中的数据，<strong>根据系统提供的绘制曲线绘制样条线的方法进行图形渲染，这样就能得到显示器上的图像了， 这里其实就是图形渲染。</strong></p>
<h4 id="图像的显示"><a href="#图像的显示" class="headerlink" title="图像的显示"></a>图像的显示</h4><p>例如照片，图片的每一个像素都可以理解成为三种不同颜色的组合。你只需要将每一个像素的RGB值送入显存，GPU会负责将其转换成电信号并输出给显示器。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>字符集：<a target="_blank" rel="noopener" href="https://dailc.github.io/2017/05/03/char_charset_charEncoding.html">https://dailc.github.io/2017/05/03/char_charset_charEncoding.html</a></p>
<p>知乎：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/296297701/answer/565941564">https://www.zhihu.com/question/296297701/answer/565941564</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24340504">https://www.zhihu.com/question/24340504</a></p>
<p>how character display on screen：<a target="_blank" rel="noopener" href="https://www.mmmmmcclxxvii.cn/2015/11/12/how-character-display-on-screen/">https://www.mmmmmcclxxvii.cn/2015/11/12/how-character-display-on-screen/</a></p>
<p>wiki：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/">https://zh.wikipedia.org/wiki/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/13/distribute/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8Bdocker%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/13/distribute/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8Bdocker%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/" class="post-title-link" itemprop="url">虚拟化之docker使用文档</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-13 18:13:22" itemprop="dateCreated datePublished" datetime="2020-05-13T18:13:22+08:00">2020-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">虚拟化</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="docker-是什么"><a href="#docker-是什么" class="headerlink" title="docker 是什么"></a>docker 是什么</h2><ul>
<li>docker 是一个基于镜像的应用容器引擎，它用于管理应用。</li>
<li>如虚拟操作系统一般，docker虚拟了进程，将程序运行环境和操作系统剥离。虚拟操作系统的虚拟是在硬件上，docker的虚拟是相当于在操作系统上多了一层。</li>
<li>有很多可以类比的，如JVM隔离了java程序和操作系统，实现了跨平台。又例如python的虚拟环境将程序执行环境和系统环境剥离。</li>
</ul>
<h2 id="docker优点"><a href="#docker优点" class="headerlink" title="docker优点"></a>docker优点</h2><p>docker 解决的问题就是程序运行的环境问题，镜像一次创建，到处运行（因为有内核支持）</p>
<ul>
<li>并且极高的启动速度。</li>
<li>和虚拟机相比，占用极少的io，磁盘资源。</li>
</ul>
<h2 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h2><h3 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h3><p>Sandboxie(又叫沙箱、沙盘)即是一个虚拟系统程序，允许你在沙盘环境中运行浏览器或其他程序，因此运行所产生的变化可以随后删除。它创造了一个类似沙盒的独立作业环境，在其内部运行的程序并不能对硬盘产生永久性的影响。其为一个独立的虚拟环境，可以用来测试不受信任的应用程序或上网行为。</p>
<p>例如：GreenBorder为IE和firefox构建了一个安全的虚拟执行环境。用户通过浏览器所作的任何写磁盘操作，都将重定向到一个特定的临时文件夹中。这样，即使网页中包含病毒，木马，广告等恶意程序，被强行安装后，也只是安装到了临时文件夹中，不会对用户pc造成危害。（这里的临时文件夹就是一个沙箱）。</p>
<h3 id="LXC"><a href="#LXC" class="headerlink" title="LXC"></a>LXC</h3><p>Linux容器是与系统其他部分隔离开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。镜像包含了容器应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。</p>
<p>和虚拟化的区别</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.redhat.com/zh/topics/virtualization">虚拟化</a>使得许多操作系统可同时在单个系统上运行。</li>
<li>容器则可共享同一个操作系统内核，将应用进程与系统其他部分隔离开。</li>
</ul>
<h2 id="docker使用"><a href="#docker使用" class="headerlink" title="docker使用"></a>docker使用</h2><p>Docker使用客户端-服务器(C&#x2F;S)架构模式，使用远程API来管理和创建Docker容器。 Docker容器通过 Docker镜像来创建。容器（对象）与镜像（类）的关系类似于面向对象编程中的对象与类.。</p>
<p>Docker采用C&#x2F;S架构 Docker daemon 作为服务端接受来自客户的请求，并处理这些请求（创建、运行、分发容器）。客户端和服务端既可以运行在一个机器上，也可通过socket 或者RESTful API 来进行通信。Docker daemon 一般在宿主主机后台运行，等待接收来自客户端的消息。Docker客户端则为用户提供一系列可执行命令，用户用这些命令实现跟Docker daemon 交互。</p>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile一般包含下面几个部分：</p>
<ul>
<li>基础镜像：以哪个镜像作为基础进行制作，用法是FROM 基础镜像名称</li>
<li>维护者信息：需要写下该Dockerfile编写人的姓名或邮箱，用法是MANITAINER 名字&#x2F;邮箱</li>
<li>镜像操作命令：对基础镜像要进行的改造命令，比如安装新的软件，进行哪些特殊配置等，常见的是RUN 命令</li>
<li>容器启动命令：当基于该镜像的容器启动时需要执行哪些命令，常见的是CMD 命令或ENTRYPOINT</li>
</ul>
<h3 id="编写-Dockerfile-常用指令"><a href="#编写-Dockerfile-常用指令" class="headerlink" title="编写 Dockerfile 常用指令"></a>编写 Dockerfile 常用指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定容器运行的用户</span></span><br><span class="line">USER percy	</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定后续命令的执行目录</span></span><br><span class="line">WORKDIR /var/www/django</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置环境变量</span></span><br><span class="line">ENV命令能够对容器内的环境变量进行设置</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增加文件，COPY, ADD， add 会解包</span></span><br><span class="line">ADD html.tar /var/www</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">from</span></span><br><span class="line">FROM指定基础镜像，是Dockerfile中必备指令，且必须放在第一个，镜像可指定为scratch，表示不以任何镜像为基础</span><br></pre></td></tr></table></figure>

<h3 id="Dockerfile-golang代码示例"><a href="#Dockerfile-golang代码示例" class="headerlink" title="Dockerfile golang代码示例"></a>Dockerfile golang代码示例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM registry.cn-zhangjiakou.aliyuncs.com/xiaoduoai/golang:1.13-pulsar2.41</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只需要将二进制文件放进镜像即可</span></span><br><span class="line">ADD ./go-mod ./</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">容器启动的的指令</span></span><br><span class="line">CMD [&quot;./go-mod&quot;, &quot;-path&quot;, &quot;/etc/config/go-mod.toml&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="docker指令"><a href="#docker指令" class="headerlink" title="docker指令"></a>docker指令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker --help</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清除不用的镜像和缓存</span></span><br><span class="line">docker system prune </span><br></pre></td></tr></table></figure>

<h3 id="镜像指令"><a href="#镜像指令" class="headerlink" title="镜像指令"></a>镜像指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从Dockerfile创建镜像</span></span><br><span class="line">docker build -t $&#123;repository&#125;:$&#123;tag&#125; -f Dockerfile basedir</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登陆</span></span><br><span class="line">docker login -u 用户名 -p 密码</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">镜像推拉</span></span><br><span class="line">docker pull ubuntu:12.04</span><br><span class="line">docker push $&#123;repository&#125;:$&#123;tag&#125;</span><br></pre></td></tr></table></figure>

<h3 id="容器指令"><a href="#容器指令" class="headerlink" title="容器指令"></a>容器指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建容器</span></span><br><span class="line">docker run -d --name container-name -p 0.0.0.0:9988:9977 repository:tag</span><br><span class="line">-d: 后台运行，如果需要到后台看看的，需要指定</span><br><span class="line">-it：交互式的</span><br><span class="line">-p: 端口映射：宿主机端口9988映射到容器端口9977</span><br><span class="line">-v: 目录映射, 例如`-v /var/log/xiaoduo:/var/log/xiaoduo`， 前面是宿主机的路径</span><br><span class="line">-w: 指定容器的工作路径， 例如 `-w /app`</span><br><span class="line">--net: 指定容器的网络模式</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基本遵循规则是从宿主机映射到容器，默认是tcp，如果使用udp，比如5600，要记得在运行时或者yaml文件端口处比如写：5000/udp， 使用HOST:CONTAINER格式或者只是指定容器的端口，宿主机会随机映射端口。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止容器</span></span><br><span class="line">docker stop container_id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除容器</span></span><br><span class="line">docker rm container_id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 从主机复制到容器</span></span></span><br><span class="line">sudo docker cp host_path containerID:container_path</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 从容器复制到主机</span></span></span><br><span class="line">sudo docker cp containerID:container_path host_path</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">logs</span></span><br><span class="line">docker logs -f --tail=20 configure-tb</span><br></pre></td></tr></table></figure>

<h4 id="启动-redis-容器"><a href="#启动-redis-容器" class="headerlink" title="启动 redis 容器"></a>启动 redis 容器</h4><h5 id="基本启动方式"><a href="#基本启动方式" class="headerlink" title="基本启动方式"></a>基本启动方式</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">镜像: redis:5.0.5。 或者国内镜像副本： daocloud.io/library/redis:latest</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地 6379 可能被占用了</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭</span></span><br><span class="line">docker stop myredis</span><br><span class="line">docker rm -f myredis</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接启动</span></span><br><span class="line">docker run -d --name myredis daocloud.io/library/redis:latest</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">持久化</span></span><br><span class="line">docker run -d --name myredis daocloud.io/library/redis:latest --appendonly yes -v /docker/host/dir:/data</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动最简单的 redis 容器， 指定网络类型， 指定 redis 端口</span></span><br><span class="line">docker run -d --net=host --name myredis -p 0.0.0.0:7379:7379 daocloud.io/library/redis:latest redis-server --port 7379</span><br><span class="line">docker ps | grep myredis</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用这个容器</span></span><br><span class="line">docker exec -it myredis redis-cli -p 7379</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">环境变量</span></span><br><span class="line">export REDIS_URI=127.0.0.1:7379</span><br></pre></td></tr></table></figure>

<h5 id="指定配置文件"><a href="#指定配置文件" class="headerlink" title="指定配置文件"></a>指定配置文件</h5><p>redis默认是没有配置的，需要手动加配置，然后后面加上配置。 </p>
<p>从这里搞到配置文件：<a target="_blank" rel="noopener" href="https://gitee.com/percyg/redis%EF%BC%8C">https://gitee.com/percyg/redis，</a> 并修改对应的项</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf --name myredis daocloud.io/library/redis:latest redis-server /usr/local/etc/redis/redis.conf</span><br></pre></td></tr></table></figure>

<h4 id="启动-mongo-容器"><a href="#启动-mongo-容器" class="headerlink" title="启动 mongo 容器"></a>启动 mongo 容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭</span></span><br><span class="line">docker stop mymongo</span><br><span class="line">docker rm -f mymongo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接启动</span></span><br><span class="line">docker run -d --name mymongo mongo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定网络类型及端口</span></span><br><span class="line">docker run -d --net=host --name mymongo -p 0.0.0.0:28017:28017 mongo --port 28017</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用</span> </span><br><span class="line">docker exec -it mymongo mongo --port 28017</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置环境变量</span></span><br><span class="line">export MONGO_URI=mongodb://127.0.0.1:28017/</span><br></pre></td></tr></table></figure>

<h2 id="docker的网络类型"><a href="#docker的网络类型" class="headerlink" title="docker的网络类型"></a>docker的网络类型</h2><p>docker四种网络模式如下：</p>
<ul>
<li>Bridge contauner   桥接式网络模式(默认)</li>
<li>Host(open) container   开放式网络模式，和宿主机共享网络</li>
<li>Container(join) container   联合挂载式网络模式，和其他容器共享网络</li>
<li>None(Close) container   封闭式网络模式，不为容器配置网络</li>
</ul>
<p>可以通过docker network命令查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure>

<h3 id="bridge网络模式—默认"><a href="#bridge网络模式—默认" class="headerlink" title="bridge网络模式—默认"></a>bridge网络模式—默认</h3><p>当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上，所以有默认地址172.17.0.0&#x2F;16的地址。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</p>
<h3 id="Host类型"><a href="#Host类型" class="headerlink" title="Host类型"></a>Host类型</h3><p>简介：与主机共享Network Namespace，–net&#x3D;host， 容器IP、主机名与宿主机一致</p>
<h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法一</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pip 安装</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装pip yum install python3-pip</span></span><br><span class="line">pip3 install docker-compose</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法二</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从github上下载docker-compose二进制文件安装</span></span><br><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>

<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><ul>
<li>相同的基础镜像会被复用，减少文件占用</li>
<li>镜像的大小就是每一层大小的累加</li>
</ul>
<h3 id="镜像系统"><a href="#镜像系统" class="headerlink" title="镜像系统"></a>镜像系统</h3><ul>
<li>首先需要区分Linux内核与Linux发行版<ul>
<li>Linux内核是Linux操作系统的核心, 负责硬件管理, 比如管理内存、管理磁盘（文件系统）、管理CPU(进程)等等…</li>
<li>Linux发行版是在Linux内核的基础上添加了一些工具软件,比如图形界面、函数库、软件包管理系统等等…</li>
</ul>
</li>
<li>Docker容器技术是基于Linux内核实现的， 它主要用到了两个内核模块<ul>
<li>Namespace： 用于容器的隔离， 例如PID Namespace使得容器中的进程无法感知宿主机以及其他容器中的进程</li>
<li>Cgroups: 用于容器的资源控制， 比如限制容器所使用的内存大小或者CPU个数</li>
</ul>
</li>
</ul>
<h3 id="容器的理解"><a href="#容器的理解" class="headerlink" title="容器的理解"></a>容器的理解</h3><ul>
<li>基础镜像是一个包含rootfs的镜像。Kernel启动后是需要把启动文件解压到rootfs上的，然后kernel找到init文件启动就可以得到一个Linux环境了，Docker做的事情就是模拟这个过程，让kernel给出一个独立的隔离环境。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>docker镜像仓库：<a target="_blank" rel="noopener" href="https://hub.docker.com/explore/">https://hub.docker.com/explore/</a></p>
<p>极客学院：<a target="_blank" rel="noopener" href="http://wiki.jikexueyuan.com/project/docker-technology-and-combat/">http://wiki.jikexueyuan.com/project/docker-technology-and-combat/</a></p>
<p>dockerfile: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangmo/p/6811321.html">https://www.cnblogs.com/wangmo/p/6811321.html</a></p>
<p>docker run：<a target="_blank" rel="noopener" href="http://dockone.io/article/152">http://dockone.io/article/152</a></p>
<p>使用国内镜像仓库：<a target="_blank" rel="noopener" href="http://mirrors.ustc.edu.cn/help/dockerhub.html?spm=a2c4e.10696291.0.0.502219a4uycHwi&highlight=docker">http://mirrors.ustc.edu.cn/help/dockerhub.html?spm=a2c4e.10696291.0.0.502219a4uycHwi&amp;highlight=docker</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Percy"
      src="https://ivalue2333.github.io/percy/images/percy.jpg">
  <p class="site-author-name" itemprop="name">Percy</p>
  <div class="site-description" itemprop="description">IOT2014</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">156</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">194</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Percy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
