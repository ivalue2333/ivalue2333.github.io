<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="IOT2014">
<meta property="og:type" content="website">
<meta property="og:title" content="blog | percy">
<meta property="og:url" content="http://example.com/page/12/index.html">
<meta property="og:site_name" content="blog | percy">
<meta property="og:description" content="IOT2014">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Percy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>blog | percy</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blog | percy</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/04/learn/oauth2.0%E6%8E%88%E6%9D%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/04/learn/oauth2.0%E6%8E%88%E6%9D%83/" class="post-title-link" itemprop="url">OAuth2.0授权</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-04 21:21:13" itemprop="dateCreated datePublished" datetime="2020-05-04T21:21:13+08:00">2020-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="OAuth2-0是什么"><a href="#OAuth2-0是什么" class="headerlink" title="OAuth2.0是什么"></a>OAuth2.0是什么</h2><ul>
<li>支持第三方登陆的功能</li>
<li>当然，有了第三方登陆，那么也就有了第三方的接口权限，毕竟有了access_token，相当于第三方开放了一些用户的接口，你可以使用用户的授权（access_token），去请求这些接口，这些接口会返回授权用户的一些信息。例如，在电商项目中，获取到一个店铺的授权后，就可以通过淘宝的开放平台拿取到授权店铺的在售商品等。</li>
</ul>
<h2 id="OAuth2-0的客户端需要做什么"><a href="#OAuth2-0的客户端需要做什么" class="headerlink" title="OAuth2.0的客户端需要做什么"></a>OAuth2.0的客户端需要做什么</h2><ol>
<li>在授权服务器中申请一个应用，这将获得 client_id, client_secret。</li>
<li>在授权服务器中填写回调的redirec_uri。</li>
<li>按照授权服务器的url拼接方式，拼接授权ur（这应该会包含client_id）。用户打开此url，将跳转到授权服务器的根域名下的一个页面，用户在此页面<strong>执行授权操作</strong>（点击按钮，或者扫描二维码）。</li>
<li>当授权服务器验证两个URL一致时，会通知浏览器跳转到redirect_uri，同时，在redirect_uri后附加用户凭证（code）的相关信息。</li>
<li>客户端接受回调的redirect_uri，这里面有code信息（也有用户在授权服务器的用户信息，如用户名等），客户端拿着code，并带上申请到的client_id, client_secret， 去请求授权服务器，授权服务器验证code和client_id，保证请求access_token的应用就是用户授权的应用，并返回access_token。</li>
<li>客户端可能需要定时刷新token，这是因为access_token一般都有过期时间，在access_token过期前，客户端主动刷新token，可以免去access_token过期后用户又要授权的问题。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20913727">https://zhuanlan.zhihu.com/p/20913727</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/03/24/distribute/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%20k8s%E3%80%901%E3%80%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/24/distribute/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%20k8s%E3%80%901%E3%80%91/" class="post-title-link" itemprop="url">虚拟化之开始使用 k8s【1】</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-24 19:14:37" itemprop="dateCreated datePublished" datetime="2020-03-24T19:14:37+08:00">2020-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-07 19:10:23" itemprop="dateModified" datetime="2023-02-07T19:10:23+08:00">2023-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">虚拟化</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="kubeconfig-文件使用"><a href="#kubeconfig-文件使用" class="headerlink" title="kubeconfig 文件使用"></a>kubeconfig 文件使用</h2><p>将 k8s 的配置文件拷贝到 ~&#x2F;.kube&#x2F; 目录下，命名为 config，最后得到的是 ~.&#x2F;.kube&#x2F;config</p>
<p>kubeconfig 配置文件的解释，生成请看官方文档</p>
<p><a target="_blank" rel="noopener" href="https://jimmysong.io/kubernetes-handbook/guide/authenticate-across-clusters-kubeconfig.html">https://jimmysong.io/kubernetes-handbook/guide/authenticate-across-clusters-kubeconfig.html</a></p>
<h3 id="使用-kubeconfig-文件配置跨集群认证"><a href="#使用-kubeconfig-文件配置跨集群认证" class="headerlink" title="使用 kubeconfig 文件配置跨集群认证"></a>使用 kubeconfig 文件配置跨集群认证</h3><p>当你有了权限的 kubeconfig 文件后（如上文），那么在你的wsl下，执行如下就能连接到你的开发环境的 k8s集群</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n dev-cm get pods</span><br></pre></td></tr></table></figure>

<p>跨集群认证：<a target="_blank" rel="noopener" href="https://jimmysong.io/kubernetes-handbook/guide/authenticate-across-clusters-kubeconfig.html">https://jimmysong.io/kubernetes-handbook/guide/authenticate-across-clusters-kubeconfig.html</a></p>
<h2 id="使用端口转发来访问集群中的应用"><a href="#使用端口转发来访问集群中的应用" class="headerlink" title="使用端口转发来访问集群中的应用"></a>使用端口转发来访问集群中的应用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n dev-cm port-forward pods/redis-master-765d459796-258hz 7000:6379</span><br><span class="line"></span><br><span class="line">这样的话，访问本地的 7000 端口，相当于访问了redis-master-765d459796-258hz 这个节点</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参考：https://kubernetes.io/zh/docs/tasks/access-application-cluster/port-forward-access-application-cluster/</span></span><br></pre></td></tr></table></figure>

<h2 id="coredns"><a href="#coredns" class="headerlink" title="coredns"></a>coredns</h2><p>设置k8s集群公用的hosts配置</p>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul>
<li>kubernetes集群外部有一些服务(比如redis、mongo、pulsar)，集群内部pod需要通过服务所在的主机的hostname访问服务。</li>
<li>不希望在所有的worker上都设置&#x2F;etc&#x2F;hosts, (不方便维护)</li>
<li>希望集群能统一管理解析hostname, 所有pod共用</li>
</ul>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl get configmap coredns -o yaml -n kube-system</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置</span></span><br><span class="line">kubectl apply -f coredns.yaml</span><br><span class="line"><span class="comment"># kubectl replace -f coredns.yaml</span></span><br></pre></td></tr></table></figure>

<h2 id="外部访问"><a href="#外部访问" class="headerlink" title="外部访问"></a>外部访问</h2><h3 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h3><ul>
<li>需要一个代理服务提供统一的入口，来转发外部访问kubernetes集群内部服务的请求，而不是暴露所有服务端口到宿主机</li>
<li>外部访问服务需要明确知道这个统一入口的地址（地址列表），方便把请求转发过来</li>
<li>这个代理服务需要实时感知集群内部服务的网络变化情况</li>
<li>要能灵活的配置路由规则</li>
</ul>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul>
<li>为了满足上面的需求，k8s提供了ingress机制。目前比较流行的ingress controller有 nginx-ingress 和 traefik。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://docs.traefik.io/v2.0/routing/providers/kubernetes-crd/">https://docs.traefik.io/v2.0/routing/providers/kubernetes-crd/</a></p>
<h3 id="文件示例"><a href="#文件示例" class="headerlink" title="文件示例"></a>文件示例</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">Corefile:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    .:53 &#123;</span></span><br><span class="line"><span class="string">        errors</span></span><br><span class="line"><span class="string">        health</span></span><br><span class="line"><span class="string">        hosts &#123;</span></span><br><span class="line"><span class="string">            10.23.112.157 etcd001</span></span><br><span class="line"><span class="string">            10.23.111.56 es001</span></span><br><span class="line"><span class="string">            fallthrough</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        kubernetes cluster.local in-addr.arpa ip6.arpa &#123;</span></span><br><span class="line"><span class="string">           pods insecure</span></span><br><span class="line"><span class="string">           upstream</span></span><br><span class="line"><span class="string">           fallthrough in-addr.arpa ip6.arpa</span></span><br><span class="line"><span class="string">           ttl 30</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        prometheus :9153</span></span><br><span class="line"><span class="string">        forward . /etc/resolv.conf</span></span><br><span class="line"><span class="string">        cache 30</span></span><br><span class="line"><span class="string">        loop</span></span><br><span class="line"><span class="string">        reload</span></span><br><span class="line"><span class="string">        loadbalance</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">&quot;2019-09-10T11:59:48Z&quot;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">coredns</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure>

<h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>Namespace 是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为不同的项目组或用户组。常见的 pods, services, replication controllers 和 deployments 等都是属于某一个 namespace 的（默认是 default），而 node, persistentVolumes 等则不属于任何 namespace。</p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>Service 是应用服务的抽象，通过 labels 为应用提供负载均衡和服务发现。匹配 labels 的 Pod IP 和端口列表组成 endpoints，由 kube-proxy 负责将服务 IP 负载均衡到这些 endpoints 上。</p>
<p>每个 Service 都会自动分配一个 cluster IP（仅在集群内部可访问的虚拟地址）和 DNS 名，其他容器可以通过该地址或 DNS 来访问服务，而不需要了解后端容器的运行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|&gt;# kcs | grep robotser</span><br><span class="line">robotserver-pf-service                            ClusterIP   172.96.98.90     &lt;none&gt;        8080/TCP                                       22d</span><br><span class="line">robotserver-service                               ClusterIP   172.96.179.246   &lt;none&gt;        8080/TCP,8081/TCP                              22d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入pod</span></span><br><span class="line">|&gt;# kc exec -it deploy/robotserver-deploy bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过集群内虚拟 ip + port 访问</span></span><br><span class="line">curl &quot;172.96.98.90:8080/testing/reply&quot;</span><br></pre></td></tr></table></figure>

<h2 id="kubectl-常用指令"><a href="#kubectl-常用指令" class="headerlink" title="kubectl 常用指令"></a>kubectl 常用指令</h2><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 别名</span></span><br><span class="line"><span class="built_in">export</span> namespace_alias=<span class="string">&quot;dev-cm&quot;</span></span><br><span class="line"><span class="built_in">alias</span> kc=<span class="string">&#x27;kubectl -n $&#123;namespace_alias&#125;&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> kcc=<span class="string">&#x27;kubectl -n $&#123;namespace_alias&#125; get cm&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> kcd=<span class="string">&#x27;kubectl -n $&#123;namespace_alias&#125; get deploy&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> kcp=<span class="string">&#x27;kubectl -n $&#123;namespace_alias&#125; -o wide get pod&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> kcs=<span class="string">&#x27;kubectl -n $&#123;namespace_alias&#125; get service&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> kcpg=<span class="string">&#x27;kubectl -n $&#123;namespace_alias&#125; -o wide get pod | grep&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> kcdes=<span class="string">&#x27;kubectl -n $&#123;namespace_alias&#125; describe&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> kce=<span class="string">&#x27;kubectl -n $&#123;namespace_alias&#125; exec -it deploy/&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> kcr=<span class="string">&#x27;kubectl -n $&#123;namespace_alias&#125; rollout restart deploy&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ec=<span class="string">&#x27;cd ~/k8s-app-deploy/ns-prod/ecrobot&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> cdl=<span class="string">&#x27;cd /var/log/xiaoduo/$&#123;namespace_alias&#125;/&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> dpg=<span class="string">&#x27;docker ps | grep&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> mg=<span class="string">&#x27;kubectl -n $&#123;namespace_alias&#125; exec -it mongo-42-0 mongo&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> qwer=<span class="string">&#x27;git add . &amp;&amp; git commit -m &quot;fix&quot; &amp;&amp; git push&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> qwe=<span class="string">&#x27;git add . &amp;&amp; git commit -m &quot;fix&quot; &amp;&amp; git push gitee&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gc=<span class="string">&#x27;git checkout&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gcm=<span class="string">&#x27;git checkout master&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gcb=<span class="string">&#x27;git checkout -&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gp=<span class="string">&#x27;git pull&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gb=<span class="string">&#x27;git branch&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gbd=<span class="string">&#x27;git branch -D&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gl=<span class="string">&#x27;git log&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 资源列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点机器</span></span><br><span class="line">kc get nodes</span><br><span class="line"><span class="comment"># 部署</span></span><br><span class="line">kc get deployments</span><br><span class="line">kc get deploy</span><br><span class="line"><span class="comment"># 服务</span></span><br><span class="line">kc get services</span><br><span class="line">kc get svc</span><br><span class="line"><span class="comment"># config map</span></span><br><span class="line">kc get configmaps</span><br><span class="line">kc get cm</span><br><span class="line"><span class="comment"># pods</span></span><br><span class="line">kc get pods</span><br><span class="line">kc get pod</span><br><span class="line"></span><br><span class="line"><span class="comment">#资源详情</span></span><br><span class="line"><span class="comment"># -o yaml 以 yaml 格式显示</span></span><br><span class="line"><span class="comment"># -o json 以 JSON 格式显示</span></span><br><span class="line"><span class="comment"># 部署配置</span></span><br><span class="line">kc get deploy configure-tb-deploy -o yaml</span><br><span class="line"><span class="comment"># 资源详情</span></span><br><span class="line">kc get cm conf-configure-tb -o yaml</span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同 get, 只是 动词换为了 delete</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除服务</span></span><br><span class="line">kc delete svc sdk-tb-service</span><br><span class="line">kc delete deploy deploy-sdk-tb-api</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除pod</span></span><br><span class="line">kc delete pods robotserver-pf-pro-deploy-7c6c4b994f-cjxlz --force --grace-period=0</span><br><span class="line"></span><br><span class="line">kubectl delete deployment-ee-janus-confcache-1-7cbf798f88-dj4rg</span><br></pre></td></tr></table></figure>

<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">前置条件</span></span><br><span class="line">配置文件路径：~/.kube/config, kubectl -n dev-cm get pods</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改部署镜像</span></span><br><span class="line">kc set image deploy configure-jd-deploy configure-jd=registry.cn-zhangjiakou.aliyuncs.com/xiaoduoai/ecrobot-configure-jd:v3.4.19</span><br><span class="line"></span><br><span class="line">kc set image deploy config-check-deploy config-check=</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑资源</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑 ConfigMap</span></span><br><span class="line">kc edit cm --save-config conf-configure-tb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑 deployment 资源</span></span><br><span class="line">kc edit deploy --save-config configure-tb-deploy</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启服务</span></span><br><span class="line">kc rollout restart deploy configure-tb-deploy</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制删除pods</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> kubectl drain 安全驱逐节点上面所有的 pod</span></span><br><span class="line">kc get nodes # 想查看有哪些节点</span><br><span class="line">kc drain &lt;node name&gt;</span><br><span class="line"></span><br><span class="line">kc drain alizjk-023112166-kubelet-ks-high --ignore-daemonsets</span><br><span class="line">kc drain alizjk-023112165-kubelet-ks-high --ignore-daemonsets</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一次驱逐多个node</span></span><br><span class="line">kc drain alizjk-023112163-kubelet-ks-high alizjk-023112162-kubelet-ks-high --ignore-daemonsets</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行完成后，如果没有任何错误返回，您可以关闭节点（如果是在云平台上，可以删除支持该节点的虚拟机）。如果在维护操作期间想要将节点留在集群，那么您需要运行下面命令：</span></span><br><span class="line">kubectl uncordon &lt;node name&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">然后，它将告知 Kubernetes 允许调度新的 pod 到该节点。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">驱逐了节点上的pod后，最好在master上删除node</span></span><br><span class="line">kc delete nodes &lt;node name&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调整服务的副本数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暂时将服务的副本数设置成 0，达到“停止服务”的目的</span></span><br><span class="line">kc scale --replicas=0 deploy configure-internal-tb-deploy</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">之后可以将副本数修改成 1 来重新启动服务</span></span><br><span class="line">kc scale --replicas=1 deploy configure-internal-tb-deploy</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器内部</span></span><br><span class="line">kc exec -it mongo-accounting-xxx mongo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如何 ping 服务， 进入一个容器内容，让后 ping service-name</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器的日志</span></span><br><span class="line">kc logs -f user-service-deploy-58bd484789-7ct66 user-service</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-f 参数是持续跟踪日志的输出</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&quot;user-service-deploy-58bd484789-7ct66&quot;</span> 是 pod 的名称，由于这个 pod 里面运行了两个容器，所以需指定查看哪个容器的日志 <span class="string">&quot;user-service&quot;</span> 是 pod 里面其中一个容器的名字</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基于配置文件部署</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 ConfigMap 配置文件可以是 yaml 格式， 也可以是 json 格式</span></span><br><span class="line">kc create configmap conf-goods-center --from-file=./goods_center.toml</span><br><span class="line">kc create cm conf-goods-center --from-file=./goods_center.toml</span><br><span class="line">kc apply -f deployment.yaml</span><br><span class="line">kc apply -f deployment.json</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有的创建都是如此</span></span><br><span class="line">kc apply -f service.json</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只有一个配置文件</span></span><br><span class="line">kc create configmap conf-go-mod -f conf.json</span><br><span class="line">kc apply -f conf.json</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 k8s 内是通过 service name + port 来访问的， 例如大多数的 golang 开启对外的 8080端口，用于http访问, 如 proxy-service:8080， 大多数的pulsar开启的是的 6650端口， 访问是 pulsar-service:6650。一个service 通过 spec.selector.app: apigate 来指明它的访问名， 这个 `apigate` 是 pod 内的 metadata.labels.app</span></span><br></pre></td></tr></table></figure>

<h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝资源， 注意pb.gz 这种文件好像无法拷贝</span></span><br><span class="line"><span class="comment"># 从pod 拷贝出来</span></span><br><span class="line">kubectl <span class="built_in">cp</span> &lt;some-namespace&gt;/&lt;some-pod&gt;:/tmp/foo /tmp/bar</span><br><span class="line"><span class="comment"># 例如</span></span><br><span class="line">kubectl <span class="built_in">cp</span> test-ks/mongo-42-0:tmp/new_account.dat new_account.dat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例如</span></span><br><span class="line">kubectl <span class="built_in">cp</span> -c cloud-loan-gate uat/cloud-786d84c554-p7jz7:app/logs/app/cloud.log cloud.log</span><br><span class="line"></span><br><span class="line">uat:为namespace</span><br><span class="line">-c :指定容器（因pod中有多个container，默认从第一个，有可能报错找不到文件和目录）</span><br><span class="line">源目录参数时，：后只能跟文件名，不能是以“/”开头的路径（eg:app/logs/cloud.log）</span><br><span class="line">目标参数时，必须为文件不能是一个目录(eg:cloud.log)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl <span class="built_in">cp</span> /tmp/foo &lt;some-namespace&gt;/&lt;some-pod&gt;:/tmp/bar</span><br><span class="line"></span><br><span class="line">kubectl <span class="built_in">cp</span> new_account.dat test-kuaishou/mongo-42-0:/tmp/new_account.data</span><br></pre></td></tr></table></figure>

<h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><h4 id="node-label"><a href="#node-label" class="headerlink" title="node label"></a>node label</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@tb-dev-agent21 <span class="built_in">test</span>]<span class="comment"># kubectl get nodes</span></span><br><span class="line">NAME             STATUS   ROLES    AGE   VERSION</span><br><span class="line">tb-dev-agent21   Ready    master   68d   v1.15.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指令</span></span><br><span class="line">kubectl label nodes &lt;node_name&gt; key1=val1 key2=val2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指令实例</span></span><br><span class="line">kubectl label nodes tb-dev-agent21 ns-test-kuaishou=<span class="string">&quot;true&quot;</span></span><br><span class="line">kubectl label nodes tb-dev-agent21 nodetype=qc</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查询节点已有的标签：</span></span><br><span class="line">kubectl get node --show-labels=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># https://blog.csdn.net/kozazyh/article/details/88587012</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Kubernetes Labels 和 Selectors：<a target="_blank" rel="noopener" href="http://docs.kubernetes.org.cn/247.html">http://docs.kubernetes.org.cn/247.html</a></p>
<p>参考：<a target="_blank" rel="noopener" href="https://jimmysong.io/kubernetes-handbook/guide/kubectl-cheatsheet.html">https://jimmysong.io/kubernetes-handbook/guide/kubectl-cheatsheet.html</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1140076">https://cloud.tencent.com/developer/article/1140076</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/03/05/operation%20system/linux%E8%99%9A%E6%8B%9F%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/05/operation%20system/linux%E8%99%9A%E6%8B%9F%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80/" class="post-title-link" itemprop="url">linux虚拟空间布局</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-05 16:02:26" itemprop="dateCreated datePublished" datetime="2020-03-05T16:02:26+08:00">2020-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在多任务操作系统中，每个进程都运行在属于自己的内存沙盘中。这个沙盘就是虚拟地址空间(Virtual Address Space)，在32位模式下它是一个4GB的内存地址块。在Linux系统中, 内核进程和用户进程所占的虚拟内存比例是1:3，而Windows系统为2:2(通过设置Large-Address-Aware Executables标志也可为1:3)。这并不意味着内核使用那么多物理内存，仅表示它可支配这部分地址空间，根据需要将其映射到物理内存。</p>
<h2 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h2><p>内核总是驻留在内存中，是操作系统的一部分。内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。</p>
<h2 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h2><table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>存储内容</strong></th>
</tr>
</thead>
<tbody><tr>
<td>栈</td>
<td>返回地址、函数参数、局部变量、临时存储区</td>
</tr>
<tr>
<td>堆</td>
<td>动态分配的内存</td>
</tr>
<tr>
<td>BSS段</td>
<td>未初始化或初值为0的全局变量和静态局部变量</td>
</tr>
<tr>
<td>数据段</td>
<td>已初始化且初值非0的全局变量和静态局部变量</td>
</tr>
<tr>
<td>代码段</td>
<td>可执行代码、字符串字面值、只读变量</td>
</tr>
</tbody></table>
<p><strong>在将应用程序从可执行文件（file）加载到内存空间（memory）执行时，操作系统负责代码段、数据段和BSS段的加载，并在内存中为这些段分配空间。栈也由操作系统分配和管理；堆由程序员自己管理，即显式地申请和释放空间。</strong></p>
<p><strong>BSS段、数据段和代码段是可执行程序编译时的分段，运行时还需要栈和堆。</strong></p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈又称为栈，由编译器自动分配释放，行为类似数据结构中的栈(先进后出)。栈主要有三个用途：</p>
<ul>
<li>为函数内部声明的非静态局部变量(C语言中称“自动变量”)提供存储空间。</li>
<li>记录函数调用过程相关的维护性信息，称为栈帧(Stack Frame)或过程活动记录(Procedure Activation Record)。它包括函数返回地址，不适合装入寄存器的函数参数及一些寄存器值的保存。除递归调用外，栈并非必需。因为编译时可获知局部变量，参数和返回地址所需空间，并将其分配于BSS段。</li>
<li>临时存储区，用于暂存长算术表达式部分计算结果或alloca()函数分配的栈内内存。</li>
</ul>
<p>stack 常出现的问题是<strong>stack overflow</strong>， 即申请的栈内存太多，程序崩溃。典型的例子就是不加控制的递归函数。</p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p><strong>局部变量其实一般就是说具有块作用域的变量。</strong>如果要在不同的块之间共享存储在局部变量中的数据，只能通过参数传递来实现。这种共享只能在主调函数和被调函数之间进行。因为局部变量具有块作用域，所以不同函数中的局部变量是互不可见的，这也是函数之间的一种数据隐藏，在结构化程序设计中这是实现数据隐藏的唯一方式。而在面向对象设计中主要靠封装来隐藏数据</p>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的 i 很明显是个非静态局部变量，自然 i 是在栈上。栈上的内存会在函数返回后释放掉（栈顶指针移动），但是这里对 i 进行取址并返回出去，显然就会产生悬挂指针的问题。正确的方式应该是将内存分配在堆上。</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">dangling_pointer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法，大概是这个意思，太久没写c了。</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">dangling_pointer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *a; </span><br><span class="line">    a = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">2</span>);</span><br><span class="line">    *a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *a);</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存映射段-mmap"><a href="#内存映射段-mmap" class="headerlink" title="内存映射段(mmap)"></a>内存映射段(mmap)</h3><p> 此处，内核将硬盘文件的内容直接映射到内存, 任何应用程序都可通过Linux的mmap()系统调用或Windows的CreateFileMapping()&#x2F;MapViewOfFile()请求这种映射。内存映射是一种方便高效的文件I&#x2F;O方式， 因而被用于装载动态共享库。用户也可创建匿名内存映射，该映射没有对应的文件, 可用于存放程序数据。在 Linux中，若通过malloc()请求一大块内存，C运行库将创建一个匿名内存映射，而不使用堆内存。”大块” 意味着比阈值 MMAP_THRESHOLD还大，缺省为128KB，可通过mallopt()调整。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><strong>堆用于存放进程运行时动态分配的内存段</strong>，可动态扩张或缩减。堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问。当进程调用malloc(C)&#x2F;new(C++)等函数分配内存时，新分配的内存动态添加到堆上(扩张)；当调用free(C)&#x2F;delete(C++)等函数释放内存时，被释放的内存从堆中剔除(缩减) 。</p>
<p>使用堆时经常出现两种问题：1) 释放或改写仍在使用的内存(<strong>内存破坏</strong>)；2)未释放不再使用的内存(<strong>内存泄漏</strong>)。当释放次数少于申请次数时，可能已造成内存泄漏。泄漏的内存往往比忘记释放的数据结构更大，因为所分配的内存通常会圆整为下个大于申请数量的2的幂次(如申请212B，会圆整为256B)。</p>
<p>注意，堆不同于数据结构中的”堆”，其行为类似链表。</p>
<p>heap 常出现的问题是<strong>out of memory</strong>，即申请的堆内存太多，这一般情况下是因为<strong>内存泄露</strong>导致堆内存不够。</p>
<h3 id="BSS段"><a href="#BSS段" class="headerlink" title="BSS段"></a>BSS段</h3><p>BSS(Block Started by Symbol)段中通常存放程序中以下符号：</p>
<ul>
<li>未初始化的全局变量和静态局部变量</li>
<li>初始值为0的全局变量和静态局部变量(依赖于编译器实现)</li>
<li>未定义且初值不为0的符号(该初值即common block的大小)</li>
</ul>
<h3 id="数据段-Data"><a href="#数据段-Data" class="headerlink" title="数据段(Data)"></a>数据段(Data)</h3><p>数据段通常用于存放程序中已初始化且初值不为0的全局变量和静态局部变量。数据段属于静态内存分配(静态存储区)，可读可写。数据段保存在目标文件中(在嵌入式系统里一般固化在镜像文件中)，其内容由程序初始化。例如，<strong>对于全局变量int gVar &#x3D; 10，必须在目标文件数据段中保存10这个数据，然后在程序加载时复制到相应的内存</strong>。</p>
<h3 id="代码段-text"><a href="#代码段-text" class="headerlink" title="代码段(text)"></a>代码段(text)</h3><p>代码段也称正文段或文本段，通常用于存放程序执行代码(即CPU执行的机器指令)。一般C语言执行语句都编译成机器代码保存在代码段。通常代码段是可共享的，因此频繁执行的程序只需要在内存中拥有一份拷贝即可。代码段通常属于只读，以防止其他程序意外地修改其指令(对该段的写操作将导致段错误)。某些架构也允许代码段为可写，即允许修改程序。</p>
<p>代码段指令根据程序设计流程依次执行，对于顺序指令，只会执行一次(每个进程)；若有反复，则需使用跳转指令；若进行递归，则需要借助栈来实现。</p>
<p>代码段指令中包括操作码和操作对象(或对象地址引用)。若操作对象是立即数(具体数值)，将直接包含在代码中；若是局部数据，将在栈区分配空间，然后引用该数据地址；若位于BSS段和数据段，同样引用该数据地址。</p>
<p> 代码段最容易受优化措施影响。</p>
<h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p>【扩展阅读】<strong>栈和堆的区别</strong></p>
<p>①<strong>管理方式</strong>：栈由编译器自动管理；堆由程序员控制，使用方便，但易产生内存泄露。</p>
<p>②<strong>生长方向</strong>：栈向低地址扩展(即”向下生长”)，是连续的内存区域；堆向高地址扩展(即”向上生长”)，是不连续的内存区域。这是由于系统用链表来存储空闲内存地址，自然不连续，而链表从低地址向高地址遍历。</p>
<p>③<strong>空间大小</strong>：栈顶地址和栈的最大容量由系统预先规定(通常默认2M或10M)；堆的大小则受限于计算机系统中有效的虚拟内存，32位Linux系统中堆内存可达2.9G空间。</p>
<p>④<strong>存储内容</strong>：栈在函数调用时，首先压入主调函数中下条指令(函数调用语句的下条可执行语句)的地址，然后是函数实参，然后是被调函数的局部变量。本次调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的指令地址，程序由该点继续运行下条可执行语句。堆通常在头部用一个字节存放其大小，堆用于存储生存期与函数调用无关的数据，具体内容由程序员安排。</p>
<p>⑤<strong>分配方式</strong>：栈可静态分配或动态分配。静态分配由编译器完成，如局部变量的分配。动态分配由alloca函数在栈上申请空间，用完后自动释放。堆只能动态分配且手工释放。</p>
<p>⑥<strong>分配效率</strong>：栈由计算机底层提供支持：分配专门的寄存器存放栈地址，压栈出栈由专门的指令执行，因此效率较高。堆由函数库提供，机制复杂，效率比栈低得多。Windows系统中VirtualAlloc可直接在进程地址空间中分配一块内存，快速且灵活。</p>
<p>⑦<strong>分配后系统响应</strong>：只要栈剩余空间大于所申请空间，系统将为程序提供内存，否则报告异常提示栈溢出。</p>
<p>操作系统为堆维护一个记录空闲内存地址的链表。当系统收到程序的内存分配申请时，会遍历该链表寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点空间分配给程序。若无足够大小的空间(可能由于内存碎片太多)，有可能调用系统功能去增加程序数据段的内存空间，以便有机会分到足够大小的内存，然后进行返回。，大多数系统会在该内存空间首地址处记录本次分配的内存大小，供后续的释放函数(如free&#x2F;delete)正确释放本内存空间。</p>
<p>此外，由于找到的堆结点大小不一定正好等于申请的大小，系统会自动将多余的部分重新放入空闲链表中。</p>
<p>⑧<strong>碎片问题</strong>：栈不会存在碎片问题，因为栈是先进后出的队列，内存块弹出栈之前，在其上面的后进的栈内容已弹出。而频繁申请释放操作会造成堆内存空间的不连续，从而造成大量碎片，使程序效率降低。</p>
<p>可见，堆容易造成内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和内核态切换，内存申请的代价更为昂贵。所以栈在程序中应用最广泛，函数调用也利用栈来完成，调用过程中的参数、返回地址、栈基指针和局部变量等都采用栈的方式存放。所以，建议尽量使用栈，仅在分配大量或大块内存空间时使用堆。</p>
<p>使用栈和堆时应避免越界发生，否则可能程序崩溃或破坏程序堆、栈结构，产生意想不到的后果。</p>
<p>原文：linux 虚拟空间布局：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/clover-toeic/p/3754433.html">https://www.cnblogs.com/clover-toeic/p/3754433.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/26/http/udp%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/26/http/udp%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">udp入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-26 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-26T00:00:00+08:00">2020-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>用户数据报协议 UDP 只在 IP 的数据报服务之上增加了很少一点的功能，这就是复用和分用的功能以及查错检测的功能</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/yzn5GD"><img src="https://s3.ax1x.com/2021/02/26/yzn5GD.png" alt="yzn5GD.png"></a></p>
<h3 id="空间复杂度和时间复杂度"><a href="#空间复杂度和时间复杂度" class="headerlink" title="空间复杂度和时间复杂度"></a>空间复杂度和时间复杂度</h3><p>封装带来的空间复杂度， 缓存带来的时间复杂度。两者是对立影响的，如果想减少封装消耗，那么就必须缓存用户数据到一定量在一次性封装发送出去，这样每个协议包的有效载荷将达到最大化，这无疑是节省了带宽空间，带宽利用率较高，但是延时增大了。如果想降低延时，那么就需要将用户数据立马封装发出去，这样显然会造成消耗更多的协议头等消耗，浪费带宽空间。</p>
<h2 id="UDP-包的大小"><a href="#UDP-包的大小" class="headerlink" title="UDP 包的大小"></a>UDP 包的大小</h2><p>面向报文的传输方式决定了 UDP 的数据发送方式是一份一份的，也就是应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。那么UDP的报文大小由哪些影响因素呢？ UDP 数据包的理论长度是多少，合适的 UDP 数据包应该是多少呢？</p>
<h3 id="UDP-报文大小的影响因素，主要有以下3个："><a href="#UDP-报文大小的影响因素，主要有以下3个：" class="headerlink" title="UDP 报文大小的影响因素，主要有以下3个："></a>UDP 报文大小的影响因素，主要有以下3个：</h3><ul>
<li>UDP协议本身，UDP协议中有16位的UDP报文长度，那么UDP报文长度不能超过 2^16 -1 &#x3D;65536 -1 ；</li>
<li>以太网(Ethernet)数据帧的长度，数据链路层的MTU(最大传输单元)；</li>
<li>socket的UDP发送缓存区大小。</li>
</ul>
<h3 id="UDP数据包最大长度："><a href="#UDP数据包最大长度：" class="headerlink" title="UDP数据包最大长度："></a>UDP数据包最大长度：</h3><p>根据 UDP 协议，从 UDP 数据包的包头可以看出，UDP 的最大包长度是2^16-1的个字节。由于UDP包头占8个字节，而在IP层进行封装后的IP包头占去20字节，所以这个是UDP数据包的最大理论长度是2^16 - 1 - 8 - 20 &#x3D; 65507字节。</p>
<h3 id="UDP数据包理想长度："><a href="#UDP数据包理想长度：" class="headerlink" title="UDP数据包理想长度："></a>UDP数据包理想长度：</h3><h4 id="MTU-最大传输单元（数据链路层）"><a href="#MTU-最大传输单元（数据链路层）" class="headerlink" title="MTU 最大传输单元（数据链路层）"></a>MTU 最大传输单元（数据链路层）</h4><p>MTU 最大传输单元，这个最大传输单元实际上和链路层协议有着密切的关系，EthernetII 帧的结构 DMAC + SMAC + Type + Data + CRC 由于以太网传输电气方面的限制，每个以太网帧都有最小的大小64字节，最大不能超过1518字节，对于小于或者大于这个限制的以太网帧我们都可以视之为错误的数据帧，一般的以太网转发设备会丢弃这些数据帧。由于以太网 EthernetII 最大的数据帧是1518字节，除去以太网帧的帧头（DMAC目的 MAC 地址48bit&#x3D;6Bytes+SMAC源 MAC 地址48bit&#x3D;6Bytes+Type域2bytes）14Bytes和帧尾CRC校验部分4Bytes那么剩下承载上层协议的地方也就是Data域最大就只能有1500字节这个值我们就把它称之为MTU。</p>
<h4 id="UDP数据包理想长度"><a href="#UDP数据包理想长度" class="headerlink" title="UDP数据包理想长度"></a>UDP数据包理想长度</h4><p>在下层数据链路层最大传输单元是1500字节的情况下，要想IP层不分包，那么UDP数据包的最大大小应该是1500字节 – IP头(20字节) – UDP头(8字节) &#x3D; 1472字节。不过鉴于Internet上的标准MTU值为576字节，所以建议在进行Internet的UDP编程时，<strong>最好将UDP的数据长度控制在 (576-8-20)548字节以内</strong>。</p>
<h2 id="UDP数据包的发送和接收问题"><a href="#UDP数据包的发送和接收问题" class="headerlink" title="UDP数据包的发送和接收问题"></a>UDP数据包的发送和接收问题</h2><h3 id="1-UDP的通信有界性："><a href="#1-UDP的通信有界性：" class="headerlink" title="(1) UDP的通信有界性："></a>(1) UDP的通信有界性：</h3><p>在阻塞模式下，UDP的通信是以数据包作为界限的，即使server端的缓冲区再大也要按照client发包的次数来多次接收数据包，server只能一次一次的接收，client发送多少次，server就需接收多少次，即客户端分几次发送过来，服务端就必须按几次接收。</p>
<h3 id="2-UDP数据包的无序性和非可靠性："><a href="#2-UDP数据包的无序性和非可靠性：" class="headerlink" title="(2) UDP数据包的无序性和非可靠性："></a>(2) UDP数据包的无序性和非可靠性：</h3><p>client依次发送1、2、3三个UDP数据包，server端先后调用3次接收函数，可能会依次收到3、2、1次序的数据包，收包可能是1、2、3的任意排列组合，也可能丢失一个或多个数据包。</p>
<h3 id="3-UDP数据包的接收："><a href="#3-UDP数据包的接收：" class="headerlink" title="(3) UDP数据包的接收："></a>(3) UDP数据包的接收：</h3><p>client发送两次UDP数据，第一次 500字节，第二次300字节，server端阻塞模式下接包，第一次recvfrom( 1000 )，收到是 1000，还是500，还是300，还是其他？</p>
<p>由于UDP通信的有界性，接收到只能是500或300，又由于UDP的无序性和非可靠性，接收到可能是300，也可能是500，也可能一直阻塞在recvfrom调用上，直到超时返回(也就是什么也收不到)。</p>
<p>在假定数据包是不丢失并且是按照发送顺序按序到达的情况下，server端阻塞模式下接包，先后三次调用：recvfrom( 200)，recvfrom( 1000)，recvfrom( 1000)，接收情况如何呢？</p>
<p>由于UDP通信的有界性，第一次recvfrom( 200)将接收第一个500字节的数据包，但是因为用户空间buf只有200字节，于是只会返回前面200字节，剩下300字节将丢弃。第二次recvfrom( 1000)将返回300字节，第三次recvfrom( 1000)将会阻塞。</p>
<h3 id="4-UDP包分片问题："><a href="#4-UDP包分片问题：" class="headerlink" title="(4) UDP包分片问题："></a>(4) UDP包分片问题：</h3><p>如果MTU是1500，Client发送一个8000字节大小的UDP包，那么Server端阻塞模式下接包，在不丢包的情况下，recvfrom(9000)是收到1500，还是8000。如果某个IP分片丢失了，recvfrom(9000)，又返回什么呢？</p>
<p>根据UDP通信的有界性，在buf足够大的情况下，接收到的一定是一个完整的数据包，<strong>UDP数据在下层的分片和组片问题由IP层来处理，提交到UDP传输层一定是一个完整的UDP包</strong>，那么recvfrom(9000)将返回8000。如果某个IP分片丢失，udp里有个CRC检验，如果包不完整就会丢弃，也不会通知是否接收成功，所以UDP是不可靠的传输协议，那么recvfrom(9000)将阻塞。</p>
<h2 id="UDP丢包问题"><a href="#UDP丢包问题" class="headerlink" title="UDP丢包问题"></a>UDP丢包问题</h2><h3 id="UDP-socket缓冲区满造成的UDP丢包："><a href="#UDP-socket缓冲区满造成的UDP丢包：" class="headerlink" title="UDP socket缓冲区满造成的UDP丢包："></a>UDP socket缓冲区满造成的UDP丢包：</h3><p>通过 cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;rmem_default 和cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;rmem_max可以查看socket缓冲区的缺省值和最大值。<strong>如果socket缓冲区满了，应用程序没来得及处理在缓冲区中的UDP包，那么后续来的UDP包会被内核丢弃，造成丢包。</strong>在socket缓冲区满造成丢包的情况下，可以通过增大缓冲区的方法来缓解UDP丢包问题。但是，如果服务已经过载了，简单的增大缓冲区并不能解决问题，反而会造成滚雪球效应，造成请求全部超时，服务不可用。</p>
<p><strong>作为对比，tcp 协议因为存在流量控制，所以更不容易出现socket缓冲区满的情况</strong></p>
<h3 id="UDP-socket缓冲区过小造成的UDP丢包："><a href="#UDP-socket缓冲区过小造成的UDP丢包：" class="headerlink" title="UDP socket缓冲区过小造成的UDP丢包："></a>UDP socket缓冲区过小造成的UDP丢包：</h3><p>如果Client发送的UDP报文很大，而socket缓冲区过小无法容下该UDP报文，那么该报文就会丢失。</p>
<h3 id="ARP缓存过期导致UDP丢包："><a href="#ARP缓存过期导致UDP丢包：" class="headerlink" title="ARP缓存过期导致UDP丢包："></a>ARP缓存过期导致UDP丢包：</h3><p>ARP 的缓存时间约10分钟，APR 缓存列表没有对方的 MAC 地址或缓存过期的时候，会发送 ARP 请求获取 MAC 地址，在没有获取到 MAC 地址之前，用户发送出去的 UDP 数据包会被内核缓存到 arp_queue 这个队列中，默认最多缓存3个包，多余的 UDP 包会被丢弃。</p>
<h2 id="UDP的冗余传输方案"><a href="#UDP的冗余传输方案" class="headerlink" title="UDP的冗余传输方案"></a>UDP的冗余传输方案</h2><p>在外网通信链路不稳定的情况下，有什么办法可以降低UDP的丢包率呢？一个简单的办法来采用冗余传输的方式。如下图，一般采用较多的是延时双发，双发指的是将原本单发的前后连续的两个包合并成一个大包发送，这样发送的数据量是原来的两倍。这种方式提高丢包率的原理比较简单，例如本例的冗余发包方式，在偶数包全丢的情况下，依然能够还原出完整的数据，也就是在这种情况下，50%的丢包率，依然能够达到100%的数据接收。</p>
<p><img src="https://pic1.zhimg.com/80/v2-d333829c32143757758102ece0b262f8_720w.jpg"></p>
<h2 id="UDP真的比TCP要高效吗"><a href="#UDP真的比TCP要高效吗" class="headerlink" title="UDP真的比TCP要高效吗"></a>UDP真的比TCP要高效吗</h2><p>相信很多同学都认为UDP无连接，无需重传和处理确认，UDP比较高效。然而UDP在大多情况下并不一定比TCP高效，TCP发展至今天，为了适应各种复杂的网络环境，其算法已经非常丰富，协议本身经过了很多优化，如果能够合理配置TCP的各种参数选项，那么在多数的网络环境下TCP是要比UDP更高效的。</p>
<p>影响UDP高效因素有以下3点。</p>
<h3 id="1-无法智能利用空闲带宽导致资源利用率低："><a href="#1-无法智能利用空闲带宽导致资源利用率低：" class="headerlink" title="(1) 无法智能利用空闲带宽导致资源利用率低："></a>(1) 无法智能利用空闲带宽导致资源利用率低：</h3><p>一个简单的事实是UDP并不会受到MTU的影响，MTU只会影响下层的IP分片，对此UDP一无所知。在极端情况下，UDP每次都是发小包，包是MTU的几百分之一，这样就造成UDP包的有效数据占比较小(UDP头的封装成本)；或者，UDP每次都是发巨大的UDP包，包大小MTU的几百倍，这样会造成下层IP层的大量分片，大量分片的情况下，其中某个分片丢失了，就会导致整个UDP包的无效。由于网络情况是动态变化的，UDP无法根据变化进行调整，发包过大或过小，从而导致带宽利用率低下，有效吞吐量较低。而TCP有一套智能算法，当发现数据必须积攒的时候，就说明此时不积攒也不行，TCP的复杂算法会在延迟和吞吐量之间达到一个很好的平衡。</p>
<h3 id="2-无法动态调整发包："><a href="#2-无法动态调整发包：" class="headerlink" title="(2) 无法动态调整发包："></a>(2) 无法动态调整发包：</h3><p><strong>由于UDP没有确认机制，没有流量控制和拥塞控制</strong>，这样在网络出现拥塞或通信两端处理能力不匹配的时候，UDP并不会进行调整发送速率，从而导致大量丢包。在丢包的时候，不合理的简单重传策略会导致重传风暴，进一步加剧网络的拥塞，从而导致丢包率雪上加霜。</p>
<h3 id="3-改进UDP的成本较高："><a href="#3-改进UDP的成本较高：" class="headerlink" title="(3) 改进UDP的成本较高："></a>(3) 改进UDP的成本较高：</h3><p>可能有同学想到针对UDP的一些缺点，在用户态做些调整改进，添加上简单的重传和动态发包大小优化。然而，这样的改进并不简单的，UDP编程可是比TCP要难不少的，考虑到改造成本，为什么不直接用TCP呢？</p>
<h2 id="UDP协议的正确使用场合"><a href="#UDP协议的正确使用场合" class="headerlink" title="UDP协议的正确使用场合"></a>UDP协议的正确使用场合</h2><h3 id="高通信实时性要求和低持续性要求的场景下"><a href="#高通信实时性要求和低持续性要求的场景下" class="headerlink" title="高通信实时性要求和低持续性要求的场景下"></a>高通信实时性要求和低持续性要求的场景下</h3><p>对于<strong>短连接通信，一方面如果业务只需要发一两个包并且对丢包有一定的容忍度</strong>，同时业务自己有简单的轮询或重复机制，那么采用UDP会较为好些。在这样的场景下，如果用TCP，仅仅握手就需要3个包，这样显然有点不划算，一个典型的例子是DNS查询。</p>
<p>另一方面，如果业务<strong>实时性要求非常高</strong>，并且不能忍受重传，那么首先就是UDP了或者只能用UDP了</p>
<h3 id="多点通信的场景下"><a href="#多点通信的场景下" class="headerlink" title="多点通信的场景下"></a>多点通信的场景下</h3><p>对于一些多点通信的场景，如果采用有连接的TCP，那么就需要和多个通信节点建立其双向连接，然后有时在NAT环境下，两个通信节点建立其直接的TCP连接不是一个容易的事情，在涉及NAT穿越的时候，UDP协议的无连接性使得穿透成功率更高（原因详见：由于UDP的无连接性，那么其完全可以向一个组播地址发送数据或者轮转地向多个目的地持续发送相同的数据，从而更为容易实现多点通信。）</p>
<p>一个典型的场景是多人实时音视频通信，这种场景下实时性要求比较高，可以容忍一定的丢包率。比如：对于音频，对端连续发送p1、p2、p3三个包，另一端收到了p1和p3，在没收到p2的保持p1的最后一个音（也是为什么有时候网络丢包就会听到嗞嗞嗞嗞嗞嗞…或者卟卟卟卟卟卟卟卟…重音的原因），等到到p3就接着播p3了，不需要也不能补帧，一补就越来越大的延时。对于这样的场景就比较合适用UDP了，如果采用TCP，那么在出现丢包的时候，就可能会出现比较大的延时。</p>
<h2 id="UDP的使用原则小结"><a href="#UDP的使用原则小结" class="headerlink" title="UDP的使用原则小结"></a>UDP的使用原则小结</h2><ul>
<li>实时性要求很高，并且几乎不能容忍重传：<ul>
<li>例子：NTP协议，实时音视频通信，多人动作类游戏中人物动作、位置。</li>
</ul>
</li>
<li>TCP实在不方便实现多点传输的情况；</li>
<li>需要进行NAT穿越；</li>
<li>对网络状态很熟悉，确保udp网络中没有氓流行为，疯狂抢带宽；</li>
<li>熟悉UDP编程。</li>
</ul>
<h2 id="UDP-小结"><a href="#UDP-小结" class="headerlink" title="UDP 小结"></a>UDP 小结</h2><ul>
<li>UDP 是无连接的，即发送数据之前不需要建立连接(发送数据结束时也没有连接可释放)，减少了开销和发送数据之前的时延</li>
<li>UDP 使用尽最大努力交付，即不保证可靠交付，主机不需要维持复杂的连接状态表</li>
<li>UDP 是面向报文的，发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界</li>
<li>UDP <code>没有拥塞控制</code>，网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的</li>
<li>UDP 支持一对一、一对多、多对一和多对多的交互通信</li>
<li>UDP 的<code>首部开销小</code>，只有8个字节，比 TCP 的20个字节的首部要短</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/101552588">原文：不为人知的UDP：深入地理解UDP协议并用好它</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/64154915">udp协议-看这篇就够了</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/07/http/tcp%E4%B9%8Btcp%E5%92%8Cudp%E5%8D%8F%E8%AE%AE%E5%AF%B9%E6%AF%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/07/http/tcp%E4%B9%8Btcp%E5%92%8Cudp%E5%8D%8F%E8%AE%AE%E5%AF%B9%E6%AF%94/" class="post-title-link" itemprop="url">tcp之tcp和udp协议的对比</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-07 17:20:19" itemprop="dateCreated datePublished" datetime="2020-02-07T17:20:19+08:00">2020-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="七层模型"><a href="#七层模型" class="headerlink" title="七层模型"></a>七层模型</h2><table>
<thead>
<tr>
<th>层</th>
<th>功能</th>
<th>协议</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>网络服务与最终用户的一个接口。</td>
<td>HTTP,  FTP, SMTP, websocket</td>
</tr>
<tr>
<td>表示层</td>
<td>数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）</td>
<td></td>
</tr>
<tr>
<td>会话层</td>
<td>建立、管理、终止会话。（在五层模型里面已经合并到了应用层）</td>
<td></td>
</tr>
<tr>
<td>传输层</td>
<td>定义传输数据的协议端口号，以及流控和差错校验。</td>
<td>TCP, UDP</td>
</tr>
<tr>
<td>网络层</td>
<td>进行逻辑地址寻址，实现不同网络之间的路径选择。</td>
<td>ICMP, IP</td>
</tr>
<tr>
<td>数据链路层</td>
<td>建立逻辑连接、进行硬件地址寻址、差错校验等功能。</td>
<td></td>
</tr>
<tr>
<td>物理层</td>
<td>建立、维护、断开物理连接。</td>
<td></td>
</tr>
</tbody></table>
<p>数据在网络上传输，通过网络层的IP地址找到目标主机，通过传输层的端口号定位目标主机上的服务(应用程序)。</p>
<h2 id="TCP（TCP可靠性）"><a href="#TCP（TCP可靠性）" class="headerlink" title="TCP（TCP可靠性）"></a>TCP（TCP可靠性）</h2><p>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<p><strong>可靠性</strong>：TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个<strong>相应的确认（ACK）</strong>；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据（假设丢失了）将会被<strong>重传</strong>。</p>
<p>TCP如何保证可靠的传输层：<strong>TCP在数据传输之前有三次握手来建立连接，并且在数据传递时，有确认、重传、流量控制、拥塞控制，在数据传输完之后，还会断开连接用来节约系统资源， 其中确认，重传，流量控制以及报文排序都是基于 syn 的设计来实现的</strong></p>
<p>TCP 会保证每一个报文都能够抵达对方，它的机制是这样：报文发出去后，必须接收到对方返回的确认报文 ACK，如果迟迟未收到，就会超时重发该报文，直到收到对方的 ACK 为止。<strong>所以，TCP 报文发出去后，并不会立马从内存中删除，因为重传时还需要用到它。</strong>由于 TCP 是内核维护的，所以报文存放在内核缓冲区。如果连接非常多，我们可以通过 free 命令观察到 <code>buff/cache</code> 内存是会增大。</p>
<h3 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h3><p>TCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。发送过的数据未收到确认之前必须保留，以便超时重传时使用。发送窗口没收到确认前不动，收到新的确认前移</p>
<p><strong>发送缓存</strong>用来暂时存放： 发送应用程序传送给发送方 TCP 准备发送的数据；TCP 已发送出但尚未收到确认的数据。</p>
<p><strong>接收缓存</strong>用来暂时存放：按序到达的、但尚未被接收应用程序读取的数据； 不按序到达的数据。<br>必须强调三点：</p>
<ul>
<li>A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。</li>
<li>TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。</li>
<li>TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销</li>
</ul>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>用户数据报协议（UDP，User Datagram Protocol）为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据报的方法。</p>
<p>在选择UDP作为传输协议时必须要谨慎。在网络质量令人十分不满意的环境下，UDP协议数据包丢失会比较严重。但是由于UDP的特性：它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p>
<h2 id="TCP-和-UDP-对比"><a href="#TCP-和-UDP-对比" class="headerlink" title="TCP 和 UDP 对比"></a>TCP 和 UDP 对比</h2><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td align="left">连接</td>
<td align="left">面向连接</td>
<td>无连接</td>
</tr>
<tr>
<td align="left">传输双方</td>
<td align="left">一对一，所以必须要提前建立连接，只支持单播</td>
<td>一对一、一对多、一对全都可以，即支持单播、广播、全播。</td>
</tr>
<tr>
<td align="left">传输可靠性</td>
<td align="left">可靠</td>
<td>不可靠</td>
</tr>
<tr>
<td align="left">传输形式</td>
<td align="left">字节流，仅把应用进程交下来的报文当作一连串的字节流，然后对这些字节流进行分组、编号、发送</td>
<td>数据报文段（UDP对应用进程交下来的报文既不合并、也不会拆分，而是保留这些报文的边界）</td>
</tr>
<tr>
<td align="left">应用场景</td>
<td align="left">要求通信数据可靠（比如文件传输、邮件传输）</td>
<td>要求实时性强，且对丢数据有一定容忍性</td>
</tr>
<tr>
<td align="left">提供服务</td>
<td align="left">可以向上层提供面向连接可靠服务，不会出现误码、丢失。</td>
<td>接收方不需要发送ack，发送方也不关系ack</td>
</tr>
<tr>
<td align="left">性能</td>
<td align="left">传输效率：慢<br>所需资源：多</td>
<td>传输效率：快<br>所需资源：少</td>
</tr>
</tbody></table>
<ul>
<li>TCP提供面向连接的服务，在传送数据之前必须先建立连接，数据传输结束之后要释放连接，TCP不提供多播和广播。并且由于TCP提供可靠的、面向连接的运输服务，这些难免会增加系统的开销，如确认，流量控制，计时器以及连接管理，使得首部字节增大很多，还需要占用很多的处理机资源。TCP一般用于文件传输、发送和接受邮件、远程登陆等场景。</li>
<li>UDP传输数据之前不需要先建立连接，<strong>远地主机在收到UDP报文后，不需要给出任何确认</strong>，远地主机假如发现UDP报文段出错，<strong>直接丢弃，也不需要给发送主机返回消息</strong>。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>百度百科</p>
<p>计算机网络-TCP和UDP的区别： <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021688094">https://segmentfault.com/a/1190000021688094</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/07/http/tcp%E4%B9%8B%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/07/http/tcp%E4%B9%8B%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">tcp之的流量控制和拥塞控制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-07 17:20:19" itemprop="dateCreated datePublished" datetime="2020-02-07T17:20:19+08:00">2020-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能承受现有的网络负荷。</p>
<p>流量控制往往指的是点对点通信量的控制，是个端到端的问题。流量控制所要做的就是控制发送端发送数据的速率，以便使接收端来得及接受。</p>
<h3 id="拥塞控制和流量控制的区别"><a href="#拥塞控制和流量控制的区别" class="headerlink" title="拥塞控制和流量控制的区别"></a>拥塞控制和流量控制的区别</h3><p>流量控制是点到点的问题，一对一，如果接收方的数据来不及接收那么就能直接找到发送方这个罪魁祸首，<code>主要是因为接收方来不及接受发送方的数据</code>；</p>
<p>拥塞控制是多对一，一个接收方 面对多个发送方出现了网络拥堵，接收方找不到具体的发送方，<code>主要是因为网络发生了堵塞发送方数据迟迟到不了接收方</code>。</p>
<h2 id="接收窗口-rwnd-和发送窗口（min-rwnd，cwnd-）"><a href="#接收窗口-rwnd-和发送窗口（min-rwnd，cwnd-）" class="headerlink" title="接收窗口 rwnd 和发送窗口（min(rwnd，cwnd)）"></a>接收窗口 rwnd 和发送窗口（min(rwnd，cwnd)）</h2><p>接收窗口receiver window(即rwnd)，是<code>接收方</code>根据自己的承受能力设置的接收缓存值大小，反映了接收方的接收能力，<code>来做流量控制</code>。</p>
<p>拥塞窗口congestion window(即cwnd)，是<code>发送方</code>根据网络拥塞程度设置的网络窗口值，发送窗口&#x3D;min(rwnd，cwnd)即是接收窗口和拥塞窗口的最小值，<code>来做拥塞控制</code>。</p>
<h2 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h2><h3 id="停止等待协议，连续ARQ协议和滑动窗口协议"><a href="#停止等待协议，连续ARQ协议和滑动窗口协议" class="headerlink" title="停止等待协议，连续ARQ协议和滑动窗口协议"></a>停止等待协议，连续ARQ协议和滑动窗口协议</h3><h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4><p>停止等待协议是tcp保证传输可靠的重要途径,”停止等待”就是指发送完一个分组就停止发送,等待对方的确认,只有对方确认过,才发送下一个分组.</p>
<p>停止等待协议的优点是简单,但是缺点是信道的利用率太低,一次发送一条消息,使得信道的大部分时间内都是空闲的,为了提高效率,我们采用流水线传输,这就与下面两个协议有关系了.</p>
<h4 id="连续ARQ协议和滑动窗口协议"><a href="#连续ARQ协议和滑动窗口协议" class="headerlink" title="连续ARQ协议和滑动窗口协议"></a>连续ARQ协议和滑动窗口协议</h4><p>这两个协议主要起到解决信道效率低的问题，增大了吞吐量,以及控制流量的作用.</p>
<ul>
<li>连续ARQ协议:它是指发送方维护着一个窗口,这个窗口中不止一个分组,有好几个分组,窗口的大小是由接收方返回的win值决定的,所以窗口的大小是动态变化的,只要在窗口中的分组都可以被发送,这就使得TCP一次不是只发送一个分组了,从而大大提高了信道的利用率.并且它采用累积确认的方式,对于<strong>按序</strong>到达的最后一个分组发送确认.</li>
<li>滑动窗口协议:之所以叫滑动窗口协议,是因为窗口是不断向前走的,该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输,还可以控制流量的问题.</li>
<li>累积确认:如果发送方发送了5个分组,接收方只收到了1,2,4,5,没有收到3分组,那么我的确认信息只会说我期望下一个收到的分组是第三个,此时发送方会将3,4,5,全部重发一次,当通信质量不是很好的时候,连续ARQ还是会带来负面影响.</li>
</ul>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>所谓的流量控制就是让发送方的发送速率不要太快，让接收方来得及接受。利用滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制。</p>
<p>TCP的窗口单位是字节，不是报文段，发送方的发送窗口不能超过接收方给出的接收窗口的数值。</p>
<p>原理这就是<strong>运用TCP报文段中的窗口大小字段来控制，发送方的发送窗口不可以大于接收方发回的窗口大小。</strong></p>
<h3 id="零窗口"><a href="#零窗口" class="headerlink" title="零窗口"></a>零窗口</h3><p>只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器，若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。</p>
<p>注意：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段</p>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p> 在某段时间，若对网络中的某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变化，这种情况叫做拥塞。</p>
<p><code>拥塞控制的目的</code>就是防止过多的数据注入到网络中，网络堵塞使得包一直到不了接收端。</p>
<p>因特网建议标准RFC2581定义了进行拥塞控制的四种算法，即慢开始（Slow-start)，拥塞避免（Congestion Avoidance)，快重传（Fast Restrangsmit)和快恢复（Fast Recovery）。我们假定</p>
<ul>
<li><p>数据是单方向传送，而另外一个方向只传送确认。</p>
</li>
<li><p>接收方总是有足够大的缓存空间，因为发送窗口的大小由网络的拥塞程度来决定。</p>
</li>
</ul>
<p>拥塞控制算法有四种：</p>
<ol>
<li>慢开始</li>
<li>拥塞避免</li>
<li>快重传</li>
<li>快恢复</li>
</ol>
<h3 id="拥塞控制的流程"><a href="#拥塞控制的流程" class="headerlink" title="拥塞控制的流程"></a>拥塞控制的流程</h3><p><img src="https://s3.ax1x.com/2021/01/20/sWhJXT.png"></p>
<h4 id="慢启动原理"><a href="#慢启动原理" class="headerlink" title="慢启动原理"></a>慢启动原理</h4><ul>
<li>当主机开始发送数据时，如果立即将较大的发送窗口的全部数据字节都注入到网络中，那么由于不清楚网络的情况，有可能引其网络拥塞。</li>
<li>比较好的方法是试探一下，即从小到达逐渐增大发送端的拥塞控制窗口数值。</li>
<li>通常在刚刚开始发送报文段时可先将拥塞窗口cwnd(拥塞窗口)设置为一个最大报文段的MSS的数值。在每收到一个对新报文段确认后，将拥塞窗口增加至多一个MSS的数值，当rwind（接收窗口）足够大的时候</li>
<li>为了防止拥塞窗口cwind的增长引起网络拥塞，还需要另外一个变量—慢开始门限ssthresh</li>
</ul>
<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><ul>
<li><p>TCP连接初始化，将拥塞窗口设置为1</p>
</li>
<li><p>执行 <strong>慢开始算法：</strong>cwind按指数规律增长，直到cwind &#x3D;&#x3D; ssthress开始执行 <strong>拥塞避免算法：</strong>cwnd按线性规律增长</p>
</li>
<li><p>当网络发生拥塞，把ssthresh值更新为拥塞前ssthresh值的一半，cwnd重新设置为1，按照拥塞避免算法继续执行。</p>
</li>
</ul>
<h4 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h4><p>从图可以看到，Reno版本相对 Tahoe版本，主要是调整了跳崖式降低发送速率这个地方，如果从0开始效率太低了，如果是男女朋友间在发送微信岂不是被折磨的心痒痒。</p>
<p>拥塞窗口cwnd每次指数增长一次都是在收到了确认报文的情况下增长的，比如A发送1，2，3，4，5，6这些报文段，2丢失了，1345都收到了那么每次345收到都会给A发送确认1收到了的确认报文，让他发2（这个地方上一篇有提到），这种算法就是在2的超时计时器到期之前收到了三个确认之后就马上重传2，接收方都催着要了哥，后面三个确认包都到了说明网络很好的嘛就是你迷路了，因此进行快速重传还是将新的ssthresh值调低为原来拥塞时候的一半又开始线性增长。</p>
<h5 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h5><p> <strong>快重传算法</strong>并非取消了<strong>重传机制</strong>，只是在某些情况下更早的重传丢失的报文段（如果当发送端接收到三个重复的确认ACK时，则断定分组丢失，立即重传丢失的报文段，而不必等待重传计时器超时）。</p>
<p>例如：M1，M2，M3 —–&gt; M1,M3,缺失M2，则接收方向发送方持续发送M2重复确认，当发送方收到M2的三次重复确认，则认为M2报文丢失，启动快重传机制，重传数据，其他数据发送数据放入队列，待快重传结束后再正常传输。</p>
<h5 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h5><p><strong>快恢复算法</strong>有以下两个要点：</p>
<ul>
<li>当发送方连续收到接收方发来的三个重复确认时，就执行“乘法减小”算法，把慢开始门限减半，这是为了预防网络发生拥塞。</li>
<li>由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是把<strong>cwnd(拥塞窗口)<strong>值设置为慢开始门限减半后的值，然后开始执行拥塞避免算法</strong>，使拥塞窗口的线性增大</strong>。</li>
</ul>
<h2 id="超时重传（重传机制）"><a href="#超时重传（重传机制）" class="headerlink" title="超时重传（重传机制）"></a>超时重传（重传机制）</h2><p>超时重传是TCP协议保证数据可靠性的另一个重要机制，其原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据，直到发送成功为止。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://my.oschina.net/manmao/blog/601585">https://my.oschina.net/manmao/blog/601585</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1632783">https://cloud.tencent.com/developer/article/1632783</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43584807/article/details/93800480">https://blog.csdn.net/weixin_43584807/article/details/93800480</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/04/concurrent%20and%20gc/%E5%B9%B6%E5%8F%91%E4%B9%8B%20Golang%20channel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/04/concurrent%20and%20gc/%E5%B9%B6%E5%8F%91%E4%B9%8B%20Golang%20channel/" class="post-title-link" itemprop="url">并发之 golang channel</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-04 20:26:56" itemprop="dateCreated datePublished" datetime="2020-02-04T20:26:56+08:00">2020-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Go语言设计团队的首任负责人<em>Rob Pike</em>对并发编程的一个建议是<strong>不要让计算通过共享内存来通讯，而应该让它们通过通讯来共享内存</strong>。 通道机制就是这种哲学的一个设计结果。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L32"><code>runtime.hchan</code></a>  表示 channel 结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="type">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">	dataqsiz <span class="type">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">	buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">	elemsize <span class="type">uint16</span></span><br><span class="line">	closed   <span class="type">uint32</span></span><br><span class="line">	elemtype *_type <span class="comment">// element type</span></span><br><span class="line">	sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line">	recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">	recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">	sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">	<span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">	<span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">	<span class="comment">// with stack shrinking.</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *sudog</span><br><span class="line">	last  *sudog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// The following fields are protected by the hchan.lock of the</span></span><br><span class="line">	<span class="comment">// channel this sudog is blocking on. shrinkstack depends on</span></span><br><span class="line">	<span class="comment">// this for sudogs involved in channel ops.</span></span><br><span class="line"></span><br><span class="line">	g *g</span><br><span class="line"></span><br><span class="line">	<span class="comment">// isSelect indicates g is participating in a select, so</span></span><br><span class="line">	<span class="comment">// g.selectDone must be CAS&#x27;d to win the wake-up race.</span></span><br><span class="line">	isSelect <span class="type">bool</span></span><br><span class="line">	next     *sudog</span><br><span class="line">	prev     *sudog</span><br><span class="line">    <span class="comment">// ...其他字段省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>qcount</code> — Channel 中的元素个数；</li>
<li><code>dataqsiz</code> — Channel 中的循环队列的长度；</li>
<li><code>buf</code> — Channel 的缓冲区数据指针；</li>
<li><code>sendx</code> — Channel 的发送操作处理到的位置；</li>
<li><code>recvx</code> — Channel 的接收操作处理到的位置；</li>
<li><code>sendq</code> 和 <code>recvq</code> 存储了当前 Channel 由于缓冲区空间不足而阻塞的 Goroutine 列表，这些等待队列使用双向链表 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L53"><code>runtime.waitq</code></a> 表示，链表中所有的元素都是 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/895b7c85addfffe19b66d8ca71c31799d6e55990/src/runtime/runtime2.go#L342"><code>runtime.sudog</code></a> 结构：</li>
</ul>
<h2 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h2><p>makechan 是 创建管道最终调用的函数。makechan64 先不考虑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">	elem := t.elem</span><br><span class="line"></span><br><span class="line">	<span class="comment">// compiler checks this but be safe.</span></span><br><span class="line">	<span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">		throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mem, overflow := math.MulUintptr(elem.size, <span class="type">uintptr</span>(size))</span><br><span class="line">	<span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.</span></span><br><span class="line">	<span class="comment">// buf points into the same allocation, elemtype is persistent.</span></span><br><span class="line">	<span class="comment">// SudoG&#x27;s are referenced from their owning thread so they can&#x27;t be collected.</span></span><br><span class="line">	<span class="comment">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span></span><br><span class="line">	<span class="keyword">var</span> c *hchan</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line">		<span class="comment">// Queue or element size is zero.</span></span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">		<span class="comment">// Race detector uses this location for synchronization.</span></span><br><span class="line">		c.buf = c.raceaddr()</span><br><span class="line">	<span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>:</span><br><span class="line">		<span class="comment">// Elements do not contain pointers.</span></span><br><span class="line">		<span class="comment">// Allocate hchan and buf in one call.</span></span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        <span class="comment">// 在 hchan 结构的内存后面分配一片底层数组的内存空间，内存连续</span></span><br><span class="line">		c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// Elements contain pointers.</span></span><br><span class="line">		c = <span class="built_in">new</span>(hchan)</span><br><span class="line">		c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.elemsize = <span class="type">uint16</span>(elem.size)</span><br><span class="line">	c.elemtype = elem</span><br><span class="line">	c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugChan &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;makechan: chan=&quot;</span>, c, <span class="string">&quot;; elemsize=&quot;</span>, elem.size, <span class="string">&quot;; elemalg=&quot;</span>, elem.alg, <span class="string">&quot;; dataqsiz=&quot;</span>, size, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果当前 Channel 中不存在缓冲区，那么就只会为 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L32"><code>runtime.hchan</code></a> 分配一段内存空间；</li>
<li>如果当前 Channel 中存储的类型不是指针类型，就会为当前的 Channel 和底层的数组分配一块连续的内存空间；</li>
<li>在默认情况下会单独为 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L32"><code>runtime.hchan</code></a> 和缓冲区分配内存；</li>
</ul>
<h2 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h2><p>当我们想要向 Channel 发送数据时，就需要使用 <code>ch &lt;- i</code> 语句，编译器会将它解析成 <code>OSEND</code> 节点并在 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/walk.go#L439"><code>cmd/compile/internal/gc.walkexpr</code></a> 函数中转换成 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L126"><code>runtime.chansend1</code></a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L126"><code>runtime.chansend1</code></a> 只是调用了 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L142"><code>runtime.chansend</code></a> 并传入 Channel 和需要发送的数据。<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L142"><code>runtime.chansend</code></a> 是向 Channel 中发送数据时最终会调用的函数，这个函数负责了发送数据的全部逻辑，如果我们在调用时将 <code>block</code> 参数设置成 <code>true</code>，那么就表示当前发送操作是一个阻塞操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 直接发送</span></span><br><span class="line">    <span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line">		<span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">		send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送到缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">		<span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">		qp := chanbuf(c, c.sendx)</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">		&#125;</span><br><span class="line">		typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">		c.sendx++</span><br><span class="line">		<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">			c.sendx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount++</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不阻塞的发送(select)</span></span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送协程阻塞</span></span><br><span class="line">	<span class="comment">// Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">	<span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.isSelect = <span class="literal">false</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 当前协程如发送队列</span></span><br><span class="line">	c.sendq.enqueue(mysg)</span><br><span class="line">    <span class="comment">// 将当前的 Goroutine 陷入沉睡等待唤醒</span></span><br><span class="line">	goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line">	<span class="comment">// Ensure the value being sent is kept alive until the</span></span><br><span class="line">	<span class="comment">// receiver copies it out. The sudog has a pointer to the</span></span><br><span class="line">	<span class="comment">// stack object, but sudogs aren&#x27;t considered as roots of the</span></span><br><span class="line">	<span class="comment">// stack tracer.</span></span><br><span class="line">	KeepAlive(ep)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在发送数据的逻辑执行之前会先为当前 Channel 加锁，防止发生竞争条件。如果 Channel 已经关闭，那么向该 Channel 发送数据时就会报<code>&quot;send on closed channel&quot;</code> 错误并中止程序。</p>
<p>因为 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L142"><code>runtime.chansend</code></a> 函数的实现比较复杂，所以我们这里将该函数的执行过程分成以下的三个部分：</p>
<ul>
<li>当存在等待的接收者时，通过 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L270"><code>runtime.send</code></a> 直接将数据发送给阻塞的接收者；</li>
<li>当缓冲区存在空余空间时，将发送的数据写入 Channel 的缓冲区；</li>
<li>当不存在缓冲区或者缓冲区已满时，等待其他 Goroutine 从 Channel 接收数据；</li>
</ul>
<h3 id="直接发送"><a href="#直接发送" class="headerlink" title="直接发送"></a>直接发送</h3><p>如果目标 Channel 没有被关闭并且已经有处于读等待的 Goroutine，那么 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L142"><code>runtime.chansend</code></a> 函数会从接收队列 <code>recvq</code> 中取出最先陷入等待的 Goroutine 并直接向它发送数据：</p>
<h4 id="直接发送数据的过程"><a href="#直接发送数据的过程" class="headerlink" title="直接发送数据的过程"></a>直接发送数据的过程</h4><ol>
<li>调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L313"><code>runtime.sendDirect</code></a> 函数将发送的数据直接拷贝到 <code>x = &lt;-c</code> 表达式中变量 <code>x</code> 所在的内存地址上；</li>
<li>调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L313"><code>runtime.goready</code></a> 将等待接收数据的 Goroutine 标记成可运行状态 <code>Grunnable</code> 并把该 Goroutine 放到发送方所在的处理器的 <code>runnext</code> 上等待执行，该处理器在下一次调度时就会立刻唤醒数据的接收方；</li>
</ol>
<p>直接发送</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendDirect</span><span class="params">(t *_type, sg *sudog, src unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 省略...， 可以看到是直接 将 src 地址中的数据，拷贝到 dst 的内存地址上</span></span><br><span class="line">	memmove(dst, src, t.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>如果当前 Channel 的缓冲区未满，向 Channel 发送的数据会存储在 Channel 中 <code>sendx</code> 索引所在的位置并将 <code>sendx</code> 索引加一，由于这里的 <code>buf</code> 是一个<strong>循环数组</strong>，所以当 <code>sendx</code> 等于 <code>dataqsiz</code> 时就会重新回到数组开始的位置。</p>
<h3 id="阻塞发送"><a href="#阻塞发送" class="headerlink" title="阻塞发送"></a>阻塞发送</h3><ol>
<li>调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/stubs.go#L18"><code>runtime.getg</code></a> 获取发送数据使用的 Goroutine；</li>
<li>执行 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L320"><code>runtime.acquireSudog</code></a> 函数获取 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/895b7c85addfffe19b66d8ca71c31799d6e55990/src/runtime/runtime2.go#L342"><code>runtime.sudog</code></a> 结构体并设置这一次阻塞发送的相关信息，例如发送的 Channel、是否在 Select 控制结构中和待发送数据的内存地址等；</li>
<li>将刚刚创建并初始化的 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/895b7c85addfffe19b66d8ca71c31799d6e55990/src/runtime/runtime2.go#L342"><code>runtime.sudog</code></a> 加入发送等待队列，并设置到当前 Goroutine 的 <code>waiting</code>上，表示 Goroutine 正在等待该 <code>sudog</code> 准备就绪；</li>
<li>调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/proc.go#L309"><code>runtime.goparkunlock</code></a> 函数将当前的 Goroutine 陷入沉睡等待唤醒；</li>
<li>被调度器唤醒后会执行一些收尾工作，将一些属性置零并且释放 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/895b7c85addfffe19b66d8ca71c31799d6e55990/src/runtime/runtime2.go#L342"><code>runtime.sudog</code></a> 结构体；</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我们在这里可以简单梳理和总结一下使用 <code>ch &lt;- i</code> 表达式向 Channel 发送数据时遇到的几种情况：</p>
<ol>
<li>如果当前 Channel 的 <code>recvq</code> 上存在已经被阻塞的 Goroutine，那么会直接将数据发送给当前的 Goroutine 并将其设置成下一个运行的 Goroutine；</li>
<li>如果 Channel 存在缓冲区并且其中还有空闲的容量，我们就会直接将数据直接存储到当前缓冲区 <code>sendx</code> 所在的位置上；</li>
<li>如果不满足上面的两种情况，就会创建一个 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/895b7c85addfffe19b66d8ca71c31799d6e55990/src/runtime/runtime2.go#L342"><code>runtime.sudog</code></a> 结构并将其加入 Channel 的 <code>sendq</code>队列中，当前 Goroutine 也会陷入阻塞等待其他的协程从 Channel 接收数据；</li>
</ol>
<h2 id="接受数据"><a href="#接受数据" class="headerlink" title="接受数据"></a>接受数据</h2><p>我们接下来继续介绍 Channel 操作的另一方 — 数据的接收。Go 语言中可以使用两种不同的方式去接收 Channel 中的数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i &lt;- ch</span><br><span class="line">i, ok &lt;- ch</span><br></pre></td></tr></table></figure>

<p>接受数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// raceenabled: don&#x27;t need to check ep, as it is always on the stack</span></span><br><span class="line">	<span class="comment">// or is new memory allocated by reflect.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">		c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">		atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line">		<span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line">		<span class="comment">// and add sender&#x27;s value to the tail of the queue (both map to</span></span><br><span class="line">		<span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">		recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.isSelect = <span class="literal">false</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 接收的 g 入队等待</span></span><br><span class="line">	c.recvq.enqueue(mysg)</span><br></pre></td></tr></table></figure>

<p>如果当前 Channel 已经被关闭并且缓冲区中不存在任何的数据，那么就会清除 <code>ep</code> 指针中的数据并立刻返回。</p>
<p>除了上述两种特殊情况，使用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L422"><code>runtime.chanrecv</code></a> 从 Channel 接收数据时还包含以下三种不同情况：</p>
<ul>
<li>当存在等待的发送者时，通过 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L556"><code>runtime.recv</code></a> 直接从阻塞的发送者或者缓冲区中获取数据；</li>
<li>当缓冲区存在数据时，从 Channel 的缓冲区中接收数据；</li>
<li>当缓冲区中不存在数据时，等待其他 Goroutine 向 Channel 发送数据；</li>
</ul>
<h3 id="直接接收"><a href="#直接接收" class="headerlink" title="直接接收"></a>直接接收</h3><p>当 Channel 的 <code>sendq</code> 队列中包含处于等待状态的 Goroutine 时，该函数会取出队列头等待的 Goroutine，处理的逻辑和发送时相差无几，只是发送数据时调用的是 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L270"><code>runtime.send</code></a> 函数，而接收数据时使用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L556"><code>runtime.recv</code></a> 函数：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L556"><code>runtime.recv</code></a> 函数的实现比较复杂：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			racesync(c, sg)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// copy data from sender</span></span><br><span class="line">			recvDirect(c.elemtype, sg, ep)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Queue is full. Take the item at the</span></span><br><span class="line">		<span class="comment">// head of the queue. Make the sender enqueue</span></span><br><span class="line">		<span class="comment">// its item at the tail of the queue. Since the</span></span><br><span class="line">		<span class="comment">// queue is full, those are both the same slot.</span></span><br><span class="line">		qp := chanbuf(c, c.recvx)</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">			raceacquireg(sg.g, qp)</span><br><span class="line">			racereleaseg(sg.g, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// copy data from queue to receiver</span></span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// copy data from sender to queue</span></span><br><span class="line">		typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">		c.recvx++</span><br><span class="line">		<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">			c.recvx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">	&#125;</span><br><span class="line">	sg.elem = <span class="literal">nil</span></span><br><span class="line">	gp := sg.g</span><br><span class="line">	unlockf()</span><br><span class="line">	gp.param = unsafe.Pointer(sg)</span><br><span class="line">	<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">		sg.releasetime = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line">	goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 Channel 不存在缓冲区；<ol>
<li>调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L326"><code>runtime.recvDirect</code></a> 函数会将 Channel 发送队列中 Goroutine 存储的 <code>elem</code> 数据拷贝到目标内存地址中；</li>
</ol>
</li>
<li>如果 Channel 存在缓冲区；<ol>
<li>将队列中的数据拷贝到接收方的内存地址；</li>
<li>将发送队列头的数据拷贝到缓冲区中，释放一个阻塞的发送方；</li>
</ol>
</li>
</ul>
<h3 id="从发送队列中获取数据"><a href="#从发送队列中获取数据" class="headerlink" title="从发送队列中获取数据"></a>从发送队列中获取数据</h3><p>Channel 在缓冲区已经没有空间并且发送队列中存在等待的 Goroutine 时，运行 <code>&lt;-ch</code> 的执行过程 — 发送队列头的 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/895b7c85addfffe19b66d8ca71c31799d6e55990/src/runtime/runtime2.go#L342"><code>runtime.sudog</code></a> 结构中的元素会替换接收索引 <code>recvx</code> 所在位置的元素，原有的元素会被拷贝到接收数据的变量的内存空间上</p>
<h3 id="阻塞接收"><a href="#阻塞接收" class="headerlink" title="阻塞接收"></a>阻塞接收</h3><p>当 Channel 的发送队列中不存在等待的 Goroutine 并且缓冲区中也不存在任何数据时，从管道中接收数据的操作会变成阻塞操作，然而不是所有的接收操作都是阻塞的，与 <code>select</code> 语句结合使用时就可能会使用到非阻塞的接收操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不阻塞，直接返回</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>我们梳理一下从 Channel 中接收数据时可能会发生的五种情况：</p>
<ol>
<li>如果 Channel 为空，那么就会直接调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L287"><code>runtime.gopark</code></a> 挂起当前 Goroutine；</li>
<li>如果 Channel 已经关闭并且缓冲区没有任何数据，<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L422"><code>runtime.chanrecv</code></a> 函数会直接返回；</li>
<li>如果 Channel 的 <code>sendq</code> 队列中存在挂起的 Goroutine，就会将 <code>recvx</code> 索引所在的数据拷贝到接收变量所在的内存空间上并将 <code>sendq</code> 队列中 Goroutine 的数据拷贝到缓冲区；</li>
<li>如果 Channel 的缓冲区中包含数据就会直接读取 <code>recvx</code> 索引对应的数据；</li>
<li>在默认情况下会挂起当前的 Goroutine，将 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/895b7c85addfffe19b66d8ca71c31799d6e55990/src/runtime/runtime2.go#L342"><code>runtime.sudog</code></a> 结构加入 <code>recvq</code> 队列并陷入休眠等待调度器的唤醒；</li>
</ol>
<p>我们总结一下从 Channel 接收数据时，会触发 Goroutine 调度的两个时机：</p>
<ol>
<li>当 Channel 为空时；</li>
<li>当缓冲区中不存在数据并且也不存在数据的发送者时</li>
</ol>
<h2 id="关闭管道"><a href="#关闭管道" class="headerlink" title="关闭管道"></a>关闭管道</h2><p>编译器会将用于关闭管道的 <code>close</code> 关键字转换成 <code>OCLOSE</code> 节点以及 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L335"><code>runtime.closechan</code></a> 的函数调用。</p>
<p>当 Channel 是一个空指针或者已经被关闭时，Go 语言运行时都会直接 <code>panic</code> 并抛出异常：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数在最后会为所有被阻塞的 Goroutine 调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L313"><code>runtime.goready</code></a> 触发调度。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/">抄自GO 语言 channel实现精要</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/01/io/%E5%A5%97%E6%8E%A5%E5%AD%97%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-%E4%B8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/01/io/%E5%A5%97%E6%8E%A5%E5%AD%97%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-%E4%B8%8B/" class="post-title-link" itemprop="url">套接字和文件描述符-下</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-01 21:17:24" itemprop="dateCreated datePublished" datetime="2020-02-01T21:17:24+08:00">2020-02-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IO/" itemprop="url" rel="index"><span itemprop="name">IO</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>内核（kernel）利用文件描述符（file descriptor）来访问文件。文件描述符在形式上是非负整数，实际上是一个索引值。打开现存文件或新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。</p>
<p>Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I&#x2F;O操作的系统调用都会通过文件描述符。</p>
<h3 id="文件描述符的限制"><a href="#文件描述符的限制" class="headerlink" title="文件描述符的限制"></a>文件描述符的限制</h3><blockquote>
<p>用户级别的限制，单个进程的文件描述符：ulimit -n</p>
<p>系统级别的限制：cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max 或者 sysctl -a | grep -i “file-max”</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>文件描述符（File Descriptor）简介：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000009724931">https://segmentfault.com/a/1190000009724931</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/01/30/io/%E5%A5%97%E6%8E%A5%E5%AD%97%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-%E4%B8%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/io/%E5%A5%97%E6%8E%A5%E5%AD%97%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-%E4%B8%8A/" class="post-title-link" itemprop="url">套接字和文件描述符-上</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-30 20:38:29" itemprop="dateCreated datePublished" datetime="2020-01-30T20:38:29+08:00">2020-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IO/" itemprop="url" rel="index"><span itemprop="name">IO</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>套接字 Socket&#x3D;（IP地址：端口号），套接字的表示方法是点分十进制的IP地址后面写上端口号，中间用冒号或逗号隔开。每一个传输层连接唯一地被通信两端的两个端点（即两个套接字）所确定。基于linux一切皆文件的思想。一个套接字就是一个文件，sockfd（套接字文件描述符）就是一种文件描述符。</p>
<p>通过下面可知。服务端，在启动时，会创建一个套接字文件（<strong>监听套接字</strong>），系统返回一个套接字文件描述符。当服务端的accept()函数返回时，也就是当某一个客户端调用connect()时，这时。在服务端的主机上还会再生成一个套接字文件（<strong>已连接套接字</strong>），这个文件用于当前的服务端和客户端连接的信息传递。而服务端最开始创建的那个套接字文件，则是继续等待新的请求的到来。</p>
<p>从内核的角度来看，一个套接字就是通信的一个端点。一个连接由它两端的套接了地址唯一确定，这对套接字地址叫做套接字对（socket pair）。<strong>一个套接字对实际上是由两个已连接套接字构成</strong>。</p>
<h3 id="C-语言套接字编程"><a href="#C-语言套接字编程" class="headerlink" title="C 语言套接字编程"></a>C 语言套接字编程</h3><h4 id="创建套接字-socket-函数"><a href="#创建套接字-socket-函数" class="headerlink" title="创建套接字-socket()函数"></a>创建套接字-socket()函数</h4><p><strong>可以看到，文件描述符在编程中，就是用一个整数来表示！</strong></p>
<blockquote>
<p>int socket(int domain, int type, int protocol);</p>
</blockquote>
<p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor， 一般记为sockfd，它是一个int型的数值，相当于一个文件的引用），它唯一标识一个socket。</p>
<ul>
<li>domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li>
<li>type：指定socket类型。</li>
<li>protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。</li>
</ul>
<h4 id="绑定套接字-bind-函数"><a href="#绑定套接字-bind-函数" class="headerlink" title="绑定套接字-bind()函数"></a>绑定套接字-bind()函数</h4><blockquote>
<p>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p>
</blockquote>
<ul>
<li>sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。</li>
<li>addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同。<strong>端口号就是在这个参数中传入的</strong>。</li>
<li>addrlen：对应的是地址的长度。</li>
</ul>
<p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</p>
<h4 id="监听端口-listen-函数"><a href="#监听端口-listen-函数" class="headerlink" title="监听端口-listen()函数"></a>监听端口-listen()函数</h4><blockquote>
<p>int listen(int sockfd, int backlog);</p>
</blockquote>
<ul>
<li>sockfd：即socket描述字。</li>
<li>backlog: 设定等待连接的等待队列的长度。</li>
</ul>
<p>刚开始理解listen函数会有一个误区，就是认为其操作是在等在一个新的connect的到来，其实不是这样的，真正等待connect的是accept操作，listen的操作就是当有较多的client发起connect时，server端不能及时的处理已经建立的连接，这时就会将connect连接放在等待队列中缓存起来。这个等待队列的长度有listen中的backlog参数来设定。listen和accept函数是服务器模式特有的函数，客户端不需要这个函数。当listen运行成功时，返回0；运行失败时，返回值位-1。<strong>listen的主要作用是缓冲队列</strong>。</p>
<h4 id="接受请求-accept-函数"><a href="#接受请求-accept-函数" class="headerlink" title="接受请求-accept()函数"></a>接受请求-accept()函数</h4><blockquote>
<p>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</p>
</blockquote>
<ul>
<li>sockfd：即socket描述字。</li>
</ul>
<p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功（从阻塞状态返回），那么其返回值是由内核自动生成的一个全新的文件描述符，代表与返回客户的TCP连接。通过对该文件描述符操作，可以向client端发送和接收数据。同时之前socket创建的sockfd，则继续监听有没有新的连接到达本地端口。返回大于0的文件描述符则表示accept成功，否则失败。</p>
<h4 id="客户端连接-connect-函数"><a href="#客户端连接-connect-函数" class="headerlink" title="客户端连接-connect()函数"></a>客户端连接-connect()函数</h4><blockquote>
<p>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p>
</blockquote>
<p>客户端通过调用connect函数来建立与TCP服务器的连接。</p>
<p>connect函数的第一个参数即为</p>
<ul>
<li>sockfd：客户端的socket描述字，</li>
<li>addr：服务器的socket地址</li>
<li>addrlen：socket地址的长度。</li>
</ul>
<h4 id="数据处理-read-、write-等函数"><a href="#数据处理-read-、write-等函数" class="headerlink" title="数据处理-read()、write()等函数"></a>数据处理-read()、write()等函数</h4><blockquote>
<p>ssize_t read(int fd, void *buf, size_t count);</p>
<p>ssize_t write(int fd, const void *buf, size_t count);</p>
</blockquote>
<p>read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。</p>
<p>write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据(<strong>还要检查返回值的大小和需要写入数据的大小是否一致</strong>)。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。</p>
<h4 id="连接关闭-close-函数"><a href="#连接关闭-close-函数" class="headerlink" title="连接关闭-close()函数"></a>连接关闭-close()函数</h4><blockquote>
<p>int close(int fd);</p>
</blockquote>
<p>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。</p>
<h3 id="socket编程中的文件描述符-监听套接字和已连接套接字"><a href="#socket编程中的文件描述符-监听套接字和已连接套接字" class="headerlink" title="socket编程中的文件描述符-监听套接字和已连接套接字"></a>socket编程中的文件描述符-监听套接字和已连接套接字</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">socket()----&gt;</span><span class="language-bash">创建出 active_socket_fd (client_socket_fd)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不绑定端口，系统会随机绑定一个端口</span></span><br><span class="line"><span class="meta prompt_">bind()---&gt;</span><span class="language-bash">把active_socket_fd与ip,port绑定起来</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">connect()---&gt; </span><span class="language-bash">client_socket_fd 主动请求服务端的 listen_socket_fd</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">read()/write()----&gt;</span><span class="language-bash">读/写(client_socket_fd) socket io</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">close()----&gt;</span><span class="language-bash">关闭socket_fd</span></span><br></pre></td></tr></table></figure>

<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">socket()----&gt;</span><span class="language-bash">创建出 active_socket_fd</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">bind()---&gt;</span><span class="language-bash">把active_socket_fd与ip,port绑定起来</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">listen()----&gt;</span><span class="language-bash">active_socket_fd--&gt; listen_socket_fd 等待客户端的client_socket_fd来请求连接</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">accept()----&gt;</span><span class="language-bash">listen_socket_fd--&gt;connec_socket_fd 把监听socket转变为连接socket,用于建立连接购的读写数据</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">read()/write()----&gt;</span><span class="language-bash">读/写(connec_socket_fd) socket io</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">close()----&gt;</span><span class="language-bash">关闭socket_fd</span></span><br></pre></td></tr></table></figure>

<p>一开始socket函数, 不管在客户端还是在服务端, 创建的都是主动socket, 但是在服务端经过listen(), 后把其转变为listen_socket_fd(被动监听socket)。经过accept()后转变为connect_socket_fd(已连接socket)。在转变为connect_socket_fd之前, 都是同一个socket, 只不过是socket的状态改变了, 但是服务端经过accept()后返回的socket是新的socket, 用于连接后的read()&#x2F;write()。</p>
<p>可以说，服务端有两类socket（实际中不止两个）</p>
<ul>
<li>监听socket，用于监听新的连接的到来</li>
<li>已连接socket，用于和客户端交流</li>
</ul>
<p>客户端只要一类socket</p>
<ul>
<li>已连接socket，用于和客户端交流</li>
</ul>
<h4 id="为什么服务端有两类套接字"><a href="#为什么服务端有两类套接字" class="headerlink" title="为什么服务端有两类套接字"></a>为什么服务端有两类套接字</h4><p> 有了listen_socket_fd和connect_socket_fd后, 就可以专门用一listen_socket_fd负责响应客户端的请求, 每次新的connect_socket_fd专门负责当前这次连接的数据交互。<strong>主要是性能更好</strong>。</p>
<h3 id="socket中TCP的三次握手建立连接详解"><a href="#socket中TCP的三次握手建立连接详解" class="headerlink" title="socket中TCP的三次握手建立连接详解"></a>socket中TCP的三次握手建立连接详解</h3><p>当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。</p>
<h3 id="socket中TCP的四次握手释放连接详解"><a href="#socket中TCP的四次握手释放连接详解" class="headerlink" title="socket中TCP的四次握手释放连接详解"></a>socket中TCP的四次握手释放连接详解</h3><ul>
<li>某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；</li>
<li>另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li>
<li>一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；</li>
<li>接收到这个FIN的源发送端TCP对它进行确认。</li>
</ul>
<p>这样每个方向上都有一个FIN和ACK。</p>
<h4 id="服务器可以主动释放连接吗？"><a href="#服务器可以主动释放连接吗？" class="headerlink" title="服务器可以主动释放连接吗？"></a>服务器可以主动释放连接吗？</h4><p>答案肯定是可以的。从代码中可以看出，只要在服务端对已连接套接字调用close()方法就可以在服务端释放连接。这相当于上述socket中的4次握手中的后两步。</p>
<h3 id="监听队列-listen-queue-和溢出"><a href="#监听队列-listen-queue-和溢出" class="headerlink" title="监听队列(listen queue)和溢出"></a>监听队列(listen queue)和溢出</h3><blockquote>
<p>int listen(int sockfd, int backlog);</p>
</blockquote>
<p>backlog是一个参数，当用户没有足够快地调用accept(2)时，它控制内核将为新连接保留多少内存。</p>
<p>例如，假设您有一个阻塞的单线程HTTP服务器，每个HTTP请求大约需要100毫秒。在这种情况下，HTTP服务器将花费100毫秒处理每个请求，然后才能再次调用accept(2)。这意味着在最多10个 rps 的情况下不会有排队现象。如果内核中有10个以上的 rps，则有两个选择。</p>
<ul>
<li>内核的第一个选择是根本不接受连接。例如，内核可以拒绝对传入的SYN包进行ACK。更常见的情况是，内核将完成TCP三次握手，然后使用RST终止连接。不管怎样，结果都是一样的：如果连接被拒绝，就不需要分配接收或写入缓冲区。</li>
<li>内核的第二个选择是接受连接并为其分配一个<strong>套接字结构（包括接收&#x2F;写入缓冲区）</strong>，然后将套接字对象排队以备以后使用。下次用户调用accept(2)将立即获得已分配的套接字, 而不是阻塞系统调用。</li>
</ul>
<p>内核将会对新连接进行排队，但只是一定数量的连接。内核将排队的连接数量由listen(2)的backlog参数控制。通常此值设置为相对较小的值。在Linux上，socket.h 将 somaxconn 的值设置为128。</p>
<p>当监听队列填满时，新连接会被拒绝。这称为监听队列溢出。</p>
<h4 id="进程监听队列检查"><a href="#进程监听队列检查" class="headerlink" title="进程监听队列检查"></a>进程监听队列检查</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查在5000端口上的连接</span></span><br><span class="line">netstat -antp | grep 5000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只看处于listen状态的tcp套接字</span></span><br><span class="line">ss -tl</span><br><span class="line"></span><br><span class="line">-t：只显示tcp套接字；</span><br><span class="line">-l：显示处于监听状态的套接字；</span><br></pre></td></tr></table></figure>

<p>ss指令中的recv-q和send-q。LISTEN 状态: Recv-Q 表示的当前等待服务端调用 accept 完成三次握手的 listen backlog 数值，也就是说，当客户端通过 connect() 去连接正在 listen() 的服务端时，这些连接会一直处于这个 queue 里面直到被服务端 accept()；Send-Q 表示的则是最大的 listen backlog 数值，这就就是上面提到的 min(backlog, somaxconn) 的值。</p>
<p>所以线上的一个常见的问题就是（特别是想tornado这种非线程编程模型的框架），连接被拒绝。这个时候就果断的使用<code>ss -tl</code>查看一下进程的等待队列是否已经满了。 </p>
<h3 id="读语义和写语义"><a href="#读语义和写语义" class="headerlink" title="读语义和写语义"></a>读语义和写语义</h3><h4 id="读语义"><a href="#读语义" class="headerlink" title="读语义"></a>读语义</h4><p>读语义就是将内核接受缓冲区中的数据删除，并将该数据复制到进程调用read(2)函数时提供的缓冲区。</p>
<p>如果接收缓冲区为空，并且用户调用read(2)，则系统调用将被阻塞，直到数据可用。如果接收缓冲区是非空的，并且用户调用read(2)，系统调用将立即返回这些可用的数据。如果读取队列中准备好的数据量小于用户提供的缓冲区的大小，则可能发生部分读取。调用方可以通过检查read(2)的返回值来检测到这一点。如果接收缓冲区已满，而TCP连接的另一端尝试发送更多的数据，内核将拒绝对数据包进行ACK。</p>
<h4 id="写语义"><a href="#写语义" class="headerlink" title="写语义"></a>写语义</h4><p>写语义就是将用户提供的缓冲区中的数据复制到内核写入队列中。</p>
<p>如果写入队列未满，并且用户调用写入，则系统调用将成功。如果写入队列有足够的空间，则将复制所有数据。如果写入队列只有部分数据的空间，那么将发生部分写入，并且只有部分数据将被复制到缓冲区。调用方通过检查write(2)的返回值来检查这一点。如果写入队列已满，并且用户调用写入write(2)），则系统调用将被阻塞。</p>
<h4 id="走向互联网"><a href="#走向互联网" class="headerlink" title="走向互联网"></a>走向互联网</h4><p>我们平时用到的套接字其实只是一个引用(一个对象ID)，这个套接字对象实际上是放在操作系统内核中。这个套接字对象内部有两个重要的缓冲结构，一个是读缓冲(read buffer)，一个是写缓冲(write buffer)，它们都是有限大小的数组结构。</p>
<p>当我们对客户端的socket写入字节数组时(序列化后的请求消息对象req)，是将字节数组拷贝到内核区套接字对象的write buffer中，内核网络模块会有单独的线程负责不停地将write buffer的数据拷贝到网卡硬件，网卡硬件再将数据送到网线，经过一些列路由器交换机，最终送达服务器的网卡硬件中。</p>
<p>同样，服务器内核的网络模块也会有单独的线程不停地将收到的数据拷贝到套接字的read buffer中等待用户层来读取。最终服务器的用户进程通过socket引用的read方法将read buffer中的数据拷贝到用户程序内存中进行反序列化成请求对象进行处理。然后服务器将处理后的响应对象走一个相反的流程发送给客户端，这里就不再具体描述。</p>
<p><img src="https://s2.ax1x.com/2020/02/02/1JcI0A.gif" alt="简单动画"></p>
<h3 id="如何查看一个进程的所有文件描述符"><a href="#如何查看一个进程的所有文件描述符" class="headerlink" title="如何查看一个进程的所有文件描述符"></a>如何查看一个进程的所有文件描述符</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 获取进程<span class="built_in">id</span>(ps -ef | grep ...)，如我这里是 22380</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 查看进程级别限制， 实际上这里还能查到进程数限制等</span></span><br><span class="line">cat /proc/22380/limits | grep &quot;open file&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 查看进程使用的文件描述符</span></span><br><span class="line">ls /proc/22380/fd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. 计数</span></span><br><span class="line">ls /proc/22380/fd| wc -l</span><br></pre></td></tr></table></figure>

<h4 id="新增一个连接后会，新建一个socket文件（也就多了一个文件描述符）"><a href="#新增一个连接后会，新建一个socket文件（也就多了一个文件描述符）" class="headerlink" title="新增一个连接后会，新建一个socket文件（也就多了一个文件描述符）"></a>新增一个连接后会，新建一个socket文件（也就多了一个文件描述符）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./server 启动后，只会有一个负责监听额socket文件</span></span><br><span class="line">dr-x------ 2 root root  0 Feb  1 13:37 ./</span><br><span class="line">dr-xr-xr-x 9 root root  0 Feb  1 13:37 ../</span><br><span class="line">lrwx------ 1 root root 64 Feb  1 13:37 0 -&gt; /dev/pts/3</span><br><span class="line">lrwx------ 1 root root 64 Feb  1 13:37 1 -&gt; /dev/pts/3</span><br><span class="line">lrwx------ 1 root root 64 Feb  1 13:37 2 -&gt; /dev/pts/3</span><br><span class="line">lrwx------ 1 root root 64 Feb  1 13:37 3 -&gt; socket:[12004746]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行 ./client后，新增了一个socket文件</span></span><br><span class="line">root@upupup:/data/pypath/cloud-fly# ll /proc/19011/fd</span><br><span class="line">total 0</span><br><span class="line">dr-x------ 2 root root  0 Feb  1 13:37 ./</span><br><span class="line">dr-xr-xr-x 9 root root  0 Feb  1 13:37 ../</span><br><span class="line">lrwx------ 1 root root 64 Feb  1 13:37 0 -&gt; /dev/pts/3</span><br><span class="line">lrwx------ 1 root root 64 Feb  1 13:37 1 -&gt; /dev/pts/3</span><br><span class="line">lrwx------ 1 root root 64 Feb  1 13:37 2 -&gt; /dev/pts/3</span><br><span class="line">lrwx------ 1 root root 64 Feb  1 13:37 3 -&gt; socket:[12004746]</span><br><span class="line">lrwx------ 1 root root 64 Feb  1 13:37 4 -&gt; socket:[12004747]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>go-science&#x2F;example&#x2F;cpp</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>C语言之网络编程（服务器和客户端）:<a target="_blank" rel="noopener" href="https://blog.csdn.net/zh0314/article/details/77387162">https://blog.csdn.net/zh0314/article/details/77387162</a></p>
<p>Linux Socket编程（不限Linux）：	<a target="_blank" rel="noopener" href="https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html">https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html</a></p>
<p>监听套接字与已连接套接字：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lihao21/article/details/64951446">https://blog.csdn.net/lihao21/article/details/64951446</a></p>
<p>为什么有监听socket和连接socket,为什么产生两个socket：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/liangjf/p/9900928.html">https://www.cnblogs.com/liangjf/p/9900928.html</a></p>
<p>ss命令和Recv-Q和Send-Q状态：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/leezhxing/p/5329786.html">https://www.cnblogs.com/leezhxing/p/5329786.html</a></p>
<p>当我们在读写Socket时，我们究竟在读写什么？：<a target="_blank" rel="noopener" href="https://juejin.im/post/5b344ad6e51d4558892eeb46">https://juejin.im/post/5b344ad6e51d4558892eeb46</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/01/20/http/http%E4%B9%8Bgolang%20gin%20%E6%A1%86%E6%9E%B6%E7%9A%84%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/http/http%E4%B9%8Bgolang%20gin%20%E6%A1%86%E6%9E%B6%E7%9A%84%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">http之golang gin 框架的路由算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-20 15:20:35" itemprop="dateCreated datePublished" datetime="2020-01-20T15:20:35+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index"><span itemprop="name">http</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>todo… not good</p>
<p>gin 框架的路由，本质上是一个前缀树。每一种http method有一颗数，并且前缀树采用最长前缀来表示， 而不是简单的通过斜杠分隔。</p>
<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><h3 id="获取树的根节点"><a href="#获取树的根节点" class="headerlink" title="获取树的根节点"></a>获取树的根节点</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里使用的是数组，在数据量很小的时候， 遍历数组肯定是比使用哈希表更高效的方式，由于http method 的方法就只有有限的几种类型，所以数组时更高效的选择。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(trees methodTrees)</span></span> get(method <span class="type">string</span>) *node &#123;</span><br><span class="line">	<span class="keyword">for</span> _, tree := <span class="keyword">range</span> trees &#123;</span><br><span class="line">		<span class="keyword">if</span> tree.method == method &#123;</span><br><span class="line">			<span class="keyword">return</span> tree.root</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tree-node"><a href="#tree-node" class="headerlink" title="tree node"></a>tree node</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    path      <span class="type">string</span> <span class="comment">// 当前节点相对路径（与祖先节点的 path 拼接可得到完整路径）</span></span><br><span class="line">    indices   <span class="type">string</span> <span class="comment">// 所有孩子节点的path[0]组成的字符串</span></span><br><span class="line">    children  []*node <span class="comment">// 孩子节点</span></span><br><span class="line">    handlers  HandlersChain <span class="comment">// 当前节点的处理函数（包括中间件）</span></span><br><span class="line">    priority  <span class="type">uint32</span> <span class="comment">// 当前节点及子孙节点的实际路由数量</span></span><br><span class="line">    nType     nodeType <span class="comment">// 节点类型</span></span><br><span class="line">    maxParams <span class="type">uint8</span> <span class="comment">// 子孙节点的最大参数数量</span></span><br><span class="line">    wildChild <span class="type">bool</span> <span class="comment">// 孩子节点是否有通配符（wildcard）</span></span><br><span class="line">    fullPath  <span class="type">string</span> <span class="comment">// 路由全路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nType 有这几个值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    static nodeType = <span class="literal">iota</span> <span class="comment">// 普通节点，默认</span></span><br><span class="line">    root <span class="comment">// 根节点</span></span><br><span class="line">    param <span class="comment">// 参数路由，比如 /user/:id</span></span><br><span class="line">    catchAll <span class="comment">// 匹配所有内容的路由，比如 /article/*key</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="注册-1"><a href="#注册-1" class="headerlink" title="注册"></a>注册</h3><p>…</p>
<h2 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h2><h3 id="ServeHTTP"><a href="#ServeHTTP" class="headerlink" title="ServeHTTP"></a>ServeHTTP</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">	c := engine.pool.Get().(*Context)</span><br><span class="line">	c.writermem.reset(w)</span><br><span class="line">	c.Request = req</span><br><span class="line">	c.reset()</span><br><span class="line"></span><br><span class="line">	engine.handleHTTPRequest(c)</span><br><span class="line"></span><br><span class="line">	engine.pool.Put(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="寻找路由并处理动态参数"><a href="#寻找路由并处理动态参数" class="headerlink" title="寻找路由并处理动态参数"></a>寻找路由并处理动态参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getValue returns the handle registered with the given path (key). The values of</span></span><br><span class="line"><span class="comment">// wildcards are saved to a map.</span></span><br><span class="line"><span class="comment">// If no handle can be found, a TSR (trailing slash redirect) recommendation is</span></span><br><span class="line"><span class="comment">// made if a handle exists with an extra (without the) trailing slash for the</span></span><br><span class="line"><span class="comment">// given path.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> getValue(path <span class="type">string</span>, po Params, unescape <span class="type">bool</span>) (value nodeValue) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022466684">gin 源码阅读（二）– 路由和路由组</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Percy"
      src="https://ivalue2333.github.io/percy/images/percy.jpg">
  <p class="site-author-name" itemprop="name">Percy</p>
  <div class="site-description" itemprop="description">IOT2014</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">156</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">194</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Percy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
