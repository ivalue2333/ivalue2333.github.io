<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="https://ivalue2333.github.io/percy/images/percy.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="IOT2014">
<meta property="og:type" content="website">
<meta property="og:title" content="blog | percy">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="blog | percy">
<meta property="og:description" content="IOT2014">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Percy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>blog | percy</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blog | percy</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/25/blog/http/http%E4%B9%8B%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/25/blog/http/http%E4%B9%8B%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/" class="post-title-link" itemprop="url">http 之 数字签名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-25 19:02:37" itemprop="dateCreated datePublished" datetime="2020-12-25T19:02:37+08:00">2020-12-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index"><span itemprop="name">http</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>鲍勃有两把钥匙，一把是公钥，另一把是私钥。</p>
<p>鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。</p>
<p>苏珊要给鲍勃写一封保密的信。她写完后用鲍勃的公钥加密，就可以达到保密的效果。</p>
<p>鲍勃收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>鲍勃给苏珊回信，决定采用”数字签名”。他写完后先用Hash函数，生成信件的摘要（digest）。</p>
<p>然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。</p>
<p>鲍勃将这个签名，附在信件下面，一起发给苏珊。</p>
<p>苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是<strong>鲍勃发出</strong>的（能够解密）。</p>
<p>苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就<strong>证明这封信未被修改过</strong>。</p>
<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，用自己的私钥做成”数字签名”，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。</p>
<p>后来，苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。</p>
<p>鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书（<strong>附上数字证书不是因为证书有用，而是为了让苏珊拿到证书里的公钥，因为在证书里的公钥肯定是没有被伪造的</strong>）就行了。</p>
<p>苏珊收信后，<strong>用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了</strong>，然后就能证明”数字签名”是否真的是鲍勃签的。（<strong>相信了CA的公钥是决定正确的， 数字证书中有服务方的公钥</strong>）</p>
<h4 id="证书包含哪些内容"><a href="#证书包含哪些内容" class="headerlink" title="证书包含哪些内容"></a>证书包含哪些内容</h4><ul>
<li>证书颁发机构的名称</li>
<li><strong>证书本身的数字签名</strong></li>
<li><strong>证书持有者公钥</strong></li>
<li>证书签名用到的Hash算法</li>
</ul>
<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html</a></p>
<p><a target="_blank" rel="noopener" href="http://www.youdzone.com/signature.html">http://www.youdzone.com/signature.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/19/blog/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BTrie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/19/blog/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BTrie/" class="post-title-link" itemprop="url">数据结构之Trie</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-19 19:39:49" itemprop="dateCreated datePublished" datetime="2020-12-19T19:39:49+08:00">2020-12-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>又称单词查找树，Trie树，前缀树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p><img src="https://pic002.cnblogs.com/images/2012/214741/2012112521092438.png"></p>
<p>第一：根节点不包含字符，除根节点外的每一个子节点都包含一个字符。</p>
<p>第二：从根节点到某一节点，路径上经过的字符连接起来，就是该节点对应的字符串。</p>
<p>第三：每个单词的公共前缀作为一个字符节点保存。</p>
<h3 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h3><ul>
<li><p>第一：词频统计。</p>
</li>
<li><p>可能有人要说了，词频统计简单啊，一个hash或者一个堆就可以打完收工，但问题来了，如果内存有限呢？还能这么玩吗？所以这里我们就可以用trie树来压缩下空间，因为公共前缀都是用一个节点保存的。</p>
</li>
<li><p>第二: 前缀匹配</p>
<ul>
<li>就拿上面的图来说吧，如果我想获取所有以”a”开头的字符串，从图中可以很明显的看到是：and,as,at，如果不用trie树，你该怎么做呢？很显然朴素的做法时间复杂度为O(N2) ，那么用Trie树就不一样了，它可以做到h，h为你检索单词的长度，可以说这是秒杀的效果。</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>省略</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huangxincheng/archive/2012/11/25/2788268.html">6天通吃树结构—— 第五天 Trie树</a></p>
<p><a target="_blank" rel="noopener" href="https://swsmile.info/post/data-structure%E6%A0%91-%E5%A4%9A%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-trie%E6%A0%91/">【Data Structure】多叉搜索树 - Trie 树（字典树)</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">leetcode</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/19/blog/algorithm/%E7%AE%97%E6%B3%95%E4%B9%8Bdfs%20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/19/blog/algorithm/%E7%AE%97%E6%B3%95%E4%B9%8Bdfs%20/" class="post-title-link" itemprop="url">算法之dfs</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-19 19:39:49" itemprop="dateCreated datePublished" datetime="2020-12-19T19:39:49+08:00">2020-12-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><p>[TOC]</p>
<p>深度优先搜索属于图算法的一种，英文缩写为DFS即Depth First Search.其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次.</p>
<p>特别的， 回溯算法也是一种dfs，回溯算法一般是先跟遍历，回溯算法需要在每次递归前做选择的操作，在每次递归后做取消选择的操作。</p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树的先序遍历，中序遍历，后序遍历，本质上来说，都是深度优先搜索。</p>
<p>唯一的区别是：<strong>在遍历的过程中，什么时候访问根节点的值， 因为根节点值可以在三个时间点访问，在第一次深度优先递归之前，在第一次深度优先递归之后，在第二次深度优先递归之后。</strong></p>
<blockquote>
<p>During the traversal, what time they will access the content of a node.<br>Because a node is actually visited 3 times for binary tree. They include: the time before the first DFS call, and the times after each DFS call.</p>
</blockquote>
<h3 id="三种遍历"><a href="#三种遍历" class="headerlink" title="三种遍历"></a>三种遍历</h3><p>The preorder traversal accesses the content of a node when it is first visited (before the DFS on his left child). It is implemented as follows:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Preorder (root) &#123;</span><br><span class="line">  1. access content of root </span><br><span class="line">  2. Call Preorder(root.left)</span><br><span class="line">  3. Call Preorder(root.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The postorder traversal accesses the content of a node when it is last visited (after the DFS on both children). It is implemented as follows :</p>
<figure class="highlight plaintext"><figcaption><span>(root) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Preorder (root) &#123;</span><br><span class="line">  1. Call Preorder(root.left)</span><br><span class="line">  2. Call Preorder(root.right)</span><br><span class="line">  3. access content of root </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The inorder traversal accesses the content of a node just before we visit right child. It is implemented as follows：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Preorder (root) &#123;</span><br><span class="line">  1. Call Preorder(root.left)</span><br><span class="line">  2. access content of root </span><br><span class="line">  3. Call Preorder(root.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从上到下vs从下到上"><a href="#从上到下vs从下到上" class="headerlink" title="从上到下vs从下到上"></a>从上到下vs从下到上</h2><p>当看到二叉树的时候，一定要有不管在哪个节点上，都是一棵二叉树的思想。</p>
<h3 id="从上到下"><a href="#从上到下" class="headerlink" title="从上到下"></a>从上到下</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">给定一个二叉树，返回所有从根节点到叶子节点的路径。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">说明:叶子节点是指没有子节点的节点。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">示例:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">输入:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   1</span></span><br><span class="line"><span class="string"> /   \</span></span><br><span class="line"><span class="string">2     3</span></span><br><span class="line"><span class="string"> \</span></span><br><span class="line"><span class="string">  5</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="string">链接：https://leetcode-cn.com/problems/binary-tree-paths</span></span><br><span class="line"><span class="string">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> algorithm.binary_tree <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.paths = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前序遍历，前序遍历的使用场景是从上到下的顺序访问，例如这里需要获取从根结点到叶子结点的路径。</span></span><br><span class="line"><span class="string">        前序遍历在访问到叶子结点后，就直接return了，不需要在回溯中做动作</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.dfs(root, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.paths</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, root: TreeNode, pathStr: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            pathStr += <span class="built_in">str</span>(root.val)</span><br><span class="line">            self.paths.append(pathStr)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        pathStr += <span class="built_in">str</span>(root.val) + <span class="string">&quot;-&gt;&quot;</span></span><br><span class="line">        self.dfs(root.left, pathStr)</span><br><span class="line">        self.dfs(root.right, pathStr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">None</span>, <span class="number">5</span>]</span><br><span class="line">root = gen_tree_from_list(root)</span><br><span class="line"><span class="built_in">print</span>(Solution().binaryTreePaths(root))</span><br></pre></td></tr></table></figure>

<h3 id="从下到上"><a href="#从下到上" class="headerlink" title="从下到上"></a>从下到上</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">给你一棵以 root 为根的 二叉树 ，请你返回 任意 二叉搜索子树的最大键值和。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">二叉搜索树的定义如下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">任意节点的左子树中的键值都 小于 此节点的键值。</span></span><br><span class="line"><span class="string">任意节点的右子树中的键值都 大于 此节点的键值。</span></span><br><span class="line"><span class="string">任意节点的左子树和右子树都是二叉搜索树。</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">示例 1：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">输入：root = [1,4,3,2,4,2,5, None, None, None, None, None, None,4,6]</span></span><br><span class="line"><span class="string">输出：20</span></span><br><span class="line"><span class="string">解释：键值为 3 的子树是和最大的二叉搜索树。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="string">链接：https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree</span></span><br><span class="line"><span class="string">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> algorithm.binary_tree <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 空的二叉树也是二叉搜索树，所以这里最小值肯定是0， 不是 float(&quot;-inf&quot;)</span></span><br><span class="line">        self.max_sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSumBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        后序遍历</span></span><br><span class="line"><span class="string">        当前节点的视角</span></span><br><span class="line"><span class="string">            1：判断当前二叉树是不是二叉搜索树 （后序遍历）</span></span><br><span class="line"><span class="string">                1：当前节点的左子树，右子树 是不是 bst</span></span><br><span class="line"><span class="string">                2：当前节点比左子树的最大值大，比右子树的最小值小</span></span><br><span class="line"><span class="string">            2：计算当前二叉树的节点和（后序遍历）</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.traverse(root)</span><br><span class="line">        <span class="keyword">return</span> self.max_sum</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        使用后序遍历</span></span><br><span class="line"><span class="string">        返回值有如下定义</span></span><br><span class="line"><span class="string">        res[0] 表示当前二叉树是否是 bst， 1表示是bst， 0表示不是bst</span></span><br><span class="line"><span class="string">        res[1] 表示当前二叉树的所有节点的最小值</span></span><br><span class="line"><span class="string">        res[2] 表示当前二叉树的所有节点的最大值</span></span><br><span class="line"><span class="string">        res[3] 表示当前二叉树的所有节点的和</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="comment"># 这里是为叶子节点方便去叶子节点的值作为二叉树所有节点的最小值，最大值</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>, <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>), <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>), <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        res = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        left = self.traverse(root.left)</span><br><span class="line">        right = self.traverse(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left[<span class="number">0</span>] != <span class="number">1</span> <span class="keyword">or</span> right[<span class="number">0</span>] != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left[<span class="number">2</span>] &gt;= root.val <span class="keyword">or</span> right[<span class="number">1</span>] &lt;= root.val:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        res[<span class="number">1</span>] = <span class="built_in">min</span>(left[<span class="number">1</span>], root.val)</span><br><span class="line">        res[<span class="number">2</span>] = <span class="built_in">max</span>(right[<span class="number">2</span>], root.val)</span><br><span class="line">        res[<span class="number">3</span>] = left[<span class="number">3</span>] + right[<span class="number">3</span>] + root.val</span><br><span class="line"></span><br><span class="line">        self.max_sum = <span class="built_in">max</span>(self.max_sum, res[<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">root = gen_tree_from_list(root)</span><br><span class="line"><span class="built_in">print</span>(Solution().maxSumBST(root))</span><br></pre></td></tr></table></figure>

<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">路径, 选择列表</span>):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<h3 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        全排列问题</span></span><br><span class="line"><span class="string">        思路：搜索回溯</span></span><br><span class="line"><span class="string">            1. 当前可选择列表， 当前已选链表</span></span><br><span class="line"><span class="string">            2. 如果达到要求，那么将 track 加入到 ans， 并返回</span></span><br><span class="line"><span class="string">            3. 循环当前可选列表</span></span><br><span class="line"><span class="string">                3.1. 未达到要求， 从可选择列表中选择一个元素，加入 track 列表，并递归</span></span><br><span class="line"><span class="string">                3.2 递归返回后，撤销上一次的选择，将上一个元素从 track 列表中弹出， 并继续循环</span></span><br><span class="line"><span class="string">            4. 返回 ans</span></span><br><span class="line"><span class="string">        :param nums:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">track: <span class="built_in">list</span></span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="built_in">len</span>(track):</span><br><span class="line">                ans.append(track[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> used[i]:</span><br><span class="line">                    track.append(num)</span><br><span class="line">                    used[i] = <span class="literal">True</span></span><br><span class="line">                    backtrace(track)</span><br><span class="line">                    used[i] = <span class="literal">False</span></span><br><span class="line">                    track.pop()</span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        used = [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        backtrace([])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(Solution().permute(<span class="built_in">input</span>))</span><br></pre></td></tr></table></figure>

<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        这里和上面的区别是，当前可选列表的表示方式的区别</span></span><br><span class="line"><span class="string">        思路</span></span><br><span class="line"><span class="string">            1. 可选列表的表示方式，在调用 backtrace 处，每次传入 index， 用于表示当前可选列表在 nums 中 起始 index</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :tag to_remember 回溯最好的写法</span></span><br><span class="line"><span class="string">        :param n:</span></span><br><span class="line"><span class="string">        :param k:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">start_index, track: <span class="built_in">list</span></span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(track) == k:</span><br><span class="line">                ans.append(track[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(start_index, n):</span><br><span class="line">                track.append(nums[index])</span><br><span class="line">                backtrace(index + <span class="number">1</span>, track)</span><br><span class="line">                track.pop()</span><br><span class="line"></span><br><span class="line">        nums = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>)]</span><br><span class="line">        ans = []</span><br><span class="line">        backtrace(<span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/12/blog/algorithm/%E7%AE%97%E6%B3%95%E4%B9%8Bgroupcache%20singleflight%20%E9%98%B2%E7%BC%93%E5%AD%98%E5%B4%A9%E6%BA%83%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/12/blog/algorithm/%E7%AE%97%E6%B3%95%E4%B9%8Bgroupcache%20singleflight%20%E9%98%B2%E7%BC%93%E5%AD%98%E5%B4%A9%E6%BA%83%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">算法之groupcache singleflight 防缓存崩溃算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-12 19:39:49" itemprop="dateCreated datePublished" datetime="2020-12-12T19:39:49+08:00">2020-12-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>一个很棒的代码，但是原理也很简单，主要是作者对互斥量和WaitGroup的妙用。</p>
<p>实现的主要功能就是防止大量的请求同时落库（ fn func() (interface{}, error)）， 在解决缓存击穿，缓存雪崩时有奇效。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleflight</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// call is an in-flight or completed Do call</span></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">	wg  sync.WaitGroup</span><br><span class="line">	val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	err <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Group represents a class of work and forms a namespace in which</span></span><br><span class="line"><span class="comment">// units of work can be executed with duplicate suppression.</span></span><br><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu sync.Mutex       <span class="comment">// protects m</span></span><br><span class="line">	m  <span class="keyword">map</span>[<span class="type">string</span>]*call <span class="comment">// lazily initialized</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do executes and returns the results of the given function, making</span></span><br><span class="line"><span class="comment">// sure that only one execution is in-flight for a given key at a</span></span><br><span class="line"><span class="comment">// time. If a duplicate comes in, the duplicate caller waits for the</span></span><br><span class="line"><span class="comment">// original to complete and receives the same results.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> Do(key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">	g.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">		g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*call)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果已经有 call in flight, then wait</span></span><br><span class="line">	<span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">		g.mu.Unlock()</span><br><span class="line">        <span class="comment">// 通过 wg 来等待， 因为另一个 g 已经对 wg.Add(1) 了</span></span><br><span class="line">		c.wg.Wait()</span><br><span class="line">		<span class="keyword">return</span> c.val, c.err</span><br><span class="line">	&#125;</span><br><span class="line">	c := <span class="built_in">new</span>(call)</span><br><span class="line">	c.wg.Add(<span class="number">1</span>)</span><br><span class="line">	g.m[key] = c</span><br><span class="line">    <span class="comment">// 这里不解锁，其他的 g 会先在 g.mu.Lock() 等待</span></span><br><span class="line">	g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	c.val, c.err = fn()</span><br><span class="line">	c.wg.Done()</span><br><span class="line"></span><br><span class="line">	g.mu.Lock()</span><br><span class="line">	<span class="built_in">delete</span>(g.m, key)</span><br><span class="line">	g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c.val, c.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/12/blog/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B%E4%B9%8B%20elasticsearch%20reindx%20%E5%92%8C%E5%88%AB%E5%90%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/12/blog/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B%E4%B9%8B%20elasticsearch%20reindx%20%E5%92%8C%E5%88%AB%E5%90%8D/" class="post-title-link" itemprop="url">分布式系统实例之 elasticsearch reindex 和别名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-12 10:42:33" itemprop="dateCreated datePublished" datetime="2020-12-12T10:42:33+08:00">2020-12-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-26 22:40:11" itemprop="dateModified" datetime="2023-02-26T22:40:11+08:00">2023-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ES中可以为索引添加别名，一个别名可以指向到多个索引中，同时在添加别名时可以设置筛选条件，指向一个索引的部分数据，实现在关系数据库汇总的视图功能，这就是ES中别名的强大之处。别名是一个非常实用的功能，为我们使用索引提供了极大的灵活性，许多ES的API都支持用别名来代替真实索引名。通过索引我们可以方便的进行以下操作：</p>
<ul>
<li>实现正在运行的集群上的一个索引到另一个索引之间的无缝切换。试想一下这种藏进，由于业务变换，我们需要将业务数据有索引1变换到新的索引2上，如果没有别名，我们必须修改和总段业务系统，但是有了别名，只需要修改别名，另起指向新的索引2即可，这样的操作可以在用户无任何感知的情况下完成。</li>
<li>使数据检索等炒作更加方便。加入有两个月的日志数据，分别存放在index_202008和index_202009两个索引中，没有使用别名进行检索时，我们需要同时写上两个索引名称进行检索，使用索引后，我们可以令别名同时指向这两个索引，检索时只需要使用这个别名就可以同时在两个索引中尽心检索。</li>
<li>为一个索引中的部分数据创建别名，例如，一个索引中存放了一整年的数据，现在新增一个业务场景，更多的是对其中某一个月的数据进行检索，这时，我们可以在创建别名时，通过设置过滤条件filter，可以单独令别名指向一个月的数据，使得检索更加高效。</li>
</ul>
<p><strong>通过上面的场景我们可以看出，ES中别名可以指向一个索引，也可以同时指向多个索引，甚至可以通过配合过滤器filter指向索引中部分数据。别名可以再创建索引时添加，也可以在索引创建后进行添加，ES中提供丰富的API对别名进行管理。接下来，我们捋一捋ES中对别名的操作。</strong></p>
<h1 id="创建别名"><a href="#创建别名" class="headerlink" title="创建别名"></a>创建别名</h1><p>创建别名有很多种方法，可以创建索引同时创建别名，也可以在创建索引后创建，既可以让别名指向多个索引，也可以让别名指向一个索引的部分数据，甚至指向一个字段。我们来一一例举这是如何操作的。</p>
<p><strong>（1）创建索引同时创建别名</strong></p>
<p>创建一个名为users用户索引，索引中记录了用户出生年，现在，我们在创建索引的同时，创建两个别名，一个别名指向整个users索引，并通过filter进行过滤，使别名只指向2000年出生的用户。</p>
<p><strong>2）创建索引后创建别名</strong></p>
<p>直接通过API路由传递别名来创建，这种方法有一下几种请求方式，注意，这种方式要求索引必须存在。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT /&lt;index&gt;/_alias/&lt;alias&gt;</span><br><span class="line"></span><br><span class="line">PUT /my_single_26/_alias/my_alias_test</span><br><span class="line"></span><br><span class="line">POST /&lt;index&gt;/_alias/&lt;alias&gt;</span><br><span class="line"></span><br><span class="line">PUT /&lt;index&gt;/_aliases/&lt;alias&gt;</span><br><span class="line"></span><br><span class="line">POST /&lt;index&gt;/_aliases/&lt;alias&gt;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/12/blog/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B%E4%B9%8B%20elasticsearch%20%E7%B4%A2%E5%BC%95mapping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/12/blog/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B%E4%B9%8B%20elasticsearch%20%E7%B4%A2%E5%BC%95mapping/" class="post-title-link" itemprop="url">分布式系统实例之 elasticsearch索引mapping</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-12 10:42:33" itemprop="dateCreated datePublished" datetime="2020-12-12T10:42:33+08:00">2020-12-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 14:26:27" itemprop="dateModified" datetime="2022-09-22T14:26:27+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>映射是定义文档及其包含的字段如何<strong>存储和索引的过程</strong>。例如，使用映射来定义：</p>
<ul>
<li>哪些字符串字段应该被视为全文字段。</li>
<li>哪些字段包含数字、日期或地理位置。</li>
<li>日期值的格式。</li>
<li>自定义规则来控制动态添加字段的映射。</li>
</ul>
<h2 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h2><p>每个字段都有一个数据类型，可以是以下类型：</p>
<ul>
<li>简单类型如<code>text</code>, <code>keyword</code>, <code>date</code>, <code>long</code>, <code>double</code>, <code>boolean</code>, <code>ip</code>.</li>
<li>一种支持JSON的分层特性的类型，例如<code>object</code>或<code>nested</code>。</li>
<li>或特殊的类型，例如<code>geo_point</code>，<code>geo_shape</code>或<code>completion</code>。</li>
</ul>
<p>为不同的目的以不同的方式为同一字段建立索引通常很有用。例如，<code>string</code>字段可以作为全文搜索的<code>text</code>字段建立索引，也可以作为排序或聚合的<code>keyword</code>字段建立索引。或者，您可以使用标准分析器、英语分析器和法语分析器来索引字符串字段。</p>
<p>这是多字段的目的。 大多数数据类型通过fields参数支持多字段。</p>
<ul>
<li>Text：默认情况下会进行分词</li>
<li>Keyword：不会进行分词，全文本匹配</li>
<li>Date：日期类型</li>
<li>Integer&#x2F;Floating：整数&#x2F;浮点数</li>
<li>Boolean：布尔类型</li>
<li>IPv4 &amp; IPv6</li>
<li>特殊类型：geo_point &amp; geo_shape &amp; percolator</li>
<li>index：表示该字段是否可以被搜索，是否需要建立倒排索引</li>
</ul>
<h3 id="类型详解"><a href="#类型详解" class="headerlink" title="类型详解"></a>类型详解</h3><h4 id="text"><a href="#text" class="headerlink" title="text"></a>text</h4><p><code>text</code> 类型适用于需要被全文检索的字段，例如新闻正文、邮件内容等比较长的文字，<code>text</code> 类型会被 Lucene 分词器（Analyzer）处理为一个个词项，并使用 Lucene 倒排索引存储，<strong>text 字段不能被用于排序</strong>，如果需要使用该类型的字段只需要在定义映射时指定 JSON 中对应字段的 <code>type</code> 为 <code>text</code>。</p>
<h4 id="keyword"><a href="#keyword" class="headerlink" title="keyword"></a>keyword</h4><p><code>keyword</code> 适合简短、结构化字符串，例如主机名、姓名、商品名称等，<strong>可以用于过滤、排序、聚合检索，也可以用于精确查询</strong>。</p>
<h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><p>数字类型分为 <code>long、integer、short、byte、double、float、half_float、scaled_float</code>。</p>
<p>数字类型的字段在满足需求的前提下应当尽量选择范围较小的数据类型，字段长度越短，搜索效率越高，对于浮点数，可以优先考虑使用 <code>scaled_float</code> 类型，该类型可以通过缩放因子来精确浮点数，例如 12.34 可以转换为 1234 来存储。</p>
<h4 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h4><p>在 ES 中日期可以为以下形式：</p>
<ul>
<li>格式化的日期字符串，例如 2020-03-17 00:00、2020&#x2F;03&#x2F;17</li>
<li>时间戳（和 1970-01-01 00:00:00 UTC 的差值），单位毫秒或者秒</li>
</ul>
<blockquote>
<p>即使是格式化的日期字符串，ES 底层依然采用的是时间戳的形式存储。</p>
</blockquote>
<h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p>JSON 文档中同样存在布尔类型，不过 JSON 字符串类型也可以被 ES 转换为布尔类型存储，前提是字符串的取值为 <code>true</code> 或者 <code>false</code>，布尔类型常用于检索中的过滤条件</p>
<h2 id="动态Mapping"><a href="#动态Mapping" class="headerlink" title="动态Mapping"></a>动态Mapping</h2><p>字段和映射类型在使用之前不需要定义。通过动态映射，仅通过索引文档即可自动添加新的字段名称。新字段既可以添加到顶级映射类型，也可以添加到内部对象和嵌套字段.</p>
<p>可以将动态映射规则配置为自定义用于新字段的映射。</p>
<h2 id="显式的映射"><a href="#显式的映射" class="headerlink" title="显式的映射"></a>显式的映射</h2><p>您对数据的了解超出了Elasticsearch的猜测，因此尽管动态映射对于入门非常有用，但有时您仍需要指定自己的显式映射。</p>
<p>你可以创建字段映射，当你创建一个索引或者在已经存在的索引中新增字段</p>
<ul>
<li>创建索引的显示映射</li>
</ul>
<p>您可以使用create index API创建带有显式映射的新索引。</p>
<h3 id="创建和新增字段的mapping"><a href="#创建和新增字段的mapping" class="headerlink" title="创建和新增字段的mapping"></a>创建和新增字段的mapping</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT <span class="string">&quot;localhost:9200/my-index?pretty&quot;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;mappings&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;properties&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;age&quot;:    &#123; &quot;type&quot;: &quot;integer&quot; &#125;,  </span></span><br><span class="line"><span class="string">      &quot;email&quot;:  &#123; &quot;type&quot;: &quot;keyword&quot;  &#125;, </span></span><br><span class="line"><span class="string">      &quot;name&quot;:   &#123; &quot;type&quot;: &quot;text&quot;  &#125;     </span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<p>您可以使用put mapping API向现有索引添加一个或多个新字段。下面的示例添加了<code>employee-id</code>，这是一个<code>keyword</code>字段，其索引映射参数值为<code>false</code>。这意味着存储了<code>employee-id</code>字段的值，但是不能进行索引，也不能用于搜索。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT <span class="string">&quot;localhost:9200/my-index/_mapping?pretty&quot;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;properties&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;employee-id&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;type&quot;: &quot;keyword&quot;,</span></span><br><span class="line"><span class="string">      &quot;index&quot;: false</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="更新字段的mapping"><a href="#更新字段的mapping" class="headerlink" title="更新字段的mapping"></a>更新字段的mapping</h3><p>除了支持的映射参数外，您无法更改现有字段的映射或字段类型。 更改现有字段可能会使已经建立索引的数据无效。</p>
<p>如果需要更改字段的映射，请使用正确的映射创建一个新索引，然后将数据重新索引到该索引中。</p>
<p>重命名字段会使在旧字段名称下已建立索引的数据无效。 而是添加一个别名字段以创建备用字段名称。</p>
<h3 id="查看索引的映射"><a href="#查看索引的映射" class="headerlink" title="查看索引的映射"></a>查看索引的映射</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/my-index/_mapping?pretty&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904104330788877">Elasticsearch教程之Mapping</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wupeixuan/p/12514843.html">一文搞懂 Elasticsearch 之 Mapping</a></p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/prestigeding/article/details/84675404">Elasticsearch Mapping parameters（主要参数一览)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/12/blog/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B%E4%B9%8B%20elasticsearch%20%E7%B4%A2%E5%BC%95%E6%A8%A1%E6%9D%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/12/blog/distribute/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B%E4%B9%8B%20elasticsearch%20%E7%B4%A2%E5%BC%95%E6%A8%A1%E6%9D%BF/" class="post-title-link" itemprop="url">分布式系统实例之 elasticsearch 索引模板</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-12 10:42:33" itemprop="dateCreated datePublished" datetime="2020-12-12T10:42:33+08:00">2020-12-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 14:26:20" itemprop="dateModified" datetime="2022-09-22T14:26:20+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>索引模板: 就是把已经创建好的某个索引的参数设置(settings)和索引映射(mapping)保存下来作为模板, 在创建新索引时, 指定要使用的模板名, 就可以直接重用已经定义好的模板中的设置和映射.</p>
<h2 id="索引模板中的内容"><a href="#索引模板中的内容" class="headerlink" title="索引模板中的内容"></a>索引模板中的内容</h2><p>(1) settings: 指定index的配置信息, 比如分片数、副本数, tranlog同步条件、refresh策略等信息;</p>
<p>(2) mappings: 指定index的内部构建信息, 主要有:</p>
<ul>
<li>properties:  最重要的配置, 是对索引结构和文档字段的设置.</li>
</ul>
<h2 id="索引模板的用途"><a href="#索引模板的用途" class="headerlink" title="索引模板的用途"></a>索引模板的用途</h2><p>索引模板一般用在时间序列相关的索引中。也就是说, 如果你需要每间隔一定的时间就建立一次索引, 你只需要配置好索引模板, 以后就可以直接使用这个模板中的设置, 不用每次都设置settings和mappings.</p>
<p>索引模板一般与索引别名一起使用. 关于索引别名。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="创建索引模板"><a href="#创建索引模板" class="headerlink" title="创建索引模板"></a>创建索引模板</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">PUT _template/shop_template</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;index_patterns&quot;</span>: [<span class="string">&quot;shop*&quot;</span>, <span class="string">&quot;bar*&quot;</span>],       // 可以通过<span class="string">&quot;shop*&quot;</span>和<span class="string">&quot;bar*&quot;</span>来适配, template字段已过期</span><br><span class="line">    <span class="string">&quot;order&quot;</span>: 0,                // 模板的权重, 多个模板的时候优先匹配用, 值越大, 权重越高</span><br><span class="line">    <span class="string">&quot;settings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;number_of_shards&quot;</span>: 1  // 分片数量, 可以定义其他配置项</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;aliases&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;alias_1&quot;</span>: &#123;&#125;          // 索引对应的别名</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        // ES 6.0开始只支持一种<span class="built_in">type</span>, 名称为“_doc”， 这里写法可能有问题，看下面的写法（version <span class="string">&quot;7.5.2&quot;</span>,）</span><br><span class="line">        <span class="string">&quot;_doc&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;_source&quot;</span>: &#123;            // 是否保存字段的原始值</span><br><span class="line">                <span class="string">&quot;enabled&quot;</span>: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;        // 字段的映射</span><br><span class="line">                <span class="string">&quot;@timestamp&quot;</span>: &#123;    // 具体的字段映射</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span>,           </span><br><span class="line">                    <span class="string">&quot;format&quot;</span>: <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;@version&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;index&quot;</span>: <span class="string">&quot;false&quot;</span>,   // 设置为<span class="literal">false</span>, 不索引</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>      // text类型</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;logLevel&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT -H <span class="string">&quot;Content-Type:application/json&quot;</span> <span class="string">&quot;localhost:9200/_template/shop_template&quot;</span> --data <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">  &quot;index_patterns&quot;: [</span></span><br><span class="line"><span class="string">    &quot;shop*&quot;,</span></span><br><span class="line"><span class="string">    &quot;bar*&quot;</span></span><br><span class="line"><span class="string">  ],</span></span><br><span class="line"><span class="string">  &quot;order&quot;: 0,</span></span><br><span class="line"><span class="string">  &quot;settings&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;number_of_shards&quot;: 1</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &quot;aliases&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;alias_1&quot;: &#123;&#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &quot;mappings&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;_source&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;enabled&quot;: false</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;properties&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;@timestamp&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;type&quot;: &quot;date&quot;,</span></span><br><span class="line"><span class="string">        &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss&quot;</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      &quot;@version&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;index&quot;: &quot;false&quot;,</span></span><br><span class="line"><span class="string">        &quot;type&quot;: &quot;text&quot;</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      &quot;logLevel&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;type&quot;: &quot;long&quot;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="索引模板优先级"><a href="#索引模板优先级" class="headerlink" title="索引模板优先级"></a>索引模板优先级</h4><p>索引匹配了多个template, 当属性等配置出现不一致时, 以模板的权重(order属性的值)为准, 值越大越优先, order的默认值是0.</p>
<h3 id="查看模板"><a href="#查看模板" class="headerlink" title="查看模板"></a>查看模板</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET _template                // 查看所有模板</span><br><span class="line">GET _template/temp*          // 查看与通配符相匹配的模板</span><br><span class="line">GET _template/temp1,temp2    // 查看多个模板</span><br><span class="line">GET _template/shop_template  // 查看指定模板</span><br></pre></td></tr></table></figure>

<h4 id="curl-1"><a href="#curl-1" class="headerlink" title="curl"></a>curl</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">&quot;localhost:9200/_template/shop_template?pretty&quot;</span></span><br><span class="line"></span><br><span class="line">curl <span class="string">&quot;localhost:9200/_template/not_esists?pretty&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="删除索引模板"><a href="#删除索引模板" class="headerlink" title="删除索引模板"></a>删除索引模板</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELETE _template/shop_template    // 删除上述创建的模板</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果模板不存在那么会报错</span></span><br></pre></td></tr></table></figure>

<h2 id="如何使用索引模板"><a href="#如何使用索引模板" class="headerlink" title="如何使用索引模板"></a>如何使用索引模板</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 技术上来说，只要你创建了一个符合索引模板的index，那么这个index就会使用这个 index template</span></span><br><span class="line">curl -X PUT <span class="string">&#x27;localhost:9200/shop_goods&#x27;</span></span><br><span class="line"></span><br><span class="line">|&gt;<span class="comment"># curl &#x27;localhost:9200/shop_goods?pretty&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;shop_goods&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;aliases&quot;</span> : &#123;</span><br><span class="line">      <span class="string">&quot;alias_1&quot;</span> : &#123; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span> : &#123;</span><br><span class="line">      <span class="string">&quot;_source&quot;</span> : &#123;</span><br><span class="line">        <span class="string">&quot;enabled&quot;</span> : <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;properties&quot;</span> : &#123;</span><br><span class="line">        <span class="string">&quot;@timestamp&quot;</span> : &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;date&quot;</span>,</span><br><span class="line">          <span class="string">&quot;format&quot;</span> : <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;@version&quot;</span> : &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;index&quot;</span> : <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;logLevel&quot;</span> : &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;long&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;settings&quot;</span> : &#123;</span><br><span class="line">      <span class="string">&quot;index&quot;</span> : &#123;</span><br><span class="line">        <span class="string">&quot;creation_date&quot;</span> : <span class="string">&quot;1607742161879&quot;</span>,</span><br><span class="line">        <span class="string">&quot;number_of_shards&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;number_of_replicas&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;uuid&quot;</span> : <span class="string">&quot;q0FmU7inStece1qctW7J2w&quot;</span>,</span><br><span class="line">        <span class="string">&quot;version&quot;</span> : &#123;</span><br><span class="line">          <span class="string">&quot;created&quot;</span> : <span class="string">&quot;7050299&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;provided_name&quot;</span> : <span class="string">&quot;shop_goods&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="features"><a href="#features" class="headerlink" title="features"></a>features</h2><ul>
<li>Index Template 只是对于一个新创建的索引才起作用</li>
<li>可以通过 order 参数来控制模板的优先级</li>
<li>一个 Elasticsearch 可以设置多个 Index Template</li>
</ul>
<h2 id="模板的使用建议"><a href="#模板的使用建议" class="headerlink" title="模板的使用建议"></a>模板的使用建议</h2><h3 id="一个index中不能有多个type"><a href="#一个index中不能有多个type" class="headerlink" title="一个index中不能有多个type"></a>一个index中不能有多个type</h3><p>Elasticsearch 6.X版本中已经不支持在同一个index下创建多个type.</p>
<h3 id="设置-source-x3D-false"><a href="#设置-source-x3D-false" class="headerlink" title="设置_source &#x3D; false"></a>设置_source &#x3D; false</h3><p>如果我们只关心查询的评分结果, 而不用查看原始文档的内容, 就设置<code>&quot;_source&quot;: &#123;&quot;enabled&quot;: false&#125;</code>.—— 这能节省磁盘空间并减少磁盘IO上的开销.</p>
<p>我们可以把原始的数据存储在MySQL、HBase等数据库, 从ES中得到文档的ID之后, 再到相应的数据库中获取数据.</p>
<h3 id="设置-all-x3D-false"><a href="#设置-all-x3D-false" class="headerlink" title="设置_all &#x3D; false"></a>设置_all &#x3D; false</h3><p>如果能够确切地知道要对哪个field做查询操作, 就设置<code>&quot;_all&quot;: &#123;&quot;enabled&quot;: false&#125;</code>.—— 这能实现性能提升, 并节省存储空间.<br>而在6.X版本开始, <code>_all</code>字段也不再支持了, ES官方建议我们通过<code>copy_to</code>自定义我们自己的all字段.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/shoufeng/p/10641560.html">ES 10 - 如何使用Elasticsearch的索引模板(index template)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/06/blog/algorithm/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/06/blog/algorithm/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/" class="post-title-link" itemprop="url">算法之微服务熔断</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-06 20:53:33" itemprop="dateCreated datePublished" datetime="2020-12-06T20:53:33+08:00">2020-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-24 10:30:04" itemprop="dateModified" datetime="2021-06-24T10:30:04+08:00">2021-06-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在微服务中服务间依赖非常常见，比如评论服务依赖审核服务而审核服务又依赖反垃圾服务，当评论服务调用审核服务时，审核服务又调用反垃圾服务，而这时反垃圾服务超时了，由于审核服务依赖反垃圾服务，反垃圾服务超时导致审核服务逻辑一直等待，而这个时候评论服务又在一直调用审核服务，审核服务就有可能因为堆积了大量请求而导致服务宕机。</p>
<p>由此可见，在整个调用链中，中间的某一个环节出现异常就会引起上游调用服务出现一些列的问题，甚至导致整个调用链的服务都宕机，这是非常可怕的。因此一个服务作为调用方调用另一个服务时，为了防止被调用服务出现问题进而导致调用服务出现问题，所以<strong>调用服务需要进行自我保护，而保护的常用手段就是熔断（调用方的自我保护措施）</strong>。</p>
<h2 id="熔断器原理"><a href="#熔断器原理" class="headerlink" title="熔断器原理"></a>熔断器原理</h2><p>而服务治理中的熔断机制，指的是在发起服务调用的时候，如果被调用方返回的错误率超过一定的阈值，那么后续的请求将不会真正发起请求，而是在调用方直接返回错误。</p>
<p>在这种模式下，服务调用方为每一个调用服务 (调用路径) 维护一个状态机，在这个<strong>熔断器的状态机</strong>中有三个状态：</p>
<ul>
<li>关闭 (Closed)：在这种状态下，我们需要一个计数器来记录调用失败的次数和总的请求次数，如果在某个时间窗口内，失败的失败率达到预设的阈值，则切换到断开状态，此时开启一个超时时间，当到达该时间则切换到半关闭状态，该超时时间是给了系统一次机会来修正导致调用失败的错误，以回到正常的工作状态。在关闭状态下，调用错误是基于时间的，在特定的时间间隔内会重置，这能够防止偶然错误导致熔断器进去断开状态</li>
<li>打开 (Open)：在该状态下，发起请求时会立即返回错误，一般会启动一个超时计时器，当计时器超时后，状态切换到半打开状态，也可以设置一个定时器，定期的探测服务是否恢复</li>
<li>半打开 (Half-Open)：在该状态下，允许应用程序一定数量的请求发往被调用服务，如果这些调用正常，那么可以认为被调用服务已经恢复正常，此时熔断器切换到关闭状态，同时需要重置计数。如果这部分仍有调用失败的情况，则认为被调用方仍然没有恢复，熔断器会切换到关闭状态，然后重置计数器，半打开状态能够有效防止正在恢复中的服务被突然大量请求再次打垮</li>
</ul>
<h2 id="zrpc熔断器引入"><a href="#zrpc熔断器引入" class="headerlink" title="zrpc熔断器引入"></a>zrpc熔断器引入</h2><p>熔断器主要是用来保护调用端，调用端在发起请求的时候需要先经过熔断器，而客户端拦截器正好兼具了这个这个功能，所以在 zRPC 框架内熔断器是实现在客户端拦截器内，拦截器的原理如下图：</p>
<p>对应的代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BreakerInterceptor</span><span class="params">(ctx context.Context, method <span class="type">string</span>, req, reply <span class="keyword">interface</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">    cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// 基于请求方法进行熔断</span></span><br><span class="line">    breakerName := path.Join(cc.Target(), method)</span><br><span class="line">    <span class="keyword">return</span> breaker.DoWithAcceptable(breakerName, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 真正发起调用</span></span><br><span class="line">        <span class="keyword">return</span> invoker(ctx, method, req, reply, cc, opts...)</span><br><span class="line">    <span class="comment">// codes.Acceptable判断哪种错误需要加入熔断错误计数</span></span><br><span class="line">    &#125;, codes.Acceptable)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="熔断器的实现"><a href="#熔断器的实现" class="headerlink" title="熔断器的实现"></a>熔断器的实现</h3><p>zRPC 中熔断器的实现参考了Google Sre 过载保护算法，该算法的原理如下：</p>
<ul>
<li>请求数量 (requests)：调用方发起请求的数量总和</li>
<li>请求接受数量 (accepts)：被调用方正常处理的请求数量</li>
</ul>
<p>在正常情况下，这两个值是相等的，随着被调用方服务出现异常开始拒绝请求，请求接受数量 (accepts) 的值开始逐渐小于请求数量 (requests)，这个时候调用方可以继续发送请求，直到 requests &#x3D; K * accepts，一旦超过这个限制，熔断器就回打开，新的请求会在本地以一定的概率被抛弃直接返回错误，概率的计算公式如下：</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/r4ZYNR"><img src="https://s3.ax1x.com/2020/12/26/r4ZYNR.md.png" alt="r4ZYNR.md.png"></a></p>
<p>通过修改算法中的 K(倍值)，可以调节熔断器的敏感度，当降低该倍值会使自适应熔断算法更敏感，当增加该倍值会使得自适应熔断算法降低敏感度，举例来说，假设将调用方的请求上限从 requests &#x3D; 2 * acceptst 调整为 requests &#x3D; 1.1 * accepts 那么就意味着调用方每十个请求之中有一个请求出错就会触发熔断</p>
<p>代码路径为 go-zero&#x2F;core&#x2F;breaker</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> googleBreaker <span class="keyword">struct</span> &#123;</span><br><span class="line">    k     <span class="type">float64</span>  <span class="comment">// 倍值 默认1.5, 那么可以容忍平时 1.5 倍的流量，就是说 0.5 这么多的请求都是重试的请求。出错了就重试，直到熔断器打开</span></span><br><span class="line">    stat  *collection.RollingWindow <span class="comment">// 滑动时间窗口，用来对请求失败和成功计数</span></span><br><span class="line">    proba *mathx.Proba <span class="comment">// 动态概率</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自适应熔断算法实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *googleBreaker)</span></span> accept() <span class="type">error</span> &#123;</span><br><span class="line">    accepts, total := b.history()  <span class="comment">// 请求接受数量和请求总量</span></span><br><span class="line">    weightedAccepts := b.k * <span class="type">float64</span>(accepts)</span><br><span class="line">  <span class="comment">// 计算丢弃请求概率</span></span><br><span class="line">    dropRatio := math.Max(<span class="number">0</span>, (<span class="type">float64</span>(total-protection)-weightedAccepts)/<span class="type">float64</span>(total+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">if</span> dropRatio &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态判断是否触发熔断</span></span><br><span class="line">    <span class="keyword">if</span> b.proba.TrueOnProba(dropRatio) &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrServiceUnavailable</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次发起请求会调用 doReq 方法，在这个方法中首先通过 accept 效验是否触发熔断，acceptable 用来判断哪些 error 会计入失败计数，定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Acceptable</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> status.Code(err) &#123;</span><br><span class="line">    <span class="keyword">case</span> codes.DeadlineExceeded, codes.Internal, codes.Unavailable, codes.DataLoss: <span class="comment">// 异常请求错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果请求正常则通过 markSuccess 把请求数量和请求接受数量都加一，如果请求不正常则只有请求数量会加一。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *googleBreaker)</span></span> doReq(req <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span>, fallback <span class="function"><span class="keyword">func</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">error</span>, acceptable Acceptable) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否触发熔断</span></span><br><span class="line">  <span class="keyword">if</span> err := b.accept(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> fallback != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fallback(err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">            b.markFailure()</span><br><span class="line">            <span class="built_in">panic</span>(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行真正的调用</span></span><br><span class="line">    err := req()</span><br><span class="line">  <span class="comment">// 正常请求计数</span></span><br><span class="line">    <span class="keyword">if</span> acceptable(err) &#123;</span><br><span class="line">        b.markSuccess()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 异常请求计数</span></span><br><span class="line">        b.markFailure()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用端可以通过熔断机制进行自我保护，防止调用下游服务出现异常，或者耗时过长影响调用端的业务逻辑，很多功能完整的微服务框架都会内置熔断器。其实，不仅微服务调用之间需要熔断器，在调用依赖资源的时候，比如 mysql、redis 等也可以引入熔断器的机制。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/n9wpL6uSjza2nEprLbJDKw">原文</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/25/blog/distribute/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%20k8s%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/25/blog/distribute/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%20k8s%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE/" class="post-title-link" itemprop="url">虚拟化之 k8s 如何实现外部访问</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-25 17:27:56" itemprop="dateCreated datePublished" datetime="2020-11-25T17:27:56+08:00">2020-11-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">虚拟化</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="Ingress-是什么"><a href="#Ingress-是什么" class="headerlink" title="Ingress 是什么"></a>Ingress 是什么</h2><p>Ingress对象，其实就是对“反向代理”的一种抽象，简单的说就是一个<strong>全局的负载均衡器</strong>，可以通过访问URL定位到后端的Service。Ingress相当于nginx、apache等负载均衡反向代理服务器，其中还包括规则定义，即URL的路由信息。</p>
<p>有了Ingress这个抽象，K8S就不需要关心Ingress的细节了，<strong>实际使用时，只需要选择一个具体的 Ingress Controller部署就行了</strong>，业界常用的反向代理项目有：Nginx、HAProxy、Envoy、Traefik，都已经成为了K8S专门维护的Ingress Controller。</p>
<p>一个Ingress对象的主要内容，就类似Nginx的配置文件描述，对应的转发规则就是ingressRule，有了Ingress这个对象，用户就可以根据自己的需求选择Ingress Controller，例如，如果应用对代理服务的中断非常敏感，可以使用Treafik这样的Ingress Controlle。</p>
<h2 id="常见-Ingress-Controller-之-traefik"><a href="#常见-Ingress-Controller-之-traefik" class="headerlink" title="常见 Ingress Controller 之 traefik"></a>常见 Ingress Controller 之 traefik</h2><p>Traefik是一款开源的反向代理与负载均衡工具。它最大的优点是能够与常见的微服务系统直接整合，实现自动化动态配置。<strong>Traefik通过不断地跟 kubernetes API 打交道，实时的感知后端 service、pod 等变化，比如pod，service 增加与减少等；当得到这些变化信息后，Ingress自动更新配置并热重载 ，达到服务发现的作用。</strong></p>
<p><img src="https://github.com/traefik/traefik/blob/master/docs/content/assets/img/traefik-architecture.png"></p>
<h3 id="Traefik主要特性"><a href="#Traefik主要特性" class="headerlink" title="Traefik主要特性"></a>Traefik主要特性</h3><h4 id="自动熔断"><a href="#自动熔断" class="headerlink" title="自动熔断"></a>自动熔断</h4><p>在集群中，当某一个服务大量出现请求错误，或者请求响应时间过久，或者返回500+错误状态码时，我们希望可以主动剔除该服务，也就是不在将请求转发到该服务上，而这一个过程是自动完成，不需要人工执行。Traefik 通过配置很容易就能帮我们实现，Traefik 可以通过定义策略来主动熔断服务。</p>
<h4 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h4><p>Traefik 提供两种负载均衡策略支持。一种是 wrr（加权轮训调度算法），一种是 drr（动态加权循环调度算法）。</p>
<ul>
<li>wrr是默认的负载均衡策略，新创建的 service 权重都是一样为1，这样的话，请求会平均分给每个服务。wrr 就是根据权重将请求 分配到 service 上。</li>
<li>drr 就更加智能，它是一种动态加权轮训调度方式，它会记录一段时间内转发到 A 的请求数，跟转发到 B 的请求数对比，转发数量多，说明处理速度快，响应时间快。如果 A 处理请求速度比 B 快，那么就会调整 A 的权重，接下来的一段时间，就会转发更多请求给 A，相应的 B 的转发就少一些。整个过程都在不断的调整权重，实现请求的合理分配，从而达到资源使用最大化。</li>
</ul>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>…</p>
<h2 id="其他-Ingress-Controller"><a href="#其他-Ingress-Controller" class="headerlink" title="其他 Ingress Controller"></a>其他 Ingress Controller</h2><h3 id="Kubernetes-Ingress-Controller"><a href="#Kubernetes-Ingress-Controller" class="headerlink" title="Kubernetes Ingress Controller"></a>Kubernetes Ingress Controller</h3><p>Kubernetes 的“官方”控制器（之所以称为官方，是想把它区别于 NGINX 公司的控制器）。这是社区开发的控制器，它基于 nginx Web 服务器，并补充了一组用于实现额外功能的 Lua 插件。</p>
<h3 id="NGINX-Ingress-Controller"><a href="#NGINX-Ingress-Controller" class="headerlink" title="NGINX Ingress Controller"></a>NGINX Ingress Controller</h3><p>这是 NGINX 公司开发的官方产品，它也有一个基于 NGINX Plus 的商业版。NGINX 的控制器具有很高的稳定性、持续的向后兼容性，且没有任何第三方模块。</p>
<p>由于消除了 Lua 代码，和官方控制器相比，它保证了较高的速度，但也因此受到较大限制。相较之下，它的付费版本有更广泛的附加功能，如实时指标、JWT 验证、主动健康检查等。</p>
<h3 id="Traefik"><a href="#Traefik" class="headerlink" title="Traefik"></a>Traefik</h3><p>最初，这个代理是为微服务请求及其动态环境的路由而创建的，因此具有许多有用的功能：<strong>连续更新配置（不重新启动）、支持多种负载均衡算法、Web UI、指标导出、对各种服务的支持协议、REST API、Canary 版本</strong>等。</p>
<p>支持开箱即用的 Let’s Encrypt 是它的另一个不错的功能，但它的主要缺点也很明显，就是为了控制器的高可用性，你必须安装并连接其 Key-value store。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenqionghe/p/11726231.html">Kubernetes的Ingress是啥</a></p>
<p><a target="_blank" rel="noopener" href="https://doc.traefik.io/traefik/getting-started/quick-start/">traefik 快速使用</a></p>
<p><a target="_blank" rel="noopener" href="https://xuchao918.github.io/2019/03/01/Kubernetes-traefik-ingress%E4%BD%BF%E7%94%A8/">部署 traefik </a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Irving/p/9879520.html">Ingress 进阶</a></p>
<p><a target="_blank" rel="noopener" href="https://www.qikqiak.com/post/visually-explained-k8s-ingress/">Ingress 进阶</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/24/blog/golang/Golang%E4%B8%AD%E7%9A%84netpoller/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ivalue2333.github.io/percy/images/percy.jpg">
      <meta itemprop="name" content="Percy">
      <meta itemprop="description" content="IOT2014">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog | percy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/24/blog/golang/Golang%E4%B8%AD%E7%9A%84netpoller/" class="post-title-link" itemprop="url">Golang中的netpoller</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-24 16:21:22" itemprop="dateCreated datePublished" datetime="2020-11-24T16:21:22+08:00">2020-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 17:01:18" itemprop="dateModified" datetime="2021-04-07T17:01:18+08:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文档参考两位大佬的文章总结而出，主要是先简单的介绍 netpoller 的核心函数，然后通过一个 tcp server 的例子来详细解释这些核心的函数分别在何时被调用，以及发挥了什么样的作用。</p>
<p>Go netpoller 通过在底层对 epoll&#x2F;kqueue&#x2F;iocp 的封装，从而实现了使用同步编程模式达到异步执行的效果。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>epoll、kqueue、solaries 等多路复用模块都要实现以下五个函数，这五个函数构成一个虚拟的接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="type">uintptr</span>, pd *pollDesc)</span></span> <span class="type">int32</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpoll</span><span class="params">(delta <span class="type">int64</span>)</span></span> gList</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollBreak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollIsPollDescriptor</span><span class="params">(fd <span class="type">uintptr</span>)</span></span> <span class="type">bool</span></span><br></pre></td></tr></table></figure>

<p>上述函数在网络轮询器中分别扮演了不同的作用：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.netpollinit"><code>runtime.netpollinit</code></a> — 初始化网络轮询器，通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once"><code>sync.Once</code></a> 和 <code>netpollInited</code> 变量保证函数只会调用一次；</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.netpollopen"><code>runtime.netpollopen</code></a> — 监听文件描述符上的边缘触发事件，创建事件并加入监听；</li>
<li><code>runtime.netpoll</code>— 轮询网络并返回一组已经准备就绪的 Goroutine，传入的参数会决定它的行为<ul>
<li>如果参数小于 0，无限期等待文件描述符就绪；</li>
<li>如果参数等于 0，非阻塞地轮询网络；</li>
<li>如果参数大于 0，阻塞特定时间轮询网络；</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.netpollBreak"><code>runtime.netpollBreak</code></a> — 唤醒网络轮询器，例如：计时器向前修改时间时会通过该函数中断网络轮询器；</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.netpollIsPollDescriptor"><code>runtime.netpollIsPollDescriptor</code></a> — 判断文件描述符是否被轮询器使用；</li>
</ul>
<h3 id="接口阐释"><a href="#接口阐释" class="headerlink" title="接口阐释 !!!"></a>接口阐释 !!!</h3><ul>
<li>netpollinit 相当于 epoll_create, 创建全局的 epfd</li>
<li>netpollopen 相当月 epoll_ctl, 用于将 socket fd 注册到 epfd</li>
<li>netpoll 相当于 epoll_wait， 这里执行 epoll_wait， events.data 是一个 pollDesc 类型的指针， pollDesc 中有 g 的信息，将这个 g 取出来，并修改这个 g 的状态为可运行状态(pdReady)。</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>总的来说，netFD 表示网络文件， netFD  中的 FD 代表通用文件， FD 中的 pollDesc 表示轮询文件描述符，它是链表节点的结构，有 link 字段用于连接下一个节点。</p>
<p>用户层关注 netFD 和 FD， FD 中的 pollDesc 连接用户层和运行时， 而 pollDesc 连接运行时和内核态的系统调用。</p>
<h4 id="pollDesc"><a href="#pollDesc" class="headerlink" title="pollDesc"></a>pollDesc</h4><p>操作系统中 I&#x2F;O 多路复用函数会监控文件描述符的可读或者可写，而 Go 语言网络轮询器会监听 <strong>runtime.pollDesc</strong> 结构体的状态，该结构会封装操作系统的文件描述符：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pollDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">	link *pollDesc</span><br><span class="line"></span><br><span class="line">	lock    mutex</span><br><span class="line">	fd      <span class="type">uintptr</span></span><br><span class="line">	...</span><br><span class="line">	rseq    <span class="type">uintptr</span></span><br><span class="line">	rg      <span class="type">uintptr</span></span><br><span class="line">	rt      timer</span><br><span class="line">	rd      <span class="type">int64</span></span><br><span class="line">	wseq    <span class="type">uintptr</span></span><br><span class="line">	wg      <span class="type">uintptr</span></span><br><span class="line">	wt      timer</span><br><span class="line">	wd      <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该结构体中包含用于监控可读和可写状态的变量，我们按照功能将它们分成以下四组：</p>
<ul>
<li><code>rseq</code> 和 <code>wseq</code> — 表示文件描述符被重用或者计时器被重置；</li>
<li><code>rg</code> 和 <code>wg</code> — 表示二进制的信号量，可能为 <code>pdReady</code>、<code>pdWait</code>、**等待文件描述符可读或者可写的 Goroutine **以及 <code>nil</code>；</li>
<li><code>rd</code> 和 <code>wd</code> — 等待文件描述符可读或者可写的截止日期；</li>
<li><code>rt</code> 和 <code>wt</code> — 用于等待文件描述符的计时器；</li>
</ul>
<h4 id="pollCache"><a href="#pollCache" class="headerlink" title="pollCache"></a>pollCache</h4><p>runtime.pollDesc 结构体会使用 link 字段串联成一个链表存储在 runtime.pollCache</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pollCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock  mutex</span><br><span class="line">	first *pollDesc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FD"><a href="#FD" class="headerlink" title="FD"></a>FD</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FD is a file descriptor. The net and os packages use this type as a</span></span><br><span class="line"><span class="comment">// field of a larger type representing a network connection or OS file.</span></span><br><span class="line"><span class="keyword">type</span> FD <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Lock sysfd and serialize access to Read and Write methods.</span></span><br><span class="line">	fdmu fdMutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// System file descriptor. Immutable until Close.</span></span><br><span class="line">	Sysfd <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// I/O poller.</span></span><br><span class="line">	pd pollDesc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="netFD"><a href="#netFD" class="headerlink" title="netFD"></a>netFD</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Network file descriptor.</span></span><br><span class="line"><span class="keyword">type</span> netFD <span class="keyword">struct</span> &#123;</span><br><span class="line">	pfd poll.FD</span><br><span class="line"></span><br><span class="line">	<span class="comment">// immutable until Close</span></span><br><span class="line">	family      <span class="type">int</span></span><br><span class="line">	sotype      <span class="type">int</span></span><br><span class="line">	isConnected <span class="type">bool</span> <span class="comment">// handshake completed or use of association with peer</span></span><br><span class="line">	net         <span class="type">string</span></span><br><span class="line">	laddr       Addr</span><br><span class="line">	raddr       Addr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pollCache-初始化"><a href="#pollCache-初始化" class="headerlink" title="pollCache 初始化"></a>pollCache 初始化</h3><p>运行时会在第一次调用 runtime.pollCache.alloc 方法时初始化总大小约为 4KB 的 runtime.pollDesc 结构体，runtime.persistentalloc 会保证这些数据结构初始化在不会触发垃圾回收的内存中，让这些数据结构只能被内部的 epoll 和 kqueue 模块引用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pollCache)</span></span> alloc() *pollDesc &#123;</span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	<span class="keyword">if</span> c.first == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> pdSize = unsafe.Sizeof(pollDesc&#123;&#125;)</span><br><span class="line">		n := pollBlockSize / pdSize</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">			n = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		mem := persistentalloc(n*pdSize, <span class="number">0</span>, &amp;memstats.other_sys)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">			pd := (*pollDesc)(add(mem, i*pdSize))</span><br><span class="line">			pd.link = c.first</span><br><span class="line">            <span class="comment">// 设置头结点为新的 pd</span></span><br><span class="line">			c.first = pd</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pd := c.first</span><br><span class="line">    <span class="comment">// c.first 又设置为空节点</span></span><br><span class="line">	c.first = pd.link</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line">	<span class="keyword">return</span> pd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>网络轮询器实际上就是对 I&#x2F;O 多路复用技术的封装，本节将通过以下的三个过程分析网络轮询器的实现原理：</p>
<ol>
<li>网络轮询器的初始化；</li>
<li>如何向网络轮询器中加入待监控的任务；</li>
<li>如何从网络轮询器中获取触发的事件；</li>
</ol>
<h3 id="网络轮训器的初始化"><a href="#网络轮训器的初始化" class="headerlink" title="网络轮训器的初始化"></a>网络轮训器的初始化</h3><h4 id="runtime-poll-runtime-pollServerInit-gt-runtime-netpollGenericInit-gt-runtime-netpollinit"><a href="#runtime-poll-runtime-pollServerInit-gt-runtime-netpollGenericInit-gt-runtime-netpollinit" class="headerlink" title="runtime.poll_runtime_pollServerInit -&gt; runtime.netpollGenericInit -&gt; runtime.netpollinit"></a>runtime.poll_runtime_pollServerInit -&gt; runtime.netpollGenericInit -&gt; runtime.netpollinit</h4><p>因为文件 I&#x2F;O、网络 I&#x2F;O 以及计时器都依赖网络轮询器，所以 Go 语言会通过以下两条不同路径初始化网络轮询器：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/internal/poll.pollDesc.init"><code>internal/poll.pollDesc.init</code></a> — 通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/net.netFD.init"><code>net.netFD.init</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/os.newFile"><code>os.newFile</code></a> 初始化网络 I&#x2F;O 和文件 I&#x2F;O 的轮询信息时；</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.doaddtimer"><code>runtime.doaddtimer</code></a> — 向处理器中增加新的计时器时；</li>
</ol>
<p>网络轮询器的初始化会使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.poll_runtime_pollServerInit"><code>runtime.poll_runtime_pollServerInit</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.netpollGenericInit"><code>runtime.netpollGenericInit</code></a> 两个函数， runtime.netpollGenericInit 会调用 runtime.netpollGenericInit。</p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.netpollGenericInit"><code>runtime.netpollGenericInit</code></a> 会调用平台上特定实现的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.netpollinit"><code>runtime.netpollinit</code></a> 函数，即 Linux 上的 <code>epoll</code>，它主要做了以下几件事情：</p>
<ol>
<li>是调用 <code>epollcreate1</code> 创建一个新的 <code>epoll</code> 文件描述符，这个文件描述符会在整个程序的生命周期中使用；</li>
<li>通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.nonblockingPipe"><code>runtime.nonblockingPipe</code></a> 创建一个用于通信的管道；</li>
<li>使用 <code>epollctl</code> 将用于读取数据的文件描述符打包成 <code>epollevent</code> 事件加入监听；</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	epfd <span class="type">int32</span> = <span class="number">-1</span></span><br><span class="line">	netpollBreakRd, netpollBreakWr <span class="type">uintptr</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	epfd = epollcreate1(_EPOLL_CLOEXEC)</span><br><span class="line">	r, w, _ := nonblockingPipe()</span><br><span class="line">	ev := epollevent&#123;</span><br><span class="line">		events: _EPOLLIN,</span><br><span class="line">	&#125;</span><br><span class="line">	*(**<span class="type">uintptr</span>)(unsafe.Pointer(&amp;ev.data)) = &amp;netpollBreakRd</span><br><span class="line">	epollctl(epfd, _EPOLL_CTL_ADD, r, &amp;ev)</span><br><span class="line">	netpollBreakRd = <span class="type">uintptr</span>(r)</span><br><span class="line">	netpollBreakWr = <span class="type">uintptr</span>(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="向-epfd-注册-事件"><a href="#向-epfd-注册-事件" class="headerlink" title="向 epfd 注册 事件"></a>向 epfd 注册 事件</h3><h4 id="runtime-pollOpen-gt-runtime-poll-runtime-pollOpen-gt-runtime-netpollopen"><a href="#runtime-pollOpen-gt-runtime-poll-runtime-pollOpen-gt-runtime-netpollopen" class="headerlink" title="runtime_pollOpen -&gt; runtime.poll_runtime_pollOpen -&gt; runtime.netpollopen"></a>runtime_pollOpen -&gt; runtime.poll_runtime_pollOpen -&gt; runtime.netpollopen</h4><p>调用 internal&#x2F;poll.pollDesc.init 初始化文件描述符时不止会初始化网络轮询器，还会通过 runtime.poll_runtime_pollOpen 函数重置轮询信息 runtime.pollDesc 并调用 runtime.netpollopen 初始化轮询事件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> init(fd *FD) <span class="type">error</span> &#123;</span><br><span class="line">	serverInit.Do(runtime_pollServerInit)</span><br><span class="line">    <span class="comment">// fd.Sysfd 就是系统文件描述符</span></span><br><span class="line">	ctx, errno := runtime_pollOpen(<span class="type">uintptr</span>(fd.Sysfd))</span><br><span class="line">	<span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ctx != <span class="number">0</span> &#123;</span><br><span class="line">			runtime_pollUnblock(ctx)</span><br><span class="line">			runtime_pollClose(ctx)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> errnoErr(syscall.Errno(errno))</span><br><span class="line">	&#125;</span><br><span class="line">	pd.runtimeCtx = ctx</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="poll-runtime-pollOpen"><a href="#poll-runtime-pollOpen" class="headerlink" title="poll_runtime_pollOpen"></a>poll_runtime_pollOpen</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollOpen</span><span class="params">(fd <span class="type">uintptr</span>)</span></span> (*pollDesc, <span class="type">int</span>) &#123;</span><br><span class="line">	pd := pollcache.alloc()</span><br><span class="line">	lock(&amp;pd.lock)</span><br><span class="line">	<span class="keyword">if</span> pd.wg != <span class="number">0</span> &amp;&amp; pd.wg != pdReady &#123;</span><br><span class="line">		throw(<span class="string">&quot;runtime: blocked write on free polldesc&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> pd.rg != <span class="number">0</span> &amp;&amp; pd.rg != pdReady &#123;</span><br><span class="line">		throw(<span class="string">&quot;runtime: blocked read on free polldesc&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fd 就是系统文件描述符</span></span><br><span class="line">	pd.fd = fd</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 调用 netpollopen</span></span><br><span class="line">   	errno = netpollopen(fd, pd)</span><br><span class="line">	<span class="keyword">return</span> pd, <span class="type">int</span>(errno)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>本节将继续介绍网络轮询器的核心逻辑，也就是事件循环。我们将从以下的两个部分介绍事件循环的实现原理：</p>
<ul>
<li>Goroutine 让出线程并等待读写事件；</li>
<li>多路复用等待读写事件的发生并返回；</li>
</ul>
<p>上述过程连接了操作系统中的 I&#x2F;O 多路复用机制和 Go 语言的运行时，在两个不同体系之间构建了桥梁，我们将分别介绍上述的两个过程。</p>
<h4 id="g-等待事件"><a href="#g-等待事件" class="headerlink" title="g 等待事件"></a>g 等待事件</h4><h5 id="runtime-poll-runtime-pollWait-gt-runtime-netpollblock-gt-runtime-gopark"><a href="#runtime-poll-runtime-pollWait-gt-runtime-netpollblock-gt-runtime-gopark" class="headerlink" title="runtime.poll_runtime_pollWait -&gt; runtime.netpollblock -&gt; runtime.gopark"></a>runtime.poll_runtime_pollWait -&gt; runtime.netpollblock -&gt; runtime.gopark</h5><p>当我们在文件描述符上执行读写操作时，如果文件描述符不可读或者不可写，当前 Goroutine 就会执行 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.poll_runtime_pollWait"><code>runtime.poll_runtime_pollWait</code></a> 检查 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.pollDesc"><code>runtime.pollDesc</code></a> 的状态并调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.netpollblock"><code>runtime.netpollblock</code></a> 等待文件描述符的可读或者可写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollWait</span><span class="params">(pd *pollDesc, mode <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> !netpollblock(pd, <span class="type">int32</span>(mode), <span class="literal">false</span>) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblock</span><span class="params">(pd *pollDesc, mode <span class="type">int32</span>, waitio <span class="type">bool</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	gpp := &amp;pd.rg</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">		gpp = &amp;pd.wg</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> waitio || netpollcheckerr(pd, mode) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 当前 g 休眠</span></span><br><span class="line">		gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, <span class="number">5</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>runtime.netpollblock 是 Goroutine 等待 I&#x2F;O 事件的关键函数，它会使用运行时提供的 runtime.gopark 让出当前线程，将 Goroutine 转换到休眠状态并等待运行时的唤醒。</strong></p>
<h4 id="g-从事件中唤醒-！！！"><a href="#g-从事件中唤醒-！！！" class="headerlink" title="g 从事件中唤醒 ！！！"></a>g 从事件中唤醒 ！！！</h4><h5 id="rutime-netpoll-gt-runtime-netpollready-gt-runtime-netpollunblock"><a href="#rutime-netpoll-gt-runtime-netpollready-gt-runtime-netpollunblock" class="headerlink" title="rutime.netpoll -&gt; runtime.netpollready -&gt; runtime.netpollunblock"></a>rutime.netpoll -&gt; runtime.netpollready -&gt; runtime.netpollunblock</h5><p>计算了需要等待的时间之后，<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.netpoll"><code>runtime.netpoll</code></a> 会执行 <code>epollwait</code> 等待文件描述符转换成可读或者可写，如果该函数返回了负值，就可能返回空的 Goroutine 列表或者重新调用 <code>epollwait</code> 陷入等待</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">var</span> events [<span class="number">128</span>]epollevent</span><br><span class="line">retry:</span><br><span class="line">	n := epollwait(epfd, &amp;events[<span class="number">0</span>], <span class="type">int32</span>(<span class="built_in">len</span>(events)), waitms)</span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> waitms &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> gList&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> retry</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>epollwait</code> 函数返回的值大于 0 时，就意味着被监控的文件描述符出现了待处理的事件，我们在如下所示的循环中就会依次处理这些事件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">var</span> toRun gList</span><br><span class="line">	<span class="keyword">for</span> i := <span class="type">int32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">		ev := &amp;events[i]</span><br><span class="line">		<span class="keyword">if</span> *(**<span class="type">uintptr</span>)(unsafe.Pointer(&amp;ev.data)) == &amp;netpollBreakRd &#123;</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> mode <span class="type">int32</span></span><br><span class="line">		<span class="keyword">if</span> ev.events&amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">			mode += <span class="string">&#x27;r&#x27;</span></span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> mode != <span class="number">0</span> &#123; </span><br><span class="line">            <span class="comment">// ev.data 是 pollDesc 类型指针</span></span><br><span class="line">			pd := *(** pollDesc)(unsafe.Pointer(&amp;ev.data))</span><br><span class="line">			pd.everr = <span class="literal">false</span></span><br><span class="line">			netpollready(&amp;toRun, pd, mode)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> toRun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理的事件总共包含两种，一种是调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.netpollBreak"><code>runtime.netpollBreak</code></a> 函数触发的事件，该函数的作用是中断网络轮询器；另一种是其他文件描述符的正常读写事件，对于这些事件，我们会交给 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.netpollready"><code>runtime.netpollready</code></a> 处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollready</span><span class="params">(toRun *gList, pd *pollDesc, mode <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> rg, wg *g</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">		wg = netpollunblock(pd, <span class="string">&#x27;w&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 构建 g list</span></span><br><span class="line">	<span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">		toRun.push(wg)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.netpollunblock"><code>runtime.netpollunblock</code></a> 会在读写事件发生时，将 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.pollDesc"><code>runtime.pollDesc</code></a> 中的读或者写信号量转换成 <code>pdReady</code> 并返回其中存储的 Goroutine；如果返回的 Goroutine 不会为空，那么该 Goroutine 就会被加入 <code>toRun</code> 列表，运行时会将列表中的全部 Goroutine 加入运行队列并等待调度器的调度。</p>
<p><strong><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.netpoll"><code>runtime.netpoll</code></a> 函数返回的 Goroutine 列表都会被 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.injectglist"><code>runtime.injectglist</code></a> 注入到处理器或者全局的运行队列上，其中因为系统监控 Goroutine 直接运行在线程上，所以它获取的 Goroutine 列表会直接加入全局的运行队列，其他 Goroutine 获取的列表都会加入 Goroutine 所在处理器的运行队列上。</strong></p>
<h3 id="截止日期"><a href="#截止日期" class="headerlink" title="截止日期"></a>截止日期</h3><p>网络轮询器和计时器的关系非常紧密，这不仅仅是因为网络轮询器负责计时器的唤醒，还因为文件和网络 I&#x2F;O 的截止日期也由网络轮询器负责处理。截止日期在 I&#x2F;O 操作中，尤其是网络调用中很关键，网络请求存在很高的不确定因素，我们需要设置一个截止日期保证程序的正常运行，这时就需要用到网络轮询器中的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.poll_runtime_pollSetDeadline"><code>runtime.poll_runtime_pollSetDeadline</code></a> 函数：</p>
<p>在 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.poll_runtime_pollSetDeadline"><code>runtime.poll_runtime_pollSetDeadline</code></a> 函数的最后，会重新检查轮询信息中存储的截止日期：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">var</span> rg *g</span><br><span class="line">	<span class="keyword">if</span> pd.rd &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> pd.rd &lt; <span class="number">0</span> &#123;</span><br><span class="line">			rg = netpollunblock(pd, <span class="string">&#x27;r&#x27;</span>, <span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> rg != <span class="literal">nil</span> &#123;</span><br><span class="line">		netpollgoready(rg, <span class="number">3</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果截止日期小于 0，上述代码会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.netpollgoready"><code>runtime.netpollgoready</code></a> 直接唤醒对应的 Goroutine</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">var</span> rg *g</span><br><span class="line">	<span class="keyword">if</span> pd.rd &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> pd.rd &lt; <span class="number">0</span> &#123;</span><br><span class="line">			rg = netpollunblock(pd, <span class="string">&#x27;r&#x27;</span>, <span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> rg != <span class="literal">nil</span> &#123;</span><br><span class="line">		netpollgoready(rg, <span class="number">3</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.poll_runtime_pollSetDeadline"><code>runtime.poll_runtime_pollSetDeadline</code></a> 函数中直接调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.netpollgoready"><code>runtime.netpollgoready</code></a> 是相对比较特殊的情况。在正常情况下，运行时都会在计时器到期时调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.netpollDeadline"><code>runtime.netpollDeadline</code></a>、<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.netpollReadDeadline"><code>runtime.netpollReadDeadline</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.netpollWriteDeadline"><code>runtime.netpollWriteDeadline</code></a> 三个函数：</p>
<h4 id="截止日期唤醒-Goroutine"><a href="#截止日期唤醒-Goroutine" class="headerlink" title="截止日期唤醒 Goroutine"></a>截止日期唤醒 Goroutine</h4><p>netpollDeadline， netpollReadDeadline， netpollWriteDeadline 三个函数都会通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.netpolldeadlineimpl"><code>runtime.netpolldeadlineimpl</code></a> 调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.netpollgoready"><code>runtime.netpollgoready</code></a> 直接唤醒相应的 Goroutine:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpolldeadlineimpl</span><span class="params">(pd *pollDesc, seq <span class="type">uintptr</span>, read, write <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> write &#123;</span><br><span class="line">		<span class="keyword">if</span> pd.wd &lt;= <span class="number">0</span> || pd.wt.f == <span class="literal">nil</span> &amp;&amp; !read &#123;</span><br><span class="line">			throw(<span class="string">&quot;runtime: inconsistent write deadline&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		pd.wd = <span class="number">-1</span></span><br><span class="line">		atomic.StorepNoWB(unsafe.Pointer(&amp;pd.wt.f), <span class="literal">nil</span>) <span class="comment">// full memory barrier between store to wd and load of wg in netpollunblock</span></span><br><span class="line">		wg = netpollunblock(pd, <span class="string">&#x27;w&#x27;</span>, <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;pd.lock)</span><br><span class="line">	<span class="keyword">if</span> rg != <span class="literal">nil</span> &#123;</span><br><span class="line">		netpollgoready(rg, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">		netpollgoready(wg, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Goroutine 在被唤醒之后就会意识到当前的 I&#x2F;O 操作已经超时，可以根据需要选择重试请求或者中止调用。</p>
<h2 id="一个-tcp-server-的链路"><a href="#一个-tcp-server-的链路" class="headerlink" title="一个 tcp server 的链路"></a>一个 tcp server 的链路</h2><h3 id="net-Listen-函数链路"><a href="#net-Listen-函数链路" class="headerlink" title="net.Listen 函数链路"></a>net.Listen 函数链路</h3><ul>
<li>internetSocket<ul>
<li>socket<ul>
<li>s, err :&#x3D; sysSocket(family, sotype, proto) - <strong>系统函数 socket</strong></li>
<li>fd, err &#x3D; newFD(s, family, sotype, net) - <strong>new netFD</strong></li>
<li>fd.listenStream(laddr, listenerBacklog(), ctrlFn)<ul>
<li>syscall.Bind(fd.pfd.Sysfd, lsa) - <strong>系统函数 bind</strong></li>
<li>listenFunc(fd.pfd.Sysfd, backlog) - <strong>系统函数 listen</strong></li>
<li>err &#x3D; fd.init()<ul>
<li>fd.pfd.Init(fd.net, true)<ul>
<li>err :&#x3D; fd.pd.init(fd)<ul>
<li>serverInit.Do(runtime_pollServerInit) - <strong>创建 epfd</strong></li>
<li>ctx, errno :&#x3D; runtime_pollOpen(uintptr(fd.Sysfd)) - <strong>注册 listenfd 到 epfd</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="listener-Accept-函数链路"><a href="#listener-Accept-函数链路" class="headerlink" title="listener.Accept 函数链路"></a>listener.Accept 函数链路</h3><ul>
<li>fd, err :&#x3D; ln.fd.accept() - <strong>netFD.accept()</strong><ul>
<li>d, rsa, errcall, err :&#x3D; fd.pfd.Accept() - <strong>FD.Accept</strong><ul>
<li>很重要，看下面的 FD.Accept</li>
</ul>
</li>
</ul>
</li>
<li>netfd, err &#x3D; newFD(d, fd.family, fd.sotype, fd.net) - <strong>通过 accept 到的 fd 创建 netfd</strong></li>
<li>netfd.init - <strong>netfd.init 将这个文件描述符如 走 listenfd 相同的 init 操作，将这个 connfd 加入到 epfd 的监听队列中</strong></li>
<li>return netfd, nil</li>
</ul>
<h4 id="FD-Accept"><a href="#FD-Accept" class="headerlink" title="FD.Accept"></a>FD.Accept</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Accept wraps the accept network call.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span></span> Accept() (<span class="type">int</span>, syscall.Sockaddr, <span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> err := fd.readLock(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span>, <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> fd.readUnlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := fd.pd.prepareRead(fd.isFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span>, <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 系统调用，非阻塞</span></span><br><span class="line">		s, rsa, errcall, err := accept(fd.Sysfd)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 accept 了，那么 返回这个新连接的文件描述符 s</span></span><br><span class="line">			<span class="keyword">return</span> s, rsa, <span class="string">&quot;&quot;</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> err &#123;</span><br><span class="line">		<span class="keyword">case</span> syscall.EINTR:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">case</span> syscall.EAGAIN:</span><br><span class="line">            <span class="comment">// netFD 在读写时出现 syscall.EAGAIN 错误，通过 pollDesc 的 waitRead 方法将当前的 goroutine park 住，直到 ready，从 pollDesc 的 waitRead 中返回</span></span><br><span class="line">			<span class="keyword">if</span> fd.pd.pollable() &#123;</span><br><span class="line">				<span class="keyword">if</span> err = fd.pd.waitRead(fd.isFile); err == <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> syscall.ECONNABORTED:</span><br><span class="line">			<span class="comment">// This means that a socket on the listen</span></span><br><span class="line">			<span class="comment">// queue was closed before we Accept()ed it;</span></span><br><span class="line">			<span class="comment">// it&#x27;s a silly error, so try again.</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span>, errcall, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="conn-Read-buf-链路"><a href="#conn-Read-buf-链路" class="headerlink" title="conn.Read(buf) 链路"></a>conn.Read(buf) 链路</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TCPConn <span class="keyword">struct</span> &#123;</span><br><span class="line">	conn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> conn <span class="keyword">struct</span> &#123;</span><br><span class="line">	fd *netFD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终是走到 FD 的读函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span></span> Read(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">   		<span class="comment">// 包装系统读函数         </span></span><br><span class="line">		n, err := ignoringEINTR(syscall.Read, fd.Sysfd, p)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			n = <span class="number">0</span></span><br><span class="line">            <span class="comment">// // err == syscall.EAGAIN 表示当前没有期待的 I/O 事件发生，也就是 socket 不可读</span></span><br><span class="line">			<span class="keyword">if</span> err == syscall.EAGAIN &amp;&amp; fd.pd.pollable() &#123;</span><br><span class="line">				<span class="comment">// 如果当前没有发生期待的 I/O 事件，那么 waitRead</span></span><br><span class="line"><span class="number">50</span>				<span class="comment">// 会通过 park goroutine 让逻辑 block 在这里</span></span><br><span class="line">				<span class="keyword">if</span> err = fd.pd.waitRead(fd.isFile); err == <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		err = fd.eofError(n, err)</span><br><span class="line">		<span class="keyword">return</span> n, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="conn-Write-buf-链路"><a href="#conn-Write-buf-链路" class="headerlink" title="conn.Write(buf) 链路"></a>conn.Write(buf) 链路</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span></span> Write(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> err := fd.writeLock(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> fd.writeUnlock()</span><br><span class="line">	<span class="keyword">if</span> err := fd.pd.prepareWrite(fd.isFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> nn <span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		max := <span class="built_in">len</span>(p)</span><br><span class="line">		<span class="keyword">if</span> fd.IsStream &amp;&amp; max-nn &gt; maxRW &#123;</span><br><span class="line">			max = nn + maxRW</span><br><span class="line">		&#125;</span><br><span class="line">		n, err := ignoringEINTR(syscall.Write, fd.Sysfd, p[nn:max])</span><br><span class="line">		<span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">			nn += n</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> nn == <span class="built_in">len</span>(p) &#123;</span><br><span class="line">			<span class="keyword">return</span> nn, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err == syscall.EAGAIN &amp;&amp; fd.pd.pollable() &#123;</span><br><span class="line">			<span class="keyword">if</span> err = fd.pd.waitWrite(fd.isFile); err == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> nn, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> nn, io.ErrUnexpectedEOF</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tcp-server-总结"><a href="#tcp-server-总结" class="headerlink" title="tcp server 总结"></a>tcp server 总结</h3><p>首先，client 连接 server 的时候，listener 通过 accept 调用接收新 connection，每一个新 connection 都启动一个 goroutine 处理，accept 调用会把该 connection 的 fd 连带所在的 goroutine 上下文信息封装注册到 epoll 的监听列表里去，当 goroutine 调用 conn.Read 或者 conn.Write 等需要阻塞等待的函数时，会被 gopark 给封存起来并使之休眠，让 P 去执行本地调度队列里的下一个可执行的 goroutine，<strong>往后 Go scheduler 会在循环调度的 runtime.schedule() 函数以及 sysmon 监控线程中调用 runtime.nepoll 以获取可运行的 goroutine 列表并通过调用 injectglist 把剩下的 g 放入全局调度队列或者当前 P 本地调度队列去重新执行。</strong></p>
<p>**func sysmon() 函数中调用 list :&#x3D; netpoll(0) , 传入的 delay 为 0，表示不阻塞，这也符合 sysmon 的定位。netpoll 最重要的调用就是 n :&#x3D; epollwait(epfd, &amp;events[0], int32(len(events)), waitms)， **</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/">draveness 网络轮询器</a></p>
<p><a target="_blank" rel="noopener" href="https://strikefreedom.top/go-netpoll-io-multiplexing-reactor">Go netpoller 原生网络模型之源码全面揭秘</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Percy"
      src="https://ivalue2333.github.io/percy/images/percy.jpg">
  <p class="site-author-name" itemprop="name">Percy</p>
  <div class="site-description" itemprop="description">IOT2014</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">157</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">194</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Percy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
